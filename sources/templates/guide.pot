# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-24 00:59\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# a197459044094cb59e592b4208ca8ebb
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# 8c29cc82c58d4b55a5e3fa2cf9646114
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# 62351349f9a04f91a1f3b22e24065cdf
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 1cd981feaf7142da8fa8c4e5a850ccf7
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 725fcb6470594f1ab7957cbf4408a0c8
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# bf1d6d0f96c14fafb58ea90dba7a1988
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# f0227bbc76554877b396a1ee86b443c4
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 63f0fde01b3e45499e7dbc790a470e88
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 7c353620ff5e489790ead5fd20a3c0e3
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# f3a8b7daa1e34fa781732412448841d8
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 0a97b69efc0e4dd3b6036238ba83c016
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# 069db7b6ec1a4c26be7753ee6a4eaf70
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# da0fb092c82749e795bc07e0222d44b9
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 49433586de43497fb8b44aaf7783a3bf
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 1f3136540a444977b46ab85395fd3ec9
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 1498ae0279354d238e5ecf56da11fef6
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# f93e42365a164a888a225dfd477d9ba3
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 5bd0fec0281643a6aafae51907385277
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# f0d7e7d600314c0d97cdb197f9bbf769
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# a13cb532d9ee478fb2a84cd235483353
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# f0bb69d337384cd2aad2414078800c12
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 4a50db1767b54a038f33829ac67a2b08
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# cb0288e4d19f411999518f65d6377490
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# 1114b29861fa4a369ca01304dd1d94dd
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 6b8edac7d4be4b9dac4dd8148a7e6245
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# a59ea716f9e747a5b3bb534c06fad62f
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# fce2e55a87c94c78a04e3685f033b2ac
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# 778e306d20714be9b3ff04db906bc7ca
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# ed901b05700a48b4b63c88b033c4e893
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 748c8bc9b13f484daa64a5c9214fe895
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 7107df2c93a24e62afb68e1eacb226f1
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 8480d34fde47444fb807abf8137b7845
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# d79c74a7fdee4e9197f658347d072a23
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# 60e08f792da14ad5a2ebe0a75b31db0c
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 323f1772e10d458fafbcee15e5bff230
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 24d02484f928416f86de3903280ffd5c
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# b6368766e1e8413eb2a01e99367292e0
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# 8050d0f8a046489d80073ff98405850d
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# ba5e24cc39c2429a9186f1dcd5a2a954
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# eea1e1b5546c4f8fb308f8481e14b46b
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# f3acccfd05d143f1af669bb4cb1cc0b7
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# d1fde5fdbcf34d3c9a7737693c7b65c6
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# b131ad081bd842bda7feb1632138faf3
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 33e9ad72c2be4ebd8b585c73f7702606
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# aa4729aca90a40cd8ff921f9c51a1479
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# 2333b535045547cf85703b38971dce28
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 94b46e975a12441497f2767861040f5e
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# bab63f8ae6784315918c146c3ca4e186
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 4ec4d8c38121458d82529cfaebf15702
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 7723b2e4ff5a4bdb9859a670f6348e08
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# de32395b30ab4db8879c4c146de2027f
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# e078826139584c3b96f0cac00a7ee156
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# b1afc2f4e2894b3e9f215766901d3484
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 9ec5a45d0260463d8e3f0d03ea992bb6
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# ba05b364513f4a54bf5c2d011491b437
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 98df835f5fb34251966d3e782b351ca5
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# a5326431477d4b4e9d7d7d6567e05b85
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# c4ff11e618d44ac8a8551d34f399d37d
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# e53a4cb9e6b2421a8622376a52245727
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 33f6c627583d44a7af56044bf70f47aa
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 9bdb526984c548bcaf5e08ec4f051b90
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# ba6c583f4a8841cf9659c0e0a4a83a31
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# 1d143c7e0dba46cca65c30fb384067b7
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# bc10fc69601148f280dd6c7d2b4b478b
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# b46dad3284cb4f6bad3b703fd10f7ee1
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 694b5a87c36041b99cdd49f988da5aec
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 900115f5f79d4825b72f634a64fe64ca
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# ed7bac963c3e4bb8ba614323a2cde55b
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 0fda7db168644ab3996d7aec085c6c1d
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# d3b49d00706c4029b2a22a518ed13975
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 09ecae8fa4bf4d82948aa4551c9fcab2
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 2a3f2400d7304a828783873c4d41ec37
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# d21797a5bdfa4417a782d3b8547bc72a
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 55f33520264548c2b4644be1d4fa030c
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 506585776f0944f281f7a9b468d38f3a
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# edaf6faaaea14490b2544af24cbde787
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# f0c7701b368f40a0bfe44eeb3367f1b6
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# d50537b7547d434c9b29f0632f56902b
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 7c9c733b948e43f0b00409c3e7263565
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# b3f0ca601c054843bf8d46ea0bfb001d
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 811b42963e9144b894c03964f61589e9
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 313acfdcb6604101b36478c9e1a05d55
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 8d08fcc11c0d4ac0af2437f13eae0098
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 1705afdcdf3b444c92ac87d0378f0ce0
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# f16c53cc3293459f831155c223a877ce
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 9da8030e16a44358918c2c3ca663b2c6
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 60be41e1c27c46c8a5b3c87628a02865
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 2360a778b847470792fa17a502e99b75
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# d7116daf3e804268809444cd4f7838ba
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 71443d95deab48b3a1caec160f9667bf
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# 97224e6dc6f0463d96a182ea6a84469e
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 3039877b391147faa03a910ad774665a
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# b8718eb90a69412aad30e9bec092fceb
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 5ba23a89c1904ee0ba5616ef5daacc43
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# b6c76be4efe14bdfb32695de6a218f03
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 35bed1fc8f194e0a97793fefafff9315
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 5ba24cecd2954d6896cba041251668cd
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 4087da43425c4be586dc8801db3b218c
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 121aad36f3724a22abcd8b69e47d444e
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 5b2f3f5b3b0f44369a9662ebfaf1f327
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 1eda9cb007b8428aa1b295b61bbefd1f
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# c7fae3d7a2c94ee8b33e9349efe8213c
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 472ac79a3bee4e95ad815e01415106a0
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# be85d2c8e4fe42748a2ce7173556ce75
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# c84638f1f1fc4b248198a3a2ac918a51
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 5533d1427a2740038be97a2bf0cf639d
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 5c0ec1edcd9045908ca066002c13c1cc
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 6a72d0f07bd04ae0ae1c38145792bac2
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# c98ba01d9d1e46238c06185ad202ec0e
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 272c230d43dd4727b39aac5ece21bf11
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# d6f297a15031482da8c2438979b7196f
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 55ade026e7894f62a6df3f6c75c5557b
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 568912c8a5074d55bb6fa8574cda4a4b
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# d08a6c2979554957a2edaabd26967221
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# 4acf88e2366b4220a156b38cb29ae484
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# d0c0dd203e1d42d08e9137ef1116e384
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# a0d1ae01a3264ce5804165252b70a3f0
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# cdafac932a904827b2cddb9191c3a9ce
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# 1cbd9314a3824a4c84c08eaa8c17d7b2
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# 67b1decbde384234ac3fdda37231d619
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 523d95761b41438ea06d8bc8bec618f7
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 153ab3f9fecd48539087df8e5ecb26c3
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 86d4c23af22b4fb8b82a74989328abf6
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# c2bfb412399b4f608365e9d9ddbf9853
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# c2f5e02f127d4e44ac50b2db693345d7
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# bd832ee9385e455b849ae040b67dc2cb
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# db835f0b1a4f46b6bd7550fc3e9b163f
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# a11589ab1e004693b249507857b11f3b
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 96525e0dab964cb7af8212c09a767d98
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 8279c4b064394c8a88ff012712dc062e
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# c608f8ac86db46ab988aa33ee2770345
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# a69d0cfb3362458aab52bb46073b0c3d
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 398a7c0f55634f61879d76b6787b6ba8
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 781a7c6dc8dd4716a367d2e7265d3e57
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# ce714f77f4ae4e27b7e8edc012e11a1b
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# f7fd729e25674cf09e2252507afd2bbf
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# deca807d9323466aa330e5ea71e3de3f
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 10575021b53f47f08d1336be91a9f3e4
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 52b6350df8e84d268a9f8c225acc729a
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# ee876676bc9744a3a52ba83326ec1bdb
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 63fc1dda1ca047419aaaab188e654e7f
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# f554305ac2ef48a9a66359031cf5e20f
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# d2b7c255745b4dd29ac53e82b0c801bc
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 047bae9ea6854111b53caa1a2c54576a
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# c714b04bc5384100bf7d33a35f753ed9
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 0df6efcaf14244c898d64559390e930d
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 0d2dab3499434617a49fca014ab8cfe3
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 59bc9e28ef044280b8634d476a7937b8
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# b2455d690b4443f69da462439821ac9d
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 61275494dcfc4e72af1bff6abec38e07
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# ba028ef83c434eae8b5d66da0060f5cf
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 0766f4ff8f7446ad8e6a62cc5c71091b
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 11bfc52ca7b040f0bb884ca49739537a
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# bba53cefb3ee42a8987fbd547232d3a7
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 3228183c21fd4ecca3aa77119b9f9b16
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 9dc2605c105f4e5c83e60df3985bef62
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# 14c908e316ec473db5f9b8513fb0a112
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 77c2caf42aac4570a0ff7bdcb9c2c265
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 14c397a103fd4dbe949c19d02b090a72
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# d40a694d52b2476687024715ba47e0bd
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 39e79e0931bd4d4d8c7ead9b9207b3c5
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 08f9646940f74663a9fb7eb093ca4876
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# a606b44027c04c71a81816e5a0a04ffe
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# bac93aa364054ae398771e4fe4f94994
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# e462a390bbaa45c9b9183365fcf4d806
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 16e0c9637e534851b5a69045d059143a
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 628d04c7c3624025937e6249e6b1d204
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 5039c595f21f42a98bc219feb40bdc67
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 5b8ced4f8e0f4612a9ce05ad73088360
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 6c5746aad6a64ba18e1af0a37eeae404
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# d7abb34cdad144afaba72193a8d48264
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# ff0cf9641b7d430eafb4282a3ace7c48
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 51d2cac747644eab91e779f0bb3224f1
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# fb837e57585c4d77b5fdd1907d6ad9fc
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 95727c27346d4084a4ad65fee8db4bd6
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# 18a1035d19244fc3b10a8b50788b256f
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 9f675d9c9fc741c7ba2f325a16a05803
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 9fa40c9529164fd9af02c423691c3fa7
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# d457b9091328432892c79942c69becef
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 571a7654a1754c3bbc2837fe1fd987e5
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 21896a1a901c493cae13200eab8c8ba2
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# c48e91eb46324045962f7763d914fcc4
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# fcba43c807cb44b78c4d7b6d10267ac5
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# a15a7d5c4b5544ef84e2df82438ee530
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 0b2dca48b4834822a3027c78f9df8faa
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# da762be328064112b87966a9708a3609
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 4665bfb98b4c4d1a82b41c895218fee9
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 8409d136e7224a4eb77eff13f4bcf171
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# a7e7c4cde5ab44e28a1327142681dc0f
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 5098fdb8e2fe42fe94fbe177355ae243
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 0d2c294f7a9145bfb1e35871b71a3b0b
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 696309bba6e34bd09c83758af7b68745
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 14138f9d637a4708b533045a1cb30ddd
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 3b9c2fb1b32a4f43892b6bfa310a95fa
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 42a7044df28242619e9c92f2f5514fb1
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# fdb3fa474f094ea09010983cf703273a
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# cd187fc085a84771a1d2810835cd0c8e
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# b1d377122f0f40b290a752a77e06ad48
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 966f0da4726c433fb07cab49c59fbd5b
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# dfa69c373e1149828a50e80ac58c501e
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# aad4a05d09c447dbbafbae862df03a1a
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 0520eb39c9dd46afb1249da97056c2c3
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 10d95cf44dc64509ac4b3f08859571d7
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 9262299790db4cf39379365f04aa90f7
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 07dd7dd85a204f5486c4e3207c7ab693
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# e63e46b7cf424dcc99536ea5a4289176
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 977ab61ec3bd414fa69708ef3ba20811
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# c4856fcf08ec434da7413b7ae62a2c31
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 06a1c827809f4fbdba741f8743648e3d
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# f536146fcfab474b8934b3660933e741
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# e093f5bbd5c8449aa8c601d9d3747d62
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# c9288a0b1a78428986f30f97b0a52919
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 42cf0f39c8ce416898c5036d510573f6
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 3776fae7880e46cd801782de57fd5314
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 1f7119e2b92b40299e4138dea3fbc938
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# d56804e5a2474103bb363a6b2e69156b
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 5c5debd7023641d590e671ce157a0758
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 7c3081db34cd417eb5546eaf6f5b8a82
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 17a5a2c5f5fa484a96731e08de2514e6
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# c27d41781bc24ca88c241ea6664f7c66
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# fc9c187fb3c3413da8acdbaf80b10b40
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# bcd2e95e06794234b7bdcfb154d25906
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 22acb10a9a1f42d4b6f33f293efe621a
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 6c72349cb13e45fa89d3218dce57597a
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# faf21390e58b48d78b0aa4537149fec9
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# ddbebf399ddd49aca1a47bb4cac1a47d
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 34c60568106a441fa15d5b9bf06e659f
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 4cd367d0d4ee4400be7fe16e1a2f082a
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# c808a3b9eb7b41a5a7bddbf875774244
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# c0e5921cea5644d1b19795378519d263
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 7387274b067447028e25cb6ba924c93d
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# 26e05d9a994a4cc5b30b5dd8ffb6b50c
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 14eed6c925d0448c86c622e37e8d8de8
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 3a634c61b39346ceb7e6347eb9a0f229
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# c55e2aa55f3f4353988d58f84422e548
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 798cdea01bd24140b8c4851df413be28
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# 68a6fc9c0bc547ec884e36eb3a62193e
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# f7a291cb9b774da48f54e8439c3670a9
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 82e6e3dc1cac419eba7097d5e306bcf6
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# ac40b8258db74a7a932c7a35f0f7ce30
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 50fb81b0b0444403874c675ebb017e12
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# e9459306bb28403aa9a646608f9a9a80
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 782f21a5728e484fa93a6c961c723da0
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 3cffbaf7d32043cc8bb2dcf69574d8e1
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# c08e41279da949559c6d94504923e5f7
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 3a3c16071f4149c1beeb3df88162a93d
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 120f0c4cf9b949c4a3f05a016bcfa94b
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# ab4830e294ee4945b59702193066e6a8
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 11a83bdf30d148d0acccb87d4bd44a8e
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# 6fd1c98547414e42883248e0dec9b590
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 51b0c0f038084780b2bf31fe238a0db6
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 76a40532796845e28ff6ff78fca5f6fb
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 4b2986120e664f74a08b280e9c14b640
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# db32a1e370594543bdb986f38fc9c685
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# ad465ef551ac4cddb25a9c44aaeee8d8
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 11c0fa9e6f904e338f7a10c72bbbeb8d
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 13c849b01b9d4d69b5437a75ae2eccd4
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# bb02b220f6e542ec9bbf223119f51914
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 064ece8dc9a5437cb418a80554dcef06
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 0284018effc6483a965e1cdfaed95959
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# a16135f83681417e8319c8ce80454b47
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 0595576221da48cc9938463d800434af
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 3f7e17be402f4460a8734fa971087487
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 10cfe79e806e4ea7ac7d714363a165ff
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# e48252e1744c4c2791cdfddb4b601368
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 5de4f8bc137e4a129f16a36ed3a47d4c
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 1a420315288949689e4fe58d36d19afe
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 0b699083bf7b462f8682f1d6684e432c
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 4227874037a64abbbdbce4034de53304
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# 61d4047b9785415ea299adce1196be90
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# d2ec5b19cc024a69adfe477436e549d0
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# 9615eb86c41149aaa0794da35fb28989
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 2a1ebff279d04784b53715516b35168a
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 6ee9a098702b4886862e12aa9de8ccde
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 0df61de96c7b4eaea7b40773a07b44a5
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 38e55fec189c4049ba964a03ed67a0bd
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 456c7817fc3d4f3ba1190f4ed480843e
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 135250812a3140efabc27d478b4dad18
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 6c9da9c49dd14991b18217165821ef14
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# 63dc1e426cd0496f831fb30c80e7c477
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# f4864ea5b432413caf75210c33c41443
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# ff7ea58009da47259e5c9ec4dbb72b18
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 87ca52f9cabe4cee820d65ee11d9ea4d
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 3a3a475cb5684c5cb924a9df8438364d
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# b8604017ee5d4804b5b9add026b25bbc
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 525bc74397534c42b9710fbcaf03cda8
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# d81f6571598b4a979c8ccf903e46048b
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 79cd761a68ee4909a600e6295c8915c4
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# e80d263ef3204bcea1ebd72bc8c65101
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# f20eed6304f94888ad49aece537bb892
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# aa27fe2d548c481bbff359bc82f8aa4b
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# baf7e3679b314f14bb90367c460a38ce
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# e61e1970a971477a93ebad3b5518de77
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 0ba911c909ea493381344f40b32d6109
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 61217ab877324a2c91e89f4e840603e4
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# cc3674423260496b9318797fb667c3ca
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 2fc494da4a7f40c5bbcefc681676619a
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 0828acf4c2454737890ccd256ee01025
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 1c4ef0731b5543839e3a1ee8b8c144a7
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 7ee15d9778ba4e30b6e6b9638b8c8b5b
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 4cfcf750bbaf4a65a8e8c1a853a31edc
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# a88b654c5e674f1197e2785689cf5953
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 20f9d0702999445a870bb08f5d38179f
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# c47cf3cc1df34f8985938f2a5157248e
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 7f4cdb523f4d420b98ba171009501029
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# ead112439e684bb58516878ac3896afc
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 1ce57c9216774d7c9c635ca46b8dd5cb
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 522ac6e5815d4576988176fc09068225
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 9a2b6ff8457a40c291194ed468221a14
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 3a03c3e84f394061bfeed76207b13dfd
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 4171c6ec45f4408a9856e0bc9a43c33c
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 1e41b1ea1a3f4597a611a9f99c7d8803
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 92e391c458ad4ba28e76cc02f1946504
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# e59e05f8fc35452e9b27edb29c7c9495
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 0a4f52c63eff4a33a1fba82e400c616e
# ca5ec9fefe53479e88d3c2acdeb9516b
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 51cefb71223e40be8349bab2fea7ce72
# af503e6a47224fcb9aeccb7cc4b8905f
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 480387f3e40b48c6b4df8f89cb648215
# 95b9a3d0ffef41c9a3608bdfaf71abd3
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# 7f3899f7d5864432b05d6e37a8dd0e1e
# 8535023bd36e4975ab45ce0c90ce065b
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# b148843a0ec54341a0226ecdd2446304
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 023d7ec4638949aa85277a6d8cae9726
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# f1a6ff26353142a49e257823790e7f90
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# be1f23c4719f47daa37ab9a785505f5d
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 34a78052757246988c5e2e25fd3aff97
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# e1f5d69be5e14b3799fca22c2e4b594e
# 38cb47b83e974dbd91423257d806adf8
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# 86e15a24626740bd8a93b5286839208f
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 47502d5ef7a94838bff392b1b6a0bc40
# 2a1aa52c571b4500b1e0fddbada58a20
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 39d37e677172445dafe0fc19bc3d6446
# 1e97a52ff9364094afd384752da73b5b
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# b0cf671b3c8e4720b0b413fc5ef760f4
# 03cb70137c1e4ca989bcbdd4913d8f97
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 058bee15eea146478ca8f8dad74c2f3f
# 7c243eeda2d44655b0f83d33d97e6120
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 751cb939313443e0bcb4931fd60e7d04
# 9797bcb523854906ba9aee132279579e
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 62d2241af4774a4d9ca1ea00f575d98e
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 0d9c692f2b87495a99677f91d63df588
# 922f976f9c0a49adbc7b634780768939
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 417aeae6a09540608a1655960a67bd2a
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 38cb82b296ae46769b489a26dcbcb6ee
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# de7549104dc84f6b877221f1dac4c518
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 8216e4962ae04b6dad3e311efb0321c0
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 00f53900fbe6431e9a6277d7d5673201
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 0f68675c4b484ad4abe09ce2906d53b3
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 2e253458d69d4c4b92484666597ebf68
# 35a1b5c8749f450ab6b3997f3d9d1925
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 212233ecdc1b4a4fa330f4b20279d6fe
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 3d906d7fa7944ed9ba734943e3aa5a7c
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# 06615e9aa4984f949c560982d317ca86
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# c43dccb7b07245869c966a24f506a01c
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 68844a77869f48bea4815c8c701dc888
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 4e90ea80c06a4edfb9c39215d816bc8f
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 4aa5c1c7f0394eb088c4a051590bb171
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 6fbac07455ca4034a13f210344e84014
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# 4c59afbfe7444854b9510673b4a5f8cb
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# bd5ff99ea3af4e6aa03e7f254a354863
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 3efd8d03af3e46f1811897ab1794b7cc
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# f1da88ac6cb04d9fb9facc91214dac17
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 30f676ff53084127b52b92a69cdb4325
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# c2422fa3c6b44074b656d2a7a05be40a
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# d1e68554f9594734b6a1922f997870d2
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 88ff2fb9021b436eaffb83667acb2835
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 9424c896233b4554af7b2998d5444245
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 56c7cfce3d6f433d88e217b7051efa06
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 567f5fda50cf496d82169cffcc7604ec
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 34bcc064d6e840d29ae4221d6a965bff
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# b01c9ff3276e4cb98bf8d3ace981d9d4
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 2808d1da474948a0b47e91fa4676bb49
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# ed80bab44f7b4ae1a642e66733123094
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 4ba897536f04407eacc347077f1cd86a
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 2f5dd7c42fe5425bb627e4435af601f6
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# a350cdcffc20484a9b2da45d9c1b31b4
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# afdc364740024ca98215fdf914fc6baf
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# d1f895af0c7d494d9a2d06a16d9478de
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 70a4c00a8d5a480badbe2c4de99c4525
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 1fb2e2091a7546c0bfeba0e7355c6ed3
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 2374457cba5343d0a7f4773f4ad934e8
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 09aa8f41388f499ca9370b48933cda14
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# 0585916fa7084389b7ef07ec7817d642
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# d69077cd08de4e348fe8dd7d848f2bec
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 52d9e59063e242c6b9d58de45d54a26d
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 7306541576624c32a5875aa5de3cc30c
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 71accd8f833e498fb44cd39b22ed9d52
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# dbcc4064990648679717b318f4f2fd53
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 487bc197fdeb44c7b9f9549f816bc961
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# f5b1424deff94c6a8379a36d7f8f7a24
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 77f6112f3e1242bc9eb806c5005ec5c1
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# f99385c9418b4902ae4a247766fe4488
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 2a85cef8787444d88aab6df8a31dd5fc
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 6c11c1ddd86f4c2da22b77093b08ef5a
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 6817fd44ace1426f89b4ed343c83548b
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# fa5a012fb38948148245b54aba7f77be
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# 82745d3517e14d07a95515ed2c8f8c55
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

