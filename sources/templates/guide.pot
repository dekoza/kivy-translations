# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-04 16:54\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 8befefeb5188473cbcf3a627b79c47c1
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:7
# 6bc27ef78326423f8866a1baf84883e5
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:9
# aba175c0635e4e86a54072483070ee86
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:17
# 768f666eb3d349069019d90428acb6bb
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:19
# 3280d1ba6e794a0482338c487c959d52
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:23
# 6988100eca3c43ecb45eba47ae8e74a6
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:25
# bb266d975d1045fa88c7eeacfe1f8962
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:29
# 49ffc234aa924305be93b14fca5361ed
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:33
# 8af8be51dd2f44eeaeb30867d580f6e1
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:35
# 176868c525de4da7a60e057f8b810fc1
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:40
# 2c8bca5f30144dbba1624eb90de83531
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:44
# 8ce2b62917b84cdbbe70db9eeb5b6fc3
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:46
# f2410fe3425a4cf69f38f1481c40f99f
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:47
# b393759e674b47caa2bd656dc05cfe36
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:48
# f62266d7a9704e1f96ad0fb6de2cd972
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:49
# 03f576e35c4a4b7c800791cfc1d2dc17
msgid "custom start.pyx to launch kivy application"
msgstr ""

#: ../../sources/guide/android.rst:50
# 845543c00cdc40b298562dfc923d6ee3
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:52
# 43c9dd5d447f440dbb0ed2fdc3cfed0f
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:54
# 865646858af949ecb568e5797957c82c
msgid "*Video providers* (done in 1.0.8 version)"
msgstr ""

#: ../../sources/guide/android.rst:55
# 5b32446c8e4b49e7a8d2e6001e02f12e
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:56
# b980e712fb0e4c23babfdf5abd6fea3e
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:57
# 62c6a7248f88489998a549df590d1f58
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:58
# 920897c5dc89422687f5d652c11540f4
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:61
# 3e277145dd7c445cac66194b008356ed
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:63
# 63ed75e685a94f469a1dac1ab9d8e82b
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:70
# ca2710cac314490c9bdc53d231a0f875
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:72
# a7eb9333c66d44aca6247ad6f32dfb0e
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:73
# 82f28f5a3f584677bd3f496aaa02ec0f
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:74
# 87377a8873b549dc904e77b1306ffd25
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:75
# 6b884921f6ab43808544af520810f489
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:76
# bbbc445b610d43d883f249a1ac252f88
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:79
# 2c65ce76f0864d738acffdd97176d372
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:81
# 49c94276e5c84bfda70e210092404846
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:82
# 3a8ddc4e487b43e4bdd3476248838812
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:83
# 437e0437834a4f54aa19a341bd24ba4f
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# f9d28ffb0b5442ee8f405d6cd5a2fb57
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 9b215b00a84b4c8faa426e7a4233f724
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# cbf87f430cde405b904efabfb2bdea17
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# e3022eba510e4529849bf993b08c54bf
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# ee2fd7dcfeb649ecb4e9aeaf1bf26e15
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 743addeeea7f4e3c841e6503310173c9
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 65d898c36b854de185cde995a6577f6a
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# c84bed4da3724e398bd85b7f8cff8091
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 4dd6427a23ee4446ae847a08a7026f03
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 0ee41e7ad3a443fa99ddd3ca72744da8
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 102fdc192dd943e19cff4acc7abb7f8d
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# e223066dd89842afb7177200d4c622cd
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 2a4d7fdf4eae4982923ef75d30919715
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# a37e990e432948c3abdde8902b98e2bb
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 8dd6af3e7e4843c2828530e98954aee3
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 6038584032c141789d935a90cd6da785
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# d8f967ede4744c2ab357e0ac9507e47a
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# a3132268d2df44a68eeb80e134fbc81d
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 923336aceab04a9da5b04ed6da599b91
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 714081e473ef4451a3e0387495340854
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# f56c5a81b96a4811a6e96b6f2e7d70ec
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# ff3e052e21ce4c508109ffbf0f1789b3
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 3002c3ba160b43ccbb23784ffc9d1af1
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 2f29796d4186406a9cb6624b0af9965c
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# ce099999c9d244b184dae7bdd356e458
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 020c49f6f62642ed950d6905b1f48e5c
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 1a165d0bb4dc4274afaae4210277c85b
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 7afaafe7221643309b3670523a5e3803
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 0e853fb57d594be1be2e4743c2c9d594
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# d8570a2c8d164190a01077c5a047036d
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# e6471aacafe9441bb9e5249f9a8135a1
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 8157059835d248f58ea719f68bf64d74
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 583818ff3eb54149bf861e3e8bdf777e
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# e3ca8cc4820940c38094e906df1fe8b3
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# c8297f788bd14830862fb1845842cead
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 4c0a3357873c448bb24bace08488c93c
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 37b443b7f58d48c1be90fa8b2a27a6b2
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# dfa3b357aced4b29822c6661bccabfc8
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 2570eb9beb5d4800b6f60b2e44af2508
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 19323b991c874f1cbca8a73e0d079fa6
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 741204d05ea8484598b1431778b04950
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 634239a4884647a5a6643c810a96b063
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 7e735108c7eb429aaaa00537f471795b
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 6d786a4b052540b6ae29eb924cb02f6a
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 499704e54f8e4d03a339cd0ce6bee8c3
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 2cffb9d9907a4ec895362bcc68d7fc39
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 9277e4f7db5d44fe90747ac39afa6721
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# de00c57ce6a34a8889ff246a73b32d95
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 8439e16932d7496abeb05627e6a2a763
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 01a7de573aea4685923965e77d05192f
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# d30be8e8f7944ef998fd64781f0a9247
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 979d62c0d6b84254943cf3b20414cbc7
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# a5f65a3109c04b2b833e264fe984cfc6
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 2a028dadfa2649099472fa5d2d66c80e
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 12f780aaa698495faffd4d492599417e
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 27ab89f8065448229d7fb3727490aeba
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 7b1b49bc5cc24591bfe91989c9c9a751
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 59c52fa296024c318acea49914d9d41a
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 560cbde9f23f4bc3b001f2baa6f06270
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 44bd1e11876c401396b22512207824fb
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# fa31eb6cec1141de955046ca2335ab40
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# ee66006b418140dab154eba9afb07934
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 7e2b7e7cb0a5450384e74569da726a3b
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# c024933df59d4dd7a281c4d14d97db10
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 0443989c1c6443d4bbcf109b8d05e40f
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# e56ec87158f24806b04627933e6517ac
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 1a2dc284a39248ca855a45256f3601c7
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# a4ce909c9f5348a9a75cd508146603a9
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 0ec6b081d74e4d3c9f51e47159a4c5f6
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 8ba604f00dea4fcea90ab740b910ee1d
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 9200914039374c9ea8a31ba3686a95e0
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 43b1c684e18448fdba40f17ee38847b7
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 41476f1e47bd4a7fa2914eef0739fac5
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 69964432f96448daa3dd814bcf6afa97
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 197daacd357640de9e69b2c91c34585c
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 21cda7acb8e94eafbc5a1b39b4f48a6c
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# ab45bb04d1004e92b4d8907078e62d5a
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 7434f18d09484123b99098e7267e43f4
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# afce834b39c64d1da435022e2553ed8b
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 15e2c0bd37e343bb998714b589205f30
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# c6c49ccf7acb4727a2e83587deb6d220
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# 9387ad8605414ba692107e8c9c31f2c1
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# b0fa68307678405caeec005ac2cc1e24
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 25d413e66aa8437196f55524804fea21
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 75352a0a630448698fffd2a1dce72f8a
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 2c01155742f4439f86fcb9e2a219558c
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 89f49eda4dfe4940985a97aa873c574c
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 2d2dcbddf6874d9ea19cb93ffa618c81
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# fbbdd338f8d1478ea57452306fdf38e2
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 82789a53c2a846dcaa34d4fb3342e9b0
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 33625183d81a4e5f9571b3e9cc999090
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 0144005d1f354edf9bbf1d5fc45355e3
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# 713fb9ea085d4e3f967d44ca40418ff1
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 0028f0f5cb204ef4ab6073e7b67722d0
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# e8e1f9922cdf4525908a980f4c0d5b0c
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 679272d0af8941c69939369e413223c9
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 914294b66edf41acb1f5e3b9ec79271a
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 020618c4307c467fb104c13c35cbbac1
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# b3e7aac84fa24879b7d7f773bb87298a
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 9678542eaa184e5886496ea1b467b115
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 1bb3e22d27d445d88b30700980a324d1
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 155610990f544e8d9e8d78138233554a
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# f2c10085dc834fa3bb9f46e140f89b5c
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 2a6f9679e08445d4be64f152b03c1a55
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# b1f51f09e1784897b4f982e88257fe8b
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# ce8b4abed5244253aacb723098e35fc6
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 4b0ca006885c4b65a67ac2b1bb98c6d0
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 9657fe5746004e1fa7b582e67fb7406c
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# a17769133c274f18addd5b437a37852c
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 0b6e86e4bfe24bb29536887e5a19f11b
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 3260f7680f2049d8a11305f2e6ba1d19
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 6b1ab00304b64618851dc514fb0ba210
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 7182403ac4f94168af6dccd30061de39
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# f267bfb6f6e741da90d9c7df766deae8
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# c9bd293692b745de84daab30bdf1253e
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# cc4d484199b145569750184217161040
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# b17860bebd2d407cad3397f0ab97acb6
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 5d03d7b9f7ba41e0bee9936058fe40d0
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# dc6c8a81b19348ec8887ce49269f6132
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 664d25789a3b4c80b5f7ae228b58fd6d
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 0e23b1bdb1a148e4b77c0b49d278a963
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# d756aac7273247158e0b3b15358aeb8e
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# b556cc02d2914cbca44e0956e3f5f1be
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 997389ebda514bbb825c732a7fcc888f
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# badb64531ff64b2cbaba96674147c2aa
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# e4b3f8c4891c435492e7594e7e26aa99
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 1ca7f5592d1c4332a60e2466e817b581
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 96ea384b52ec4cefb63fb2a4b91fe950
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# a2089337104c410ab981659bb1739f26
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# d02564f82c194916a44a2d3aa21a3e89
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# d955460d315b4d10b059313cf70ece22
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 9e97273c75374cb7838ac405364eed83
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 1560a1b4370849d3a6e66fd769f9b559
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 61e42dcc21444bf9b0ad1c653c2f194a
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 46162efef0ec4738856a14685cec8660
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 8cf94d62a5214da8bb3bbc8bd0f6dd49
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# f87a529ab56146818ede9efbaf77cc8b
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# ad5c66ea25f44bdbbe9fd2f92b857d37
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# c984f877e25e42cc97325b2301fd2e20
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 6d411b5861f14486bdeded7ee54fe224
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# cc0dcff7d72f4ef7b0e021b50e023309
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# cc8b476cdc514217ae5b06c2251e8238
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 33ffbc6694c747a09435b9ac8b8070d3
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 1122303891ab446b86e8e9d779d2b8b5
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# b4aa26fd7bb4411e95222f97562fa1b2
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 1fb0b306cfcb4d3db6c8da4ff59e15fb
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# abdd0441f78042f79bd132a3d0e68b6e
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# 036617eaebfe42c596ca2fdfef122be0
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 8bad27eb6d234c77b31fd155365e3dbe
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 7c2853cd10464f4a8f06ceea581afbe0
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 717fdba937fc4c5b965ced0c3de033a9
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 7c21d19465344383b37f4523b3183257
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 5af99d4d9df94f48be381a9a4100acef
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 1a8c1c91826a46458866e60421a95df7
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 96b3e40261364948b8375d06a7df03c0
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# b3889567dd0745c9a59e8c5350762645
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 4e054317ba864c0daad832582ed3f799
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# bea328dfa2f04df9a01c9aa0f8c6daa9
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# d96276ec1fb1405592364ac0673ae7f8
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# a0628c2fa34c499bb8a4f84cf3309b26
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 5b970261a27f4ed4a824a5982c1b28bf
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 11cc6a78356647f18ae23c212c36cc79
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# a114419b7120425393c82ca74a9d68be
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 410aa361adea4c46a4de5c0a089d3448
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 15bb7759f17d4ddcbd2ec7a0d5e085e8
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 236113fb22584242a42fa68a3f5e20b4
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 20bd89e9285347a3aa7c34b2e80d286d
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 0db31187b8a244cda9b7b43e3bf786df
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# c80572a7b82a4c42b8b5a306d9627f45
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# a3b345d296f94134ad98dface5a3eaa3
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 7d24e32ccb664ffd903074e234902c0c
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 1472a5cc47554da6987bc3d991f74ee1
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 0b48b0457ad740bcb47fb2c5b871ed37
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 8aa845fd6d6a442ba74de1886c9db50f
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# b257f13393b2412ba96a009ced9fd938
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# c02e30d7249044a1a72d51b6f7d7db13
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 5598ce383d4b45c0bd3381e62ecbb057
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# fe8d2a7302d9462fa04101b28de9138a
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 881fdd6b043a45ed8b6ef0bcabb0f4b3
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# f55ab5490014414fbbfbf81eb4906cf0
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 70715d102476424a8d9b4ce3856ea24e
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# cefbcf1125144654bd9b23be1dfabd87
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# 91d6b8be3f0f4c5da584ce67a91cf84e
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# f962c283e8ff4d339be80453e3c061a2
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# e4227bb5ccf94989b21acd35c1e5f8cc
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# ac6540f7cba1450b977dad5d7d70db47
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 61f475455a5e418686a414cc249587af
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 5a0c21ad5c6c4e1eba75fa207a2ea9ca
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# dac09ce7be9f495cbdd5678b7b107336
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 1f02b2416c804065b02d24e7570501db
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# e4867ea22d3546d3abbe0022764da041
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# fcdb33a4ca0245538185627ebed457af
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 3b48d845e09d4c13bb776bb830d6adbc
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# 698632009f7743808e8164d0ab2d1483
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# fde89f8d0e714b54966f2577ffe304f5
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 94de5954ad20432e9173b3c224413063
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 5714e00023c2476ca2575b3f3f6e5736
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 4e7003d51cb042fb9edca8ad16d4d878
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# 5f4947416b294981bab6e7680c6b58da
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 3b182983a3c940f485e1a6bd2644b85e
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 800eded4c4b44b609af01c074decf59a
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 8daf048ad0aa495b9081bf45343ce16c
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 16a03a9466b54a878b26b139dfea71bd
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# fa0254d337b443089d9f0f78aed80160
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 49f5ac8aa21445d58cd4356a6fe9a543
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 76cc8f8bdfc5482082cb8ecdd4dedda3
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 068c065ce5e646f498d3dc1c2feb91a5
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 457d326c1e1344089b20bbd32b9cef76
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 333005fd1b754841998831afa422ddd3
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 49b3b568f6124f72bb3028847e88bf5b
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 3bf20fe130da4107812818bd956cdbfc
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# f46142b97765431bb78e9a6abdceea05
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 5b194472ca3a48389ce610267a97ee79
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 7b092a9ba8c24fc4821b13399944c9be
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 5ac0b5ebc75b4800ad09c9e48bd55bac
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# e476d78bf8344509bbc4a930eb2dfbbc
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# adfafb1f1b544c15a98da516ee505745
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 6689403a19da4a0c8161be80a1480b33
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# ce021a328db54b3fa3f15b8ef90e82eb
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# f575c79bfb2b49408ae9b7539f0a6d40
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 310c7b84c950432a8d3630919a9c2f04
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 755371a1d89c41f0a87ea18d93149964
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# cb49d4dd80b743679bce80e59fb7140b
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 2f0ef7fa37044a26a4ddac86be542c1b
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# b005728e95bf4d1e81aaa4553832f9ef
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 261629c9fc124dfbb46a8e6d15005c51
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 641bbd06dbeb46ba89a27297f0519107
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 21efcaef2a1246b0b2afe1ace8435531
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 2ab9e7ee6e084143b67b6558ae357b01
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 088dec41ec8e42788d92ee96a0021ce1
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 717df63dfccf4597a1ef48c5678cc626
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# 85c8b0fdeac9484d9d81ba03b759c6a1
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 75eea06677024d2dadd0d6cc3fe3c2ea
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# 496af87a5b474172ba1590133d9e5e4c
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# ba830402736349dd8e71744312ad0719
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 1500da84792a4eae9ee6874dae6c9555
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 2aa5b25e97bc4f1db21b58986ce4ca85
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 8e56142b5cd647b4be436f544cb780dc
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 4679877f29ad4d7489213178d0045bf1
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# be54a8c59cb943e9a1e628ac7f9fd2d5
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 55f8a25b967b4657926d67e1f109faf3
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# 91c127b94f2e4dfcb799d42e9f698b0c
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# 003dc7f6b10344ceb30510c83f2d63fc
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# 317cca67f36a448f9f6963f894dbb1b9
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 13ac39ba433a40f9a45f4cfc84dcf1a4
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# b1acf49830a742df89fff095a84869c7
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 1a26cad8522c436293012a283257f717
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# b6d5d65cfbd54653bea722de48d628c9
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 065b60a1f256471ab22d024f4e624a7b
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 3125bd6ea2a049149b93cf82b427684a
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 68c17e63f0d4431b80eb140a96543a95
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# e24e7a21d031412db55e9bf5d8b6ac72
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# cee85b9eee2745bab2272791b9a24f1b
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 81715d6ae4134d0b8075c3e1fd69535e
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# b181cdf0da964571bfc2654f8557abe6
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 9fb86b8d0bab48adb3c1bfa344120b9b
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 481f3027b0624ad6b1930f6104acb449
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 5c6707ebfe64496ea463fd55e4f66e49
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 64cbe1ee7f614b119572e7e06fc43467
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 5bcce28d9a97495bbf304a65839d0bfb
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 0456ec2e4531489d84230e80b96e8b54
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 0d9c3f249bcd4b7ab430aa6e3c2409cd
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 76cdfce1d100459ab7052302e0f28c3e
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# e0232b2061424075b89586edb4db8ef2
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# cc1872bd52cf4f95942eb07d0b372c8c
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 61523369f02343939a95f8cc0b63ad61
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 23463fda9d524406a026406435fa73af
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 1eee59b53f644d50a0d53de97005aaab
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 3195da079e69456ea7e057d6f370cf1a
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 447b50a7b41b4806bad44ee3c1ba5610
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# ac6d317a5518448f8f3af8e88ba5a2c5
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 930807e69b4d403e864e534b38431048
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# a01c11de73ef4d0bbdd783da24ef86e4
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# eb9abf8e3fdc46609a37dd080893dfa3
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 5ab8c752ebfe41199486d8a8a34b292f
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# e69236daabde495881ab4cb897c9be8a
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 9252d872dd5b475c85639513faba7e9b
# ea408f958daf46c0bae075ca928dec9c
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 28bd2c3e3f684156821969b2babf3081
# 385fa65ad8d14edeaa5a31aab96ed63a
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 102bb5c5d10e48fe8d9f49a79fdfd2e1
# 3a191a0a5f524d0d8b667f5e6d3ad82e
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# a79c4e69237143e8b285d0546acaae69
# e2f5f928e5d74899b67714410d8f738d
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 7228f7c2d1954b7cb9b40b5b1f1ec940
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 273bc0fc973249f8947b3aecc52ddba1
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 87489d4116504a2eb749326b3e76ccce
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 3ce680dc802a4bb29184499fa279a0e4
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 493d7c49bd0d4bf58126bb148ba6b40c
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 06ede81315eb42eeb1ab28aeb50df34d
# 144a4e6b5f6843509fae806d94289d93
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# a172803b389248b4ad0dd3025b5d718c
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# b181e99b5afe4fa5b6325f911a772fb8
# 2cf216db897f49589f98758daa9ceec3
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 5ec599dd96a24ceb9bdd8c5e2d101e42
# cc59670d213445b09317d4f372f30db8
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# e9651a64a029443bb4e59e32d56ed109
# cfff5247576645e09e475b69b3ab009d
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 30cad9cd98e6409cb3ce8796557d038e
# e66bf54c023a448aa6e058a0eaf04290
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 601de709793c47eba2b5d20eb1a452c1
# 93aa47c968fa4d6ba962b12295a2bafd
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 368a94e4955b4a4d8144d72dfeaa79cc
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 1cbb57ed8b8d44feb5961e00d5b20e0d
# 9a1fb026a88b4133bee0f5d7e9d6f03b
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# ba0f4628d79f47139a8542d0cc807908
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 750c518d5af24db1afd0daa0d3c6c229
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# d5d639dfcf464ee2a9e006cc0d656ffa
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 7e3c74e01d9b4cd6814dd8ea335a0d73
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# b0a60b7d258c4674861ab66a6599aaf3
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 7af7c6c8869047d1a27d2f4d989be960
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# a3d974c7f2ef48f2a2e8921c8f4971a7
# 83c630821a174676b268e79c4dd1b3e0
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# f88392feb93d4847a0dea41266870e02
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 87f04e103df042e387cf9ce4f8976b28
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# 5359b78d241544b59f54f109b7326905
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# cb01c9f8c0a745078c5be6241a85d780
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 31f33b167733482883e26ab2c3575c12
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# d6b46121c27c49e4a0d97d1ebff3174b
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# e4b57320a6d441e48a14711ae47b5c9f
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 6c058a6176cc498fb592f94020b3ef51
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# 6abf22a94ca64feeac86c0c8a01b6faf
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 21ddc5a5b22a4856b47c71de85b0ef14
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 1e1bb31c006946fab7557db6d817a101
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# d307c80615b541bbb4817a6a000e2f52
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# d2fedb25ddba47b68c3355acdb491bb2
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 45133843778e466f998fc9c2771472c6
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# e79f1ae806274f83bf7584430b47118c
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# c0631df79a14466180e80c34dfe47885
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 8978a9837fc041b28f3dfc14a87356b4
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 674347b9b3824e37b17a6296d08522bd
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 9cdbd11776d5452f954e6ad1773ae3de
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 4a808943a35f4c92aa4f8d1f024c5eda
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 9f4a58ba6faa48e6b312fbc3553bb05b
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# dbf037774b404b0b8b3a0618c00c2c4d
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# 3dc8fde1c94a423d822e80171ea5a250
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 485c13874ff0482290143c5e45cadd9e
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 820b25a7cf71405c8f089ef6edbca8b7
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 65b10458e12f495fbfac3097d0b863e1
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 534f1c45ad4a4303bd07bd62e3aba587
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 2f371877a18b46389998d603ffc0c290
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 146dab868ab74f948f95fbe226ecd937
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 3c312c3ec04f4ed2adc9c4f6eea4b081
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# b22f3bfaa3214f1f9d4d9fcb0ecc7760
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 70843a347d234b6e9a781e7ae385ecbb
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# f1431979d7a749388326ef5a50a4b854
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 3b3e1f30f6ab4628b98b09a004924490
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 53a2e2813eb64d288f8a045de1b5b306
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# e5b647d143e04ee18c5cf0db500582c6
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# c0d41799f67844cba261adada91a9294
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# 98319cc015524f22be554cb86a67be46
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 481019f444e9438484c198f39e134a6f
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# f9e3fed8d38248ea93d8f71215173b38
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 3d9f1c90c5d24969ab350f2657f667e4
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# f7207aed86e14bb7aa66a0f559561824
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 0fc0948416234c14800b3603a635a023
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 915e73a2bca742eda3c36c20766ce9df
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 2eb11d4cc75d440788976513623e59b0
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 21ac36abe3c84e13839720ba9963becb
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# a5181d1022894d6e98bc6339ab8e149c
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

