# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-18 21:58\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# e0625208faf840e0aeb6cc0578c19b59
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# f099222682f5429d81753d82aa515550
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# ee05b94a459e4f73b6374d5814e9a15c
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# aa77be7da32b44c081511f0e89cfc124
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 0ce320bbc96f438585112203d5878bce
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# d50acaa3fa814ba88c95cb93fe73a03b
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# fe782c0df4a7441794299128341a9850
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# cfe2c12d788f4acd95f8674c2e2e62bc
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 6a63673f34da4e10944d98d5e0138d53
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 53f9f73ae4544561aea8078d272f3a4e
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 699b3d050b80468a8349d809e1cf4900
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# d1b07df3968f4af79944c58f3ed9ee70
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# 9272c926045d41f3be4f0279686cfa1d
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 4925f15ce5944cf7a43c8b937d853c86
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 682e23ef80294aba94ca6f319ece4137
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 4246f19e78e14d9da0b0219575ebdb10
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# 55fdb77b3b33446384825a3c6b12d5fb
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 336ea6a6e5714828a65104085dd30d08
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# fb3e903e6758406f8398daf8dbe9d789
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 95fadb8ff1164015a9f5cc5a155d47a9
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 8adb06097c854f9aa14c532c1a1f8a69
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 828b0a943dae44eeb780b18b1fdb5b05
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# 187c0e88be7d48d0ae13f91eb1345452
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# 7cd547ffb19145dcb845230d413acf71
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# cbb9f9699bfd40428a2f61f730f0c98b
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# 41071db713024a3581da69c2940f862d
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# b1be3bb53d7847bb9ce48ef633fca47b
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# 5ff112b0d81c4a24a8b16bbd0d96b4aa
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# 663e264ab4a74d6c8559497da8936b71
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 53389c9b57ca4b2282e52d38f5073997
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 007c47f00ce748359f57687496b25ffa
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 36f01e6785c64daebaf0d6c132117a90
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# d75a1f3b074d46a9979bffa5bcd74c85
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# 2c8b24b824314239b35d5833f91e56a0
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 052d8e8c33c945f78e98cd5241ae27ca
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# a93dbf8ea3e44644b447294201551fc5
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# 15a8d53b87d64097a00c42b79c138a57
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# 3cccc7f325bb424587abafc4ee703084
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 12c4711da7f642e3a028f236ee45cbcf
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 03fde5f16814466e90fbe01a6fb5aa05
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 9aa42784581347c8afe781bd17b5d695
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 049fea0b6a334cf8b8882736f18356d7
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# 4341f9a5809a41ae91eaf615343354ee
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 6a7d8d886bbb4d4fab9845bfc892acb2
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 93cbe1a895ca427fa205f9c0b87f0db7
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# 8ebdec0a3c0e43cca58f606397867e4d
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# dbd6ef6ba5bd488f8064f80a8fe52d9a
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# b5ea5d86435440248113f1956bb4214a
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# b93d4e12d0194ed5bfcd0aae018c2d2e
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# f3de5999c898481788f68b08f9f9e494
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 55b7cb4701ae4e37b7734479644cffba
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 4570f9ba1bd343a885ba8cf7c892326c
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# eade25545540429c90de8d6780f16b59
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 163b1867d5344509a2b568bb6b171bad
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# c0ed7a821a70420f83c3043a61c7ebab
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 43aa4951f5e64a188aac6b8cf2406120
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 3c3e80d7f4174767a49d88a7857b9e8d
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# df773aa47964434db9f07123bef034c6
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 44a125711fb6406fb293c91c3bd0841c
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 060b0fe53b654100a320b29c08aa036a
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 0be45f64a61c4afab7043e5955735e9b
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# f9fde8b998bd450f9095a683a2b14765
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# e1390dde026d4f669b8d2576e13f4a89
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# a6fed3447d4b4d2488236d568be1ee44
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 8e1ba92807104f13a161e3bde86fd596
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 4f0dd9267fd5475fb5779f7182652c47
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 60b6c923cd5d48288ec69876934b9f69
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 5de9e76bac8a4c628d2d580c6a9c4e4f
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 8f6252ea22d54ffabf79828975388448
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 5c96bfda70954fd3a942ca9170a5aacc
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 033df914c698438a9a830222e0dde0b8
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 5d76896c08784157bae75b28fc6d26df
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 9de490e957c24166a417e2764d09a8e4
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# c90cbcbc5e054c02a2e7c9b134d03497
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 0a2d26ce38cb4ed99088514ae2b8653c
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# f74ad75baed9456fbae619680bc3c3a0
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# bc1dd2f95a96476d9227b8c8ff709136
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 2afaa3fcbe0b4da69bcf93b02c8a42df
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# a91d98af93514b9894fcec1260e1dddf
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# f22b28e181d445d7bd78effef9b5183b
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 9002178533cd481c99922f3bd6c11b21
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 8661173b90054d44a73859f4ca4e71e6
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# b9cdce140176458ca72cb8e27e569460
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# c26453c9904147f19a884421800bd49e
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 2e0e6b47574a43c982dcc7fc3ebc2f8a
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 947880ccf2344a5c9d3fb9362eef662c
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 2ad7a930c50b48159f506884b3194f6d
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# ae12280333744dd7bcb053668536a2cf
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# ea3c2ae1d9ec4f599bc0d5fcda969543
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# a66dfe7224fe456cac73592fbb45fb9d
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# bea61b70c88e46699c22263bf5e88a9b
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 053229da025446b1ab53ebee42cdc4b5
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# a6660be8fbb44ece9baa239a8becedcc
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 8cf41acd25544f73a22ef8665def861e
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 84f61ca5226e4e8ea2cf73e4289ae096
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 455c1d90c45b4ca2a453826aa9353e02
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 1cc03f4267434e86a800428c4abb0147
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 0e5811ac16c74b129f6088996dbb0487
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 1f7d6cb7df6d4f4c8c7764fb7ea78e29
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 96aa4483d3a44f92bead1e7df3283337
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 436a6f6f89074032bbbe6f5196666c63
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 22c643d5e235425fb91460dbc68a49c2
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 19e66299a6794c97befec57a360c946d
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# 29bda787dd9a470f9deccfb0a9a83510
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# a872e2f5fb5d463c944a839ed4ab6b05
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 94855437337d4c7589ec0d5a08d74e3d
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 8fbbe3e7fa8d4f1087b4635c1b4ea348
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 30938297aa0e4b89811ed59f72584a33
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# c425c944c21947bdb37852ba3e4a2a28
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 077c74e3f67847b0a72c6da00425b68f
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 62dd6e2cc4994b7496b032b091fe8150
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 6991005aea774be8a96ac6fcee4deca4
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 8a7ad276fc11450a97d644c4f7f05e2c
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 367cb1f0fd3a497ab2a15468d467bed2
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# 0ae13e104991415b984375e6a32d508a
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 2f7f05005f524ef99b24229a737cd946
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# a00fe354850f4301bf1e4f3c6ee5ede9
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# d541e53e1e4548fa8d21af4e5c319cc8
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# 09c52bd190114930a33bf97028ef25e6
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# ab9d2326ae3d4d1eb390a410af0b9585
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 1f5276dd5e454db081c5a45b35089a55
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 0ebc2d9d926047d18278bdbfefe189d4
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 31a119d8ab6a44e5afcefd4e3ff0b29d
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 9e52bf0a0fea4c49837a556f333298e1
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# d831da4a821e4cd28c9cabb524bb5c61
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 3ab44e9676a24e36b6b7ba2fe57c8481
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# 63db8e4aadde4b5d907698151a997728
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 4c6c7d04fdf24f40a465192503212de5
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 9f67dd9c4e774345a0914b4e9222ebe3
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 4ef450c7d3204b19a438cf47d2d9bc85
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# 070f8ab89bf24747bcd6eee4341241b5
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# c9ad71efcf0346578ae70d6c4739e916
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# c5d5f5ef1ab340eca1ddfb038a8e7a8e
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 3e9d47130ac54a51bc3d63da041b7de8
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 4e5211dd70db406992d0cd5528afe62d
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 0e50e5bc5d734849a59307eefed11ee4
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# fbdb44f52023476b87db66d376aa729d
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 130cbfbfee1e4cbe972394687759343b
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 8b0a8c0ca1644f10990a9440529fd1fd
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 7c3643765aa546f296b5f25501125c51
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# f4d53de11dca4879b7be8f4d42c4a648
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 5079ad99270d43c88a119fdfb32206e3
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 029de8f5416542eaa8a73b773d523ef3
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 3548f703d0f9413aa01174e12c71c71b
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 77c9b873328642b1a9d5a864578e0f56
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 280aa453ebb34a718387f3d0c341675b
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 48804bb2adda4491b3c87733772fd19a
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# c5e774d458e9460cbf71a75fd4cf8fd0
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 62bc54bba7c348f4b141e9b4a3663dc6
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 2fc353b742d744929ead5c2506cd0c37
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 02a861e59a71436db9182f76b30202ac
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# c27de232bc9e478aa170d115d733acec
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 2c536b461adb46a3913550fa956c7ca3
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 9fc43a82e950405ab657c81568bd84d6
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 5b3fb47fed5149d4ab97dda869037d13
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# b835d9edc7b1402e9c5aef8d272b0e77
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# ea0cce031444481d83f3e1e2c58346d6
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 6df197de5d6e47b782938f88772a9cdc
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 95811107af00452f9b9780b164a1f29d
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# e84ce1c5e86b494b84981016b98342ec
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# e1bea1ea92734d9496754ecbca6ee62d
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 29bd177e0e1f40b2b6129f6c31c72630
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 020d4a6c26574795b1c038a30534e90a
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 28833952ef174d7ab3632898a9ed180e
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 4352cc3ba2874c4c93223d4cffa54f21
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 2f65dc1e6cad4be5b90d8691741e556d
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 0f6b022baf3144878f16010f0dfd7bfb
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 3191b2a529e4427ba6b0e5c62284eed8
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 647d36fb5e684a1f95c80d9c0c9ea78c
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 8ded63d1de154618823a7e2bac2b265c
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 8d3c07a5f2f0437b834f376f224c5197
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 6722d762b02c4cf48a5788b1896aebbb
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 503365ec7e0d46a08c53c0d5bab3d0ae
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 93b956e476234e29a9911f9cf36a697d
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 6e57788aa338468b9b7ce03224599d5b
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# e160e4f82a4846fbbf5f9c3df5c35822
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 184aac771d1645a6b6cd7ca91be9b283
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# fbcd11fa1c0044c9b547c82668656b10
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 5912c4be6f9049cb86db4cb956b81ab7
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 9a55e00462ea4294993d0fed8b214959
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 077b88e078e94b4c86ad08898f1fc53a
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 65107bdcd5224351a464f1cc7a690522
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# e9a58b50e26446b8a8505fe4d6dd1f27
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# b20a7bffb00f47a5ae807fcd64672d8b
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 121a3b6ea8c643e891934cf1e1d0e7b2
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# b1e5a9fd04e741e49c6811e0908f0a8e
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# e78c8b020fa449aabf2cb8edc8e55b92
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 3407765aea1643ce94c34191176f557b
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 6b6839b8859c4b70a98fef69ab19cd24
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 6ba895ea9dc048bf98c2712107de6c42
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 38dc9f0d77b0487d9d5073427b742efa
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 21d364b4d5d442d9a1322ccadcbafcca
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# d90268c6c5254cb0ad0b99de3ed828d0
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# dd2efb63060141d7a82e1931f2473f0e
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 9ef541274b6e43d6aedad466bc8adf95
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 41c79aae2d1e442e8160888c679e79b1
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# ce39554930854312917ef3e9dd6da4de
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 2d5e3ed4827b4a4aa43266e0f1dab132
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 59886e4f6d9e4c36b43815375a86914f
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# d9caabe26b25431abf31be0f81f228d1
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# fad1cf8e55a14a4f9049d9902e141d11
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# e2d467ac6bde4ec8a3e2469ef8885a29
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 671c74087a224d01a70af1c8dc1d5301
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# f60796cec806480789bcf9d2de615faa
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 47eac6cb7619439e81c8022da2f7593c
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# e196f0eac00446dca687f696e7eadec2
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 429c3a02ed144f5a915048bb97a7d083
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# fa8e0dcff9464588a9a5a9fc632f7a85
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# e0f6ea051fe74384b2c5ed80569e6abc
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 94f3cb0fca2c4fa8a3311cc1ed76cbf8
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 8e7934a658e84ec2a5baab11fc44c4eb
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# a31bbd00cc33439f91a6e99959a6ea09
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# a978facae78a40f1bae8f9bc8644a2ab
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# a1d4951d33ac4610ae344fc5b54c6036
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 73a2d5f9b750489a8c9e5db55b7fec5b
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# ffd75312eff749e3881476a0fa65d246
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 883bc91c681e4ce1add020d4adc20a15
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 354d2a5f0309488898d97c08a3af2820
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 24a9ceb387d3495c90a1082ca5c94e55
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# e36dc90cd2a84d0ea18ce055a5f0b7a1
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# a4f8af4a729b4167a3efed36145d16f7
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# c8034ec7e75c4257bf1e0a3f035cdb14
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 34bd2c94ca7b45329cdc1a9cb4415596
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 79e0208aa2b84cf9971e10e7ef37ab83
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 0fcdd6b6e4964fdeb69dc799a23e0bdf
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# cb33b30003be403480b3500516978360
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# ec8f1fced8a54de1bed51c9de504db3a
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 7db029a691f646fba5d41f84b2956d23
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# 3518a7fc9e8048a6bc0264723445f7af
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# 52b188ca23de43448e16d83c710a5dbb
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# e3c57450825147eba7ee0895c75d8d13
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# df85978416294187b605243878af2bc5
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 0fbaeddcdab94c65aba38fe7325f72fc
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# cdfd86ca75504b5eb120640f07f18f50
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 19c21f165ceb42868bdffa730aa61cfc
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# dd232d338f334824a66fa991d854113c
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# 2c480540006f4ce3b8f31d1e0b0ea7de
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# a28009e200194531b3b3540291cc029a
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 3eb938f6a64d4876be46296baf840641
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 1a343963ef38449a9e98bc36558bbb65
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 12115ba7cdc2498a804a7e4619621e70
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# ccab1af4d78d48b9a21b914cb524cf3b
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# caae9e79509e4e77a49f2571cd90a1fe
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 44a777702da4455ca34a0d0489e929fc
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# c0fc56260a014f169e49f4d6ff1a42ee
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 8515a231e3fe4bcebb8fcccea3692692
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# eb79f9f5679b468c89c262326d093c8e
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# c7500894d7ca4b768e64a83efbe28773
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 134e069594924bc4a132f82918aeb6e3
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# b06d407dae56441f9f3c6e48b56ce174
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# bc0310eee6e24bc2b60a91cbb8f53f65
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 2c4b21dc92ec42f6a18d0de8db5b0a14
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# b89b97efb3cb453ba8c5b276930c6f8f
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 16af331572f24ebaa6566c42cb2a9e03
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 853ab93d7b27479eb7ac047a769d978d
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 794fb7f49454459b8f346a40ccfc1e88
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 41c4a27b3c804f359ecd5787d685dd64
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# fa10072771ec4ac9b53359daa72c0bee
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 891ad9d4472f4c14b66219376a70247e
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 8e58995877b64ecd9496964b57fa5978
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# e9c0c5f2bd7f496eb3b9db4e7640d02b
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 5c1bec99d7844b1cae83dddd34130519
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 9b2e4a61d03c407ba81f266c4da72b97
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# f2e16e34dc6b401dbe62c49cc79c215b
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 7ef72e5eeb684bd187a6f3aa15565d63
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# aba662a6a6604b4eb543b324e94c4351
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 74c2e38a9a6345d0827e96ae8723b0c0
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# e5eb80bc96014baba47249433e72f690
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# d1182d1f2b0b42bba1fe0cb20a8ade06
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# c34ff5374c6a45939dfd9a332b4118dd
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 9497d6591c504b49960ab793e9a94537
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# edc853b11b4b47a3aff6c254d81498c6
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# e3d7c4a4475749d99d80e0c9695178fa
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 722afe95374e4bc6b17da8e71f26189d
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# a8bfe8a641414f1cb3ece316cb17abb2
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 523ba681ae76430781c9d0a9aa1e73f1
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 63238c05616e45b7988461d51d5329af
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# ee51fd2095ab44f1a600aee38ab7379d
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 6f787277141c432a8fd6bddea90ca4b6
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# e1d524b267fa4a329e9dbeb6b9d38795
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# d6a20fe9d00c431d82ceea420620e1c7
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# a754a4eaa9c842c6b2aa550e5b066bd5
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 5c7915dc567b4995b996e4d0087ec3da
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# f32abee9073342c3996545e4f3d79081
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 7f258f41b7f94b9d86528455eb283093
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 00083896fc074bdca7bda2893c0484a4
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 2e86ef87497e4219bb324206f8b8277e
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 9cc8530f1966485f89a9aa50505a257e
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 36071cc63df644009f204c3ba20a782a
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# e31d53e6a94541dba3e3b09fd5ec04f3
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 12c6e64aac5c4a559aeafc14ae8e7b9c
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# dd261c5ae4db4126a1459b2d1d85c912
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 3a9381214b4043fd9445796348bfbfd6
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# fafd6d5061944d72b2ea624664801e11
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 70a8537d5ebe4e4382442ceabe974099
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# a6e1493a7736440f9a730e26a7fb3b31
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# a78dc449ada34f718fe1ac59cf4b9345
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# a2256ef718454e51a8b321d9cb6869ce
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# f1925d83c2c7458abca1930b18f7d748
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# ddcae95c2b554f5eab663635c38f21ac
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 8c356c451ada48219077ba2aa466e400
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 11f1d0d2e2da4dd9a30f2e9add3fd0be
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# ac4ab2bff8bb47bb9ecdc4ecad9470c5
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 13269bbb4850463592d3d3d6b939e33d
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# d3c0d2582f5a4666a1b446120cdec891
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# d71178828ec741f181ab080e207cea54
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 02765b6b43b148a28f0f2b5b353f0993
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 3042b569c27a4438a1f4edbe3fd4457c
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 9d22ac44a68e484180288cd72d3b2b4b
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 4a5c35ff0bfe4f08b25cdb1f2153ef62
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 40d76e8b0e2641098849b0eb78822fe1
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 57f73b47e6e840a4a698c5fb1df6218a
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 845676d1f2fa434a8509ce095ac2fe99
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# e18663a3b7bb445abffc0fcf8803fd6e
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 450148ac38c347cf8c0c4683af3e79cf
# 928c27d145064e0a82508a60a6ca2f3d
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 519edb20d56f45b99f3487d521e06fd6
# a9c7fd1b737c4094ab51642f1bb440bd
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 1bea9fa9141446f28bfa41205246da96
# 75820b82e51244e080bca9866de6c79d
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# f6e6c2513dc34bc0a83724189af4ba24
# 003aa14e4c4348008558d43498221576
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# a9fdac706be94106b61ddae527eb784a
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# effaf179ada9446080440bb46e480c1c
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 91fb2067c71a4c0ba3d24db622fed5c9
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 4e6a2191789c4e24bd29968c1571a21a
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 2b606161fb334cd18830bbdef4bc9d8c
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 3397b3bae6ba45a6a9e71064ac8adc90
# 743d80e5239a4a6cb7ff75c5f2d82b03
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# f93be522d1804715a2ff52a7f864c922
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 06f5e0c5fc704e28848338a52c03c2bb
# 1a0f12133c13424192baeb08b6f5d89e
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 97b1e389e9ad49dc9854b9a1fb4ad082
# 27362644d57e4e3faab4c32c4f81a697
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# ada298803804441195a087d96dbda861
# dd5898eaaedd4756bc580be5e3085d12
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 6b1105acb5ac4bb5aa8114f1e9b95dce
# 43dc841bdccc4775ae391c3e6650f9a4
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 9b9800d9373f402baff0006b18f86c6a
# 0f98d7629658451a9e19b6dda70c8df4
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 0dd1cba66b8246cf9e942221f70dfefc
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# f54ac428e8164dd6911fa2c21bac39ad
# 1fc7eb4ee9a64006bc3012470d1923aa
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 74a9d77419804124ae95b72da1e7ea45
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 539b6eac41ff455d80005719af4cf4da
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# c8aa6129ca0742bcac97256075382ecc
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# a4cf944a65c34cb5a614eeb0e96186b6
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# b2c9adc7318d4affb4911a52fe466062
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 4da5066e268f457480d4419445a2348f
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 87adf43c141a4bd2b73d6b90dfd86f75
# 366e9bd22fed4ab1b533554ad8094e8f
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 28f61a06c5b74ce69620c79fecf8b782
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# ae2bdabbe5f64047bc0e4d0de1dc5eb6
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# 26a9e787c1104dd1b18c808fcd9672cb
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# a916db31c986437695de96aa9b9ab2c2
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 1c29349734ed400ca017b41634e350ab
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 58dfa6fd47164d17a5c965255f68b84a
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 32b73efce7cc4f64bd4ab29bdeee85fd
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# bdfce19908594a6c940ab736fb84ae26
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# f5c48d2dae6145b7a4c58ae3ffc8429b
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 2c54c7a2767e4c12befec70e1543c902
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 990b64dca45e4549bfad118362a644ed
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 44da78253ff44a9fbd4d176ed544da9d
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# bbd2e96c2b0b4402bcac5c937490eddc
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# b78e0de0c9b0490a9af9f264569a21d1
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 54c918153df54e3688ce520f5d434b53
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 06dc36c48b30424aa1a3f5c4e5c762ea
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 77103a82907645cca7bba4b13ce2f0bb
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# b0b5f60fb0e44cd3b670691623f6b5f9
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 845fc2581a1047ce977f5fce71d301cb
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 2973b5c1d83246689ae0dcc8930a284e
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 7f2a4fa469614e8ab17ae5a3406de0cc
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 49b3a1619c1641f5958fcec6157ebb9d
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# 4fdfdad9eb864288888f62401c609e35
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 278793a188c340859d487ab28be0d6af
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 3933298caab547e4b2b718f54c172890
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# c530d26ee4cc477ab31b2009884ca95a
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 53d445ca8b5f45d984edb18c164bffc6
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 91666f47247447edb5181e327e3dbf08
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 365a5ae2dacb4d0ea8fc070abd21d7a5
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# d7945df6cbb543fcad95304c854667f4
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 2fb05640abc64b5a82ed48c5738c722e
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 91a56347d6c8465f86f2f53a9b4dbee6
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# a1802a8816804e1da51a650a8f3ab1a3
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 2144c55a5e2d431d85363824798af108
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# f030a6dffa6848db98853b7f6db06558
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 46b9dd58c3144df7b2748680b04b7197
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# b8b672e31cc34cc78e9bd7498f489847
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# c815fc29078f42c1b6cb218d59119320
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# ce73e9ef3c414922b98d2da7a3dab298
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 87b995214d3748b5a90ea101eb99df67
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 6211b32a726848549ee7912393faeeb9
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# e36504db93e24d5f98b73e82780524ad
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# eaaca44727684a5b95f66d0620136cad
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 96780b09de3b4e51bce5c0e2fc8b6525
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 44fc9d3a6f28442387825a853d8108e4
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 7e8ef2e7310741578dddb257cf99cb19
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# a25fa04167cf4108853f9e2181f94967
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

