# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-24 09:59\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# e8d566b48ef144a094903ad4de77531a
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# f8e7a4ca93914be38dae2a16fa97aae5
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# 359e79b1770e406cbf18ee728eaeb33a
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 434c95ae70d24d1688683a1085859800
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 962c8ed72bfd441d8c204ae281631818
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# f28687935a584f63a88faf085d26a019
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# af8786462ea342df9e038f535d9296af
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 37a0ae2b0a9f4b3eab440628a46aff03
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 8285b24ccc0548fb8266803505090be3
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 6132a3609553483ea56a950329c08bd6
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# d80a20ec5a894783b484996814ad7376
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# bbd6b2c2d223403bb96205728da57c08
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# 1c06fbca141b4738b400333516057273
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# a1cbc38566844a46b64fc25ff3334a69
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 19b5291a11e34da3a233b299f2a45859
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 4c7ba3b32945449db3f6e0f18bfc5011
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# 8fd99dd17fe745a2b9616be831096b17
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 75b055773a7a4e19915248ffbb7b324d
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# 2aa267422e994bc6b9750a26437d57c3
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 85459d7ac0ee487aaa220f7a8b784743
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# ac2af0c9641a4e37a9719dafeb986b3a
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 0a8bb3048ded46f3ade8f46e7758598e
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# 9d04659dda2f492ba4e776e211bb3d52
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# bbccd9bdfb224e6292be32e70afda57c
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 99babd9d34164075bd5a69c21cf87c25
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# a569bbc5ed1f4a5ebb6ed45ca80073fc
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# e9d109e38ed6478b94a6c24b835917b7
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# f0064e76e04d481587b0902074005bf6
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# fc076301cd2643e49876ffd510d7adf9
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 0e500f0c6a01449db5b77b3060a45cbe
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 917f81e40cc64386bdcc9437a9576aef
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 2b8a560eee1047eaa88bb1c474c12be3
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# 9d67df0623de4760a7356db112dd587b
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# 90ac0ab6e4b846f58671f4b2475e59b5
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 19373e88eceb4c7db3d8cd9df5eced9d
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 0846243c4b3e498b9984350c236ef39a
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# 4a95e6d3902642d9880b71e6e3393416
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# fb2e596482bd4d7b9361efbee15acc9d
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 4d62786f7e3a470aab323c2a8b363e0c
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 9625468736d9426491784a1834489506
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 4d0d738448b3472da2ab7a091301baee
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 3b3ee9f2e9a5431cb36985cbffbf768f
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# d2a083510a1340129819ab2fc26b08e8
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 9452abfbb314478693955babd5630e25
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# b2f868bb139946f197c5002ac4aedd68
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# fbac08955ede483fb4f6b68779ad145a
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# b313026132d940bca2e57d0a099f19c2
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 0ee35a0cf7fc432eaf9d5771ed076fb2
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 15d6b92adc3c41cea0e510f7ae5ce904
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 1f86447638fa4861b62a73cfd3b73a48
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 6ead2bb0510f461baae8ae0c6c60e49a
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 0a6e63b911e045188024b0d4b291d3d9
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 9626306c48bf4513a4d1b27ca0f5b311
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 62fd91d805bc421d8a15797fbfe2c41d
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# 94ac6cd594b54213b9160d535efc3529
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 280c3bd61ba94681b8d1adc8c2a1da21
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# ec4e2a1741cd47dba47e2da50c3b61ae
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# e6ffe0a733d54cad83ff05689a6e0b4d
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# f1e24f9f109f40a19c5f55ff17c5bdbf
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# fb3ce02c09374823bc4cbfa1facd6b03
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 9daeb848841f4f5e9cf64d28739c77eb
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 5a5ddd1f3bb94c9fbb89472fb5fb46d6
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# f7375df6eda0420db209b0fd0323bd92
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 0554896b3b054ddb8280dae9cf391775
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# ea2e049abdac455a909faee6fd2601cb
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# a19b0f5b9ca04100adc230024a17e00f
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# c64d51ae344c4578947ced6fb78382a7
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# d4e9406ef2d545988444443340f706d9
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# b4f9ade246fe402a86bb6510e0ae1b60
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 8e83c66b5ddd417dbbaf44eb96639860
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# f83615daecbd465c8827504a09387801
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# f2d561e0dbef403095a17c16bd268133
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# dcc57373a22343208abe12a08ebe5288
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 9f2ffaf58a0247cd8bf2fe895e58c171
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# f24e3ca5ccad4f8b9a974e2051206b5f
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 109957d14273457aae4b1d2388e7e14e
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# af5d27e3708740a2907e0e5f5a2f3501
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# c087c261e576403d9900ac36cde6bc42
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 00dfed271bac43a48c51c234a8059dc8
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 5b8f8cfc6ca74a539322cfcaf792f5cb
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 7b429cbde2874348b7fa7a046c6a6cef
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# bf5e8b5880a046a584dc43a6d61dac03
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 2b158813b70b4a09bb176f7a4e8e75a1
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 5a78d8b2e1624f2f9fbef27c78c32ff9
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 9a64b88d989c48b98644500238d41d05
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 3a5114edcc24474d9b69f462546d07ca
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# e436ff6a80704602b62189f8dbad3dda
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 42ebb597f1cc4fbe846f99b21efe0da1
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# 727dfbf76c8e42a487f986b664b4fb7e
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# e45da465d6df4c29a000e76684ee88d0
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# a24b47bdfcb64596852c138eb3cf074c
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# bf7fad2c6e764166b3a4d815207353a7
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 1d7bf5a791cd4cdc85aa83ab5afa59d5
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 6100a8540a644a9cbd60a6ef14777130
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 25bbd0ead2704a21bb59a94ecb566522
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 23c7e1b97f20403597acf3d19deb681b
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 01b60e19272b472f80d1f0428fa74ea5
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 12a6c827a2df40c69cf1eeb31ae3ac3e
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 4a8d8ff116ad48ddb5cd2832de8fea90
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 810959a6c37a497e8a9373123ee575e0
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 8bab284b9f2144a9bad4bcf4ba317bdf
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# ec423c3d0401423d959b5d6640532858
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 3e51514b3a544b3bb0b01e0d6096e18a
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# bba88d2e638a4310b6934782a5108cac
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 4af542627d5f402e8e10ec9af16eef83
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 9681c71cee454960881d9e2451491471
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 0755f8ba443c4ce59b102279f843dedf
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# da33c66796d640188901894b20810ce0
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# c7ee0dfa51974eeba596ed177a35e625
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# b244e721a2ca4263a2791a60166f778d
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 10d0b362a0104661abc52dae76acfdaa
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# ec02bfca38df4cd2b5673e99d0fd7a00
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 55d1e4b4c04a46a4aac5d4a8bf478598
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 0ec1e566b3c64b9ebee39164d7944cdb
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# f15ec2d0f3a045e49d41e7e5f93e4e7e
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# a05d1635060e40318d24a4572c8ef6ed
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# 22c90f53f52947b491284b0db7fa6091
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# f689f11cd5fc4e29b623ee2950162197
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# ae261183335540fc9b0dec9945fd3be3
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# e90c5e866f93452f99406533dc230eed
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 189139a73a1744a7b3b967370ecbf6fe
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# efbd5a7d6d134e5eaf5e6472a6ea82af
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 4915ec6c2bb94debbc787b2bb4489657
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 62312d63f0a44409b181e7590998ebc2
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 179c5e62a4f34d2ea0a8a71279d40e44
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# d2c2f4dac786467ba4da5a8f3d680ceb
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# ac1ce7f88d7a47e9a2d15a7c10b0c106
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# daefac5a7fec4627879c7fe7412a3ac5
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 95060e1c44414164bd68077c5c467c8e
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 496118a6c7d84338944e0ed3bec7a8b3
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# c7c45d490962471ba067773c1617ce0d
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 457d13e201c64653bfb0d15ad7ecfe99
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 00db3f88bf62434ba1e8a540c0f97d83
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 7236683b5d7a484cb6ae0610605f4901
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# e5c58beffc874109bc3636bf370f5cf8
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 1fd522af4d11402888083cebc5c2cec1
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# f3d191b1562245668a2ea92640503590
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# f404ceda12c84949aedafcab3d957a13
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 0b08cb4b2e4343179ea6e42ff6fd1b67
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# b6daf0c52b4544069ea7d905351e803a
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# cd5d8c541f274b2c89c61906e30b67b2
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 51619074569b4059b9d1d21fce4933bb
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 3ce2fa4d93304fdd9864c990ae708804
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# b91096f5f39f4ab182737ab7e4e7c42a
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# a516abf410c5485fa80a8e0c5a3c7a2a
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# e5fbd7491f55481f872ef40cdb8f2cb1
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 86b167fa86f54147bcfb76f871756b4a
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# c53845719dc249d08b6edb83c790d1b4
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 7d9a0b9aa2cb484da6bda5674909e37e
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 9d483242772e48f695880f0842fd8d69
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 171e0ddd7bb24f08a5125b81f659fb7d
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 6d777d0c315c4b8cab4a3a518f5461c9
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 77a32c9fc5d242449e4f8c23f13b5461
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 46e7e352a21941c6949297b3cd3fc70e
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 0918c6ffc2f4483a9a13b690a2aad52e
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# a40e1115d57b40058f1c7d59693b35eb
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# 02cc46be1be04e0a98483b41a0aeca76
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# d0e4e75589ac4a19adff6317202d9f7b
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 0acad4da23f6495e82f05b50279127cf
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# cb288db17bc34ce49365a9e84aa17470
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# bbadf87e2f7f41f5948cd8c3eaa0ecc2
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 409a02f4d6d34dfd89edf7c0da9ab720
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 9336af1b8ade4b0797a243db624ec560
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 264d804ee212466f93ad1a95bc96f3b9
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 201b4fb100104cdb8d82b19c65ddee7d
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 4a47ed204baf4de581a77a6aae970364
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# c4907f9d40894ce5b26b27abd9c02d27
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 44017efb1ec247489ed8e87606cab95a
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# b9a935f13de14ee99344a433f4fb5897
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# f576b6593692419f8bb853ad1467e661
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 36b6c03273b34c8bb78cee97f7e74589
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 32619fc699794d0a9fc3b22868d2b018
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 708146910cf344a6b1d12c8d3551f2d5
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 12bfd3f9fa0e44359c1de3247045b7b3
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# cb3253e12f02431684eea688abf8b157
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# e3d6b52923bb42019776735106436681
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 313aa7ec2cc04ea5a677451f90b38d33
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 589adfa51bb143589915331a3ed0c413
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 64a62bde59da4ed4962dae3ffb5ffd9e
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 007ad6fa88814213a4ea447d6255f364
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# ee39bed418c24c6ca63a6847c3f48f46
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 0bd1a0ffa9e14f389e44b143a07fb5c9
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# 7e797edff5a64403a3beee4ce3c1d80d
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# e22334dcaa6043cfa9a7287f49c656f7
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 079401ce08d14c2e93e27eac86aed3ef
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# f0c99a3bc3a744b4a39735802d00f67e
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 0a89c1b9b2584c19bea14d2091b2b850
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 136b82a7d2e84c01a8b940a299354d54
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 8ed78a38cb5c40b1b7da51d51e79f447
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 32304d3104524fddb39deb22cc921134
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 048b2e519c20400d8782593604332977
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 4b929a2f92c242bb915437588cacc70a
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 09fc0cd6db2845e8b9346e03733364be
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 3446d287dc0a455b97a9c886b0da96c6
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# a63d09157a2245d19d3a35e403db5f8b
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 59d25299b46442f38177d84b99259683
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 9d09e6a5488f4447b5dfe2f579ed5d98
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 079c661ce4a94d0b8f06ba1f1c343e13
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 816ddf49603b4033a60ce96ed3846dd9
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 1280da46f1d846c8a74334c7b148d75b
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# fee87b3c411f4ce19a062c27923efa2b
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# ec6b659615504d0296881cda27144654
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# ac77454619a34bc3bb79a5d70e47264c
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 6827c18f4ee440dd9b67960a22420d3f
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# bf75b4168dde4d8894ff00ec1dabae5b
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 6564b04fe1d943c5820ff278e5586671
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# ac82770337484b4b83cc5b39b8ca1809
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 8ee9c83a871043428a42c27ee1abc5a0
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 85d0e433702243ca88696e9ef1b3543f
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# e868e564bf6e4a44a1a2be01229a20b4
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# c249f6007a5e46ec8354672ed34ff5b6
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# d9cd50372a2648c486db086db6e6d33c
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 7fc3c0ed7bdb4e188cf4184569e8c5dc
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 530980365fc24edcae33885c3452e16f
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 734e476a28ee4004936e9ebef8720c7c
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# 7d7c9af370da422a984872738b7ba186
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 91d84234233246f890f9bff71763065e
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# d3ffa1db9e4b42729211242de44def40
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# e9821ec66669400cb94dfeb693cf5488
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 52db10b776e24087b2abc3bf9b21927b
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# db986cdc601c40949af759591fe06be4
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 07ce255f79c34665abcc759bd9c04ff6
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# fcadaa73347f4e3185085c31f199605a
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# dbe1819f76a548a5b5ca1c038114a993
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# e576a35e8a4a43129a317fae58ab399f
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 464642ebb3e14e35961a9f22d5c830a5
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 2f0d88bc79f44acdb00df4dbd6d5bbb6
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 975f905cf12a4b5da2899ad5430e58f6
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# f78146f08fe24b039ba0e7f093cd7b20
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# 103b51634a6e4b59a8baf8bb714ab8cc
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 7e16bf8770f5467593634163cb305390
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# 6f129173578a42f98d4873487db136bb
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 15e43b2d69324b29902a6e1dd33b384c
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 8aa192c5750d439ab128d7aabd74bac3
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 7c01d00cba854ed980be6f765dd1d694
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# f9d14f053b3d427b9c5be96ec7935966
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# f7fa5ae376304044a0f8c1858b46bcba
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 1fc69988404945c0a96bdf98b340fd18
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 27706fdc40984ce5b10f0eb304f59d2c
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 44f317f13633480c8ff65044a917022e
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 447d409b0f0f4b9f8ae68bc3d066454c
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 3a5d4eee995c455589d562e25d396c69
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# fca52288b53043038908a826392d8a86
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 8eb022a1816c46369f3942fb69e9049d
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# ba8677b42e07461187470f8301e9593c
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 5e42183f9aab4a9ab73f9368f8e75f85
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 5247eb0aa90a475bb6243b166e7a8d8a
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# a27e6b3aad1e4fc485d252e2015910cd
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 0691f825173a45a1a8d530ae94eda8a4
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# b58104e5d1f847c18437664ccf30f786
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 85b016629891495e8856bf02ce329a00
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 8d480062b6c1490eb015f045edbbc7ca
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 34d83513cfe240d483ef09537bc29c90
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 877fb4e72fac48ef95c9a9e012bcfdc9
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# a5de395538614cea81eabdf0814b86eb
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# ff8b100b4fa243e6a275f66a92ca9a40
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 2ad404b5ed814cdeafed8974b66c587e
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# b5706cbc628e4664bb73d1b7f669b235
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 9308aac3ad3a4f5ab506a1ed31bf94aa
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# acd0d409b80f4819a5f08cc9b22dfe33
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# cc4671342986438dac1ac2145649ae42
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 5954431059df4c0a9cbd7933d25e283f
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 6656a489b9214d9e9f124e49f285a212
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 8ecd8506d1414cf08dffe9610092a1a5
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 288b3f47c96a4c4faacca16382234b08
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# b95e9e7df43a499889b7367e4309bfb9
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# fa7f0ecefaff48cabe20b68d0a911dda
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 441dad62e2d944bdbc88865d1ae9bc15
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 3a75020615f14b74addfc5d7af3a66ad
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# e3aef267a8354edca6cdb0ed14681c9c
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 34d636fc03d646a4b44715e2bbf958e6
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# cd28a6c9cb3c4d06ab574ef8ea74d06c
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 12f0c131beaa4aa8b936ab73808773c6
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# daf617fa219e4ae080660e21d9b6bf06
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 4720196acece4303b5c8881ec003d88c
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 2c84454fe3c1420da249e107f3246fed
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 484cec2c100045deb1648bb84cd47957
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 400b2b57685a41aa8ecdc9891ec7b5ae
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# cae39af6c6744205a5003ddb772ca49e
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# a443bbb4293a4cde9e4cecf59aa6167f
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# ee02dc710ecf448c83256ce691b8209b
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# 4bff556840dd48d8920e1c9f23fc9c61
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 43d33fc92e764863ad315effcd25a7b1
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 5265edf3f9844d7f81ba7cbf5fc37e27
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 7786955dd31e4fb88b84cfe9b86c4ec4
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 4c8fe7661c00431eb1d0e916536bbbca
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 52f78ecc502d40f8a662b1ee72cf45c2
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# af0ccce1dad64d1eb18f52758474ad71
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# a85912a594fb492aac85e8ade6b77db5
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 6a406e9cfbd14e89a540c32cb7361b63
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 4b6e9f4d2bb0477aabb237e18aea2180
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 9e4ab9756cf14ec7abd867b8b83d05d4
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# bf4e2520621144e29608e43bf0605789
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 46cd98b7383a446fa3fe80643ee5d741
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 8daf391f1f42486aa9af20a2a8d68a61
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 488b6ed3c2ee48b1a4fbd20d922daaca
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 572aadd696384e519d4ab4ea1d355225
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# bb0edf27d8a14f858bac4348a36093e1
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# d01dba054cb541fab9b9c2f4fe76734d
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 9e92ef5a3b544327b2699917ec2d6068
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# ff5a097436ff4ff2891b126ea3b64c61
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# b3e4ced81c8349449642ff12b64d60cb
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 0dfb7db684c84ed99b33baaef731ddf6
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 16a30e53d6394f7897947cb4c90f17dd
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# a55407d6b7ac441f86a2b7446caa3cd4
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 8bde5db95fc34b0fa9db33c34cdd5c7d
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 6db98bfe7809424fb352f20e5f731666
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# ff5777a7bea84c7db189e79fec111ebd
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 7732acb1779442a4bfa35350faa55b6e
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 96e8b56ddd51441fad470e3c23d23695
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 7efb2db355c4430ab9d65ec960cbc6bc
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 5e0172bc8cd243b1bfa793eb9a49e7b8
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 74ad4dfa4cad4169a3120164ba6f4a44
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# d2e0273347b5485890ec02cc5f3a9980
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 29cd92573a034d9a9b4fe6ea0a0c9621
# 575fb9e372b54286ab8588b683d2f2f8
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# eb147d611515476585e80885d20603ad
# b9c1a08d98ea4e53b9d728bda6fb62af
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 83c9b84078e2400cb3d068ef1bd08c59
# 3ad0a49c4742458291093ca5b62d009c
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# 03854d8a81634b0c8d195521a861cb14
# 9f7b2c4142b340e6ac037b40b2c5d7a4
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 95fa1fadc3c54ae1b48af95e082afd0e
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# de98d03e83574b15938f6ca72d0e72e2
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# c31679c66bdc4e86b9b8a4c2dd4742ac
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 0ae07161b8764ec5b63e978a76dd1715
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 4642e9f649cb475e9102e42a92f1e12a
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 52932354f16f4a7cbb0ff3f12e4d7dd8
# a72fcfb78643420b958dc3158e4d0022
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# 8bb27c5de5e942b2b3c70899b3901a03
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# f67ef4735f3d415dbf862fdc55c05943
# 0f3c46e9128c4fa0804b3032615b30a0
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 37400f32d99a4969b83da545f99c92b2
# fe36c1d642e3473fb179725df89bbd07
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 2995948126fa41f0a61611cc782ccf7c
# e924d295a9734abbbac33ceb0e873137
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 8c4b1c923a814dd58d9fff5247784e03
# 936ec6488add40aab16e5b3636c56b28
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 211e5d21e4fd420ba1da66b88c2af113
# 9c6588519e0d46f69b27c9a7747afd8e
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# b4e34615f2134a98814c562103aa70db
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 431ac0bfdc254445a09781039404c177
# 73c949eabbe04c958dea73e302813df3
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 1298969cb6324317a43da23afc898c6a
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# d46983b5cda943f29bb9a738e66613e5
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# b1ae09c37b334b36a202f63a3636f78e
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 755526c404d745de99d303ab5203896b
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 397050c8bce24709a2b2c1cadd787f5a
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 8ff63c9a4c9b4eb397d865a63852c4d5
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 0a564ac0e63444e5b80119728e509880
# d17b4be606f24bcf928e1579a5f0bc02
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# e9f56124a159454ba409866737a99f05
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# ef433a731f1644dcbc34a35f491f174d
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# d8e15ee7ad2c492fbfc2210411d05845
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# 33437461d644407e97e32ea4a6f4fbdd
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 574fd765998e4d4baceea627c5f9ef28
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 0222cc11f524449e926a67a27962e5d4
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 846120d7a0aa483a9ab44877de02352a
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 8454cc0f519e4e4894214fbb3946f450
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# bbc63e3c0deb4aabb8ed3dafb8c2f792
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 3055a002c43a4b93bd1ca34e2cb6b1ef
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 5129b99b0f3c4abb9d9148efa989020b
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 10a423adcadb47cc88990145cf1d9af4
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 75d42a6a1827448797ebd4cedaca142d
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 38b4acb0e71e4e7eac7cc961e9848949
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 7eb839edd91243cdba51907455ccee01
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 71f875d10b9848afa911babefb0e7f2e
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 3ca6b132d0524f7bb5708446e1dbc390
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 1a748232ffae4245aaa73b9eac007f21
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 8d32ace10b3b4098abd434c9563c705c
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# dfe46c1b24cc49b58a349e274440ab77
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 806a0b01abda453490fd6104db0dee5c
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 2f98c60f6143472c8cc056ef7bf790d7
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# e65bb94caf3b4c1195eb7c605107aad7
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# e90f98fc7b164d6f897b5b784f4eaa13
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 1a7be7b715454b6390a1753f5e678a69
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# e03c47d2dc974cfeb33b45eb6e90df04
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 54f561503b1642819814c3a266caf233
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 82fd04d7b6b64f2083f627bcd36e6b4a
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 0312570a32124d629dd1b723dd0f68e2
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 373be53e76574bb182614c13cd2a5053
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 4c94db00f1e046e88021c0729f7b1fb9
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 89723ac46b5e4bf7afa5c478c3a804a8
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# d668d6a73507452685082bbe8f72921d
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 0521c392e6704e2bb39b46b4ef737d9c
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# ef67e07925064fc18d9fe695697afc1c
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# daa4c83249f94cafa9f6e7d9c5418ccb
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 37d94dd792b04f46b56e9d07f7011bb7
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# d9b0d1878b34454695315b2eb09c85a3
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# f8058e641ae84cb68d2eb0379c58e063
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 15e17e10242b40f6923534129b15737a
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 4b6fafa839ed458eb7a595c6ca8d8dc4
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 23ac35dffed44520abf5a61c3899942c
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# bf0968c5521148a6bc3ecf291c0c99ec
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# a996cb85800648168fb09fb1547c9fe6
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# c6577ad3125245f08f859add1dd0ed4a
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 756ffc15da24430e947e382a36351261
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# 8d3ef53584ef4d9486318ecbe702b064
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

