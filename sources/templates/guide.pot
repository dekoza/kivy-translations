# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-18 09:08\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 582a6e4fab2a4694b84c7840ef085470
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# 2097d3caa2b641a18d187a2e84be108e
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# f7c7c2aadc584bf58fac1a20e69a69df
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 4b91599f0a0d443aa199320ed37f32a3
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# c787f0e076ae4a6dbecc3ae1d954c658
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# 2eb8f684b2ea4112be311e1a22a3ee7c
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# 9a59aaa547534dd5be82217900994ff0
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# f442953106c14d33bb17d66f061bf5f0
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 0aa1bcae61854018a75b7ec21cd16044
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 3d6a89c3934b400ea429e4037cd6a50b
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# a25a835635154269a7a34aca667594bf
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# 28f949d0c6e84cfdaecd35dec4c4ded9
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# d74c19f72a2a4b6ea4da3107b7286ce8
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# db7ed2fd723b4d96b6e356ac241fb0f9
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 113622e152c24485a9bdd37f4e25f8e3
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 457f487b6b574b51b746c26e5b0cf7f6
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# bf9702f2b1134829ab33691a73320a12
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 5f82f7c024484afc8f4f402bbecddbca
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# f1ac7ed5f5534fd98ccbe541c7aa9461
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 31146dbb153940108df4e20f4579fa59
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 67f832c0a1ac42cbb0c2c6881858a136
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 63e7dc8f36634fe181aef2f54e7257ee
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# d24652cb6922456bafecfce982c0482d
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# 00a1d9a2bd7545e4b5bf806ec63328d9
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 37817d7fa9284017b3bb230f7cf1f6ac
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# c618bc30c50b48039795660c29045d7b
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# fcd9612960ec4749be3f703fc187a816
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# a5107678cbeb42189593b642df76b0e1
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# eb6f9b7fb32c49c8845bdb2dce53cbf1
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 6f3af05f4bb449a19c1a3aeac0fe0d81
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# efc6a49ea14046b2ab2511a391da5455
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 89f5241a03b84eeea2d6cff9a0a3b15e
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# 894278579ad24548b62ab567cfa71b89
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# 4edd743209414b849f259e7b42c98271
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# f72c642a1cdc459eaff72712f1362dc8
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 1aa861f4759d4a85949b63be969e8038
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# 04e93873e48a4216b9d566c5f6b39417
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# 4b4890c1d9a34d339632b13c6f14ae7c
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# b8c2a37ffe6d4420b64442ebccb344e4
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 0533a81e33744c749a1c6e4cf97ebfb0
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# ea9772ddb9924a348c0b5ce6551abab4
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 7005e57f66074db488899ee951da516b
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# c37a2220b3da4c099c6ac12770fa4135
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 0b1f559f9a8c4a518db355038e1c1855
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 162c45bc36b84673a220ca481dc960fa
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# 8faf67f2f014460286a87f717fc1d909
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 026e5a0489684699a94591a7a739371a
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 3dfef6eb4a9e41e08aed0d901d1c59e6
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 894e461610a14ecb977bcf0ea7fb5407
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 88c3f193fa5d45d68ce13bb1655242b3
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# a450e1285b044466991ed895e037e9f2
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 72257ec0643c445bb3fc5a64b56261aa
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 2670229670c14215a5fd989fec21769b
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# bc6c11430aaa4839b52bad33c6a30a36
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# d3ac350f8ff64960ba901c551d8f41b8
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 7d6fa34980004312879c324ec13d27e2
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 5b8cf8aa73b7419b9f5d87f30b236205
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# a0bbcf5dae39404996ed638c4db9e0c9
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 9729b9bcb9344fd1a74823648a845f5f
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# d412c987906944688fe01508bc6be2be
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 3ed959ac505f4582b053a9135fa4bbcc
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# ee93f91935bc41ffb15117c413f454d6
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# 77a5cdec60ae465aa04592d98efed49f
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 1463848e08f34ffb9c4e942afcdd4f71
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 2ae23502213643baaed2f21c801525d4
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 3b0470b891594e7a99ebfb06cbe259db
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 3441a1e2f1914b07bf1e89b96481aeaa
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 59c5baf4be7144e486f9ee796084ab84
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 9368c04c5d1146e0bc53bd7671fbfe57
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# f6f69639dd9942e5a25c27193c9d4eeb
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 7c32fc4da8d8422cbbb86d8331e6ec71
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 14513eb4bbd9477784480f5669b7cf81
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 7e4c5079f77a4a45beccc8b63b107347
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 99278e5ec2684cd6a7afcb77a18baac9
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# ad8c80508fbf493590f4f5390dde7bab
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 8a569d1ab9cd41c9be319b2a3fd30ee0
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 812a7de2ac13495da276eed65a4edd53
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# db7ea2ee8eab4b5ea3710af58d3c39c0
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 5bc11fc3d9414669a7508bf1117552d2
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 50778fbe5fe14a7296b5f6a8afa5ec09
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 45da2251b0c140eaa5f555d3c5e0fb67
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 4d648e59ea54446891e0d7f668a033e2
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 361e10577cd14a64abb398ef1a144fbf
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# fcdd7a65e36245f9bc698242e90f5ee9
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 551031beb57b41998df460e4be5ddf88
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 48f1e2868b2a4426b9fc23ab02d05e43
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# a6660be7793141c5b1d3eb8d2d72d278
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 1b9312b99e2d4a4f8055995ec6a49f58
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# aae521737fdb4827bc158b9b8a245e7e
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# baa5988ccb2c495cb8d6d82e43a41662
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# b13e8caa947d409587316806bf69e903
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 8a51e0d9775e4348b4e5fa01e2f02900
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 97ac809fce54494bbdcd38a9d26416dc
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# bbc66a5e22af43dabdd3278f02f62c94
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 869eb2e53a0c41a2b352bd5a5cfda1e8
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 4344a51e50804851b7213e27c7531b34
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 6247cf0de17d4140a5606d4ec0122a8b
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# ad27df3e36674db0a72040dc59ab9a40
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# be1adc45afab43418fdd4808ba263dc2
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 754690aae93c475eb1e77d5fa6f6c8cb
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# a39cf74ec6974ee4b421cd9f4e0e9c25
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 6868ff5d5d334726ac1ba759f6f9d195
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# ee54a09ad31642cd90acf601a325f33c
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# a3f08fbe49a8417aa3a5279424ecfa0c
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 325d9987b0e34031b855ed29aea71ac1
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# a73709bbbb154dbe8ffc85b37b3d6184
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# d6e488681f264cdf92b70f84c7a616f5
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# e6b0470e941240b488b8fffee25659cb
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# b067b32ef7734804931a36be9e024b71
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 447b9ecebffc47448b13f9766732dfe9
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 550b25ab417e46df8325892ae4662f28
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# b5074b4b855a4b78821e8b1d31af5b70
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 9f62682b533549959be543a50d980532
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# ac025f29728f4656975506495763eda7
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# dd6d9111f8744b44a9b84c66e3e987f8
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 96aa114d3ab54d10b191e83cd69e64fe
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# fdf655445a76450288c5ff8296afa737
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 4ec4e1fcb81844feba2e00148abdd124
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# 1df494a83d1643cda70b9008674ff699
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# ea081930f6334ae188f6872505fd3f94
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 0a36b66816a646a8b895e1879b7c4503
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 6459c554d28148e5842168eadff630b7
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 96e530fe7ea046bb9a82e5504b873540
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 55155e88defd47508e7e4af39c77383b
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# f76e8e0b91964010b4b0e824e9875556
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# ac58d0617c7e433e9c74639e841edbc0
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# a673c35eb7df4be8bac1064461eb5cea
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 2610655a056a4dec89187d8736bdefe6
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 3407313d590b4a1e9aabe234c8b87694
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# d492ec26188a47e9a54680ca808f789c
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# 9646edb26f0a4ca49d4565bcf043187e
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# bcfdd798231042aea5740f0e47d8bcf2
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 5228a9e5b82a41e8889c72ebafa7a7ea
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 385ab05e7fed4d61bd8f3184f2f3f11b
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 144cd64189bc4f85b11855c32525874c
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 766d57b1f2b44bfcb5dc46a85243e273
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# ffd6003ebbd24d828fb6c0fcaaa1e34d
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# fe919fe3157246f4b02eb3c32499e73c
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 6d3ff402cb1d4b93904b2a49b149e6b4
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# fc090add6a654023b77397a25a2b97cd
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 7834d9124ce54cf49f8f0403ff865efd
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 9958724835144eaa9a1c3fb2c70e3f72
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 28c81dc93464405189856f6ff3bd4671
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# f6a7f01058c34b7b8d8d9d28533de3e4
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 77c7256637e149c0b49a3f094b977441
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 9955be52af314cdbb3196c779d04be0c
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# a5b18cd14c264c86b4be30d2fe26f10c
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 948e1c6166804887b0919a9772aaacfc
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# ca039cbd88e94cb183d449d9a0bde0c3
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 02210f0e613e4dd39bffd9a6d98e2b3f
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# e94ffb48fec24dd0854a560770e2b9a5
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 511aa7dfde304815aa6d28436884d940
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 4063c75c9bc948f38d55e692f7c77184
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 10b6bd056f4f468b8dbbb08668f6db58
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 7348876d6a0749bda880029568a0772c
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 4f45eabf7cf2477b93b0e7380dfa660d
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# b90dd1c76bc04e63812931ff258aa4b7
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# f7f9983cf99642cfb32be46f790bb8c6
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# a868c9683e9e4cb1b4c21982bfe1aa65
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# c81359e29ccc47da84b858393ce98d1d
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# e3a706cb6c674be2b10aa5d2da8264ae
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# f7829f6e3c664bfca5a50281689f95a8
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 34be09aa56444bbc94f81a915105a2a1
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# cfb656a76dd945eeb554f23e48709a37
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 48fbb3f3157d425399c4461bbcfee0e8
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 6934de56117c4526b732749a8747a8b8
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 65df19af1758476d8d4ff667325fc98f
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# d20b8cedaab74d0bb037dd08ea2664f0
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 2df713bb48e44545969abe902625f944
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 859d6ccee770437aa921965e1eb2ed65
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 589368e74a8f4947bec39718b3065400
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 51526975ddb44d298bb60c51ae2ddb39
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# e72b08f393bb4f66bf249bdacefd5da2
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 746ebf6f03a34453812dd6b994e5bb93
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# ab968b244c2c4c01a4007dfda873fd4b
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# 5c4b3bb64b434c89a4a3b568a42db853
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# e86f2797d8d649018918e5712bb5e44f
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 9d792ffad86c452aa4f729b8fa87b967
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 9644b4384d4a4359ba216beff2982b61
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# bfa1e2293ccb43fcaf1438e23a60593b
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 8e6ee631bc8647198b64707fe0a3dfd9
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# c18d8829bfda47d98ed51e54d65ac5a0
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# 29895ccb0bc24ca4b91341a0a35f16da
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 3a66d09cc439452d929cd6107c542c33
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# f75741f483f64c919b3ca05060e9d0d7
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# 9035ab6fb7f040ec98b191b9590436d8
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 9a4d0be5eb7c401c83ed4db4c2b485ce
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 397ed93eeafd4cceae1d439956adfdce
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 2d6e9e85b4c1420da8c22752a935499d
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 8c33db441d894889b60cc01d6f0d09ce
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 6cafe235364b4ac3b6d701d097bdc384
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 873440f6870248c6a7988c30edbfe1cc
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 2a9765ce107f406abc90d76e4e7707fc
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# a1c66262fa334028ad70e0e6e9d00a28
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 9b9abca139ba4688a82f289f78ce1fa4
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# c796093f85c84a63b9ef37bc7b440e49
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 9d364e86dd4145eda107451a64956034
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 9472da76e07c47fbaf4af91bd9af5097
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 0e5cfacb7a87448fb444bf86d4e67bc5
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 667329107f23414c9a736aebaee557a6
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 5424c3eb8eb240d9b21ae3494cf51f76
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 636cfe2a7f69448a9d77cc9fa618b6e2
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# b294f5dd87ca443e90fce229563f0e69
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 9e50e4d8a84241acac6bf38bd00366df
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# c1e813f89fda4d0e92ffe635c682bad5
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 5e2a501112e140f5a5931ce7e91efbb2
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# aafbac9d4ffa44c891660f9de7086798
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# d271f01d8b0c40dd878ba5369726e8a4
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 552bb65c26554eec82765789508e9c5b
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 9d0820ce7c574cc5b802ef2f6d816267
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# e6e3cfd69ef14c20a0d3983b05273fd4
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# f67bce261f68460cbbcd862d95cae453
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# e0d5471631f64b81a3f7414bd6c5fd64
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 2d3a82a096e04c58ac15ed239129d5fb
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# d102d4610c6c456aad9808d234932746
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# e63a636c05af4ae78b627bbe938ecc87
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 73968eecc037460b9eaa0e4019d416e1
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# cb5ee5ddcd5243acb7c45abc6b945eb4
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 1b84bf852cc040eca92ba8d22da8764b
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 30157cf414ee47e795e47ef88a38cb7a
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# ce8f072a27584c71906bb8ed282f0d97
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 3a5b256737d94520a34032c7b013c26f
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 47e7afd689b44abf8b9e7706a781eddd
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 685eb464517a4f979ae7c2f4b78e63e5
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 9784c68f5d344df9ba46dd573a2ad71f
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 5afe775b82314e8db409901b009c03d7
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 73b14f492e73476d90c7faec6f423ffb
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 2628667204e8457f923801cefbec2d71
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# aedb5f5e3c9a4906a24dedbac6ebdca0
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# eaa096f9d0e84d449352ac07e21118af
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 3858bba6df234e959e884784ef68c214
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# b2432b879d294a7a815a441358daa01c
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# e7f7c55791fe48c3bbd6c96bfd5be9c8
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 0a8e6206e74d4df9ab128a15f4580e3f
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 829a527438934192b48041e657a717e4
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 4e096f6edb564ddaa637d1a8e21585fe
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# a4ca6689044c49b7946df67f54166cff
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 2b614d3ff5434f23aec229cfb942a00d
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# a6189039c4f1481daa178322bf7dfdc4
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# da97e8ac839e47c095e4268c05032dd4
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 9b638de5ea464a2794e609aa3b8bd42a
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 27d62f9618e44f9a9f28f56c22bec250
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# d2bcf8d2c1ab49309d0c9b10e5fbf18f
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 2936e4929f41422b996696a23e6850dd
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 4eeb4210847a4221b7f4af554001e1a1
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 6578194b09794a88bbd35e739927aed0
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 129431299ee448628720348ac8b4be6d
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# a317b98e50134619af5a98d8f753bdd4
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 5d98b2e1e6f044af8ae5c87da30613e9
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# 16b39ca88ac34f8ebcefe4bc359ed7ca
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 6b0f41b0c10a42e88a9919f0f0410de0
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# bf62f1a6e51f447aa358747a90ba2a79
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 56d3c9cb98c44d84907997691df41210
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 94348befe68d4caf8ebe35a475393d46
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 27ea4317e8ca4f41886489cd2a734127
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# c15998f9f6364349bbddfdafac6bb463
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# d30d5d08671248a691022cb556769b13
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# ab4d4a6761eb4cedb76f07fcb723d7da
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# aa9bd6c812c24c2e877d386c64aa34f4
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 8da38980ea84401789a60d82297639f4
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# f9a965818a8a41c5b4a2fea76841f392
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 4cdd43455dfa440c8a0ac036dc6d1271
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# f15d78c879c7423991213ef51bbd6b0b
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 300d41cf02524f76861b744838da4451
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 506023247e4d40869a289a9b8961c444
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 76ee371a6da042cf857fde8086ff3feb
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# c74c06f2de2744d08d7851d510b4ed41
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 7d0b20d93ae64b5589608e63149e7fc2
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 6cd3da13b8a04681b1fc3dd646ffb274
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# a1cdf75c72394e9d986691aba4229a60
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 22b3444b53b149d3a1b1825d63d3e880
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# 6cca3dcbc4364d2e98c61b0979875a2a
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 90c174d93b9e4530ba414d8f86f2625c
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# cee986873ee8461286ad0a0b8f342d4d
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 9b9d3d63e047407aab5093decff752e5
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 295651bdb0954f8a96f27da7953e1733
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 9d335dcfdb154ec2a0f2057e0c345309
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# d4e43b5d17474696a8157e2981cc57b7
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 3efea82df089417b8c1d93621bade53c
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# 5b50d4dcf95e4794b3fdcb344a9c1289
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# d7fde7d4efba452e84710462af035049
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# 10009fc04a16421c908439a66a44bef4
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 7688b0c8104649c3927bcfea12038ae9
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# c900bd74bf5f4ea99dfa82802580875b
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 7e343c5f9a624344a4415f5e03590267
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# cea4df29985b4d4292152d636a7712b9
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 7903a559b2654b1da50718323cb3655b
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 8fa70cbc21a946babf8a368cacd7c255
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 2a43b6f17ebc4c559f14e64a14ca44d5
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 9ddb781fd1f84daf84c9775ee42417a0
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 5f31caf5c68b4a7bba16e41d65bee9e5
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 3da096cbe57b47c58c6db1f668cdb1c2
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# c8a34ec0faf147798f798b918f98fcc5
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 54bf693417bc4b5a871734126708316e
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 41bc416541ea4852874c5eeb64204acd
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 5d05687a753f4acb819207c27e0c4884
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# b162abb8aeb54b4a954de4c8122e7260
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 41db594450cd46589809f7bb7b569c85
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# b741ba0e7bed4e9a964ee34d90b164fc
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 6a405092461543eb8692167f6601079e
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 4f2e5e8a0e664e35aebdde96b3d805d8
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 4619ef7dee9b4f42a88b3334e36db2b7
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# a74d8be17f7f451193c454e145d295ee
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# ed45b8deddd140da861e8c57aa7219c6
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# fb2f56c9d0fe489083d90db2a866b347
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# f97b334e340941a1b2ca565bc8a805b4
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# a4f4dc2c5559493884a054329cbfda67
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 19f7e75ec1804059989cd7f39e91a285
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# d65a5883994048d9b0850808cfc26748
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 3caca3b121db4678b610a50b284cbae9
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 185634635ddb4e71b9ee27022e69194e
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 6c4b198676ef4fac890bcf5904ae226d
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 77d6c029ab9e4a8aa7fee7010c151431
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# ab8c5b71e3e84db9bfafc0b0b2f1b2ef
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 51a24482800f426f84a5dc28ed50a24a
# 1d414359997f40b3b99feeb4bb4a8789
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# f107c59e44904031a06066988ebf9dc0
# aed61f96a6994fd09b6e786dd431bb78
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# a3b1479affca44f28ef0f16f49030504
# 7643c4e8e63b40dd9de41801937882d0
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# e9e76c57dc5f4a4ea9167ef6d6d5e40b
# 2c4dd562019b4afe96f6df2e0b8d9b80
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 21d956cfee9a4606bec99fcd50c42fd0
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 68491c22d71243879f1d6c5faa64c5ae
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 6fa28d1bb6e74d40914fdc8653fced9d
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# d4c08193cddd4124b394cef502f00aa5
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 2eb3b27cdba24a618408f64fb18c742f
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# a8a8f1dbcff546d0969deef6b415fdb8
# 49e2b63648414d1b85d0cc5528841bf7
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# ef35b5d38f23482fa6a6d1fe1807081f
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# f995eaa0b94c4bcc808b0352f8c3c69c
# 071e49836ea341e4a7cbef9eb6deb1ae
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# a33791bfe2f849bdb5ffc9bcf0c841b7
# 297a74a93f8d47889aa3f68b49eb475d
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# f79a50d3e67049a8ae1bde20bef65f5d
# 1b356cf2e52441de9fa2ecd0db01af27
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 4d81b54134484bb4a40d7ef9884a4ef7
# 18d2724d84f841d2bf4116cd3631025e
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 41f94da49e5a458ea9f239ef832e4275
# 99f5b863955c41f687851d2d0f758eec
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# f95c45fae09f469da5087e2a2f5a095b
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 2b39e4bad9c0434388a30f653f7cd2ba
# 94e07567aca54beaaf7d85d330b836f8
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 24abf41a5d7347f3959172c6782e018b
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 156266dc9fbe4006a5e7d6ccb998f3b2
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 95d66de9489f40fea2a2b05b1aa04c2a
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# f1253551335449adac99bd6547d621af
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# e59fcf2206af43d0907b67988eafef1d
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 25d9e3bfabc74e55b7e868899f7b490f
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 2da94442d1c64667a306cf8947e60011
# 59b37d98110343f8b99765fcd3af1444
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# ed9b257fc05e4841bee4f23ff5109cdd
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 1777375282434eda934ac1b63b96ab21
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# d54963ebc7b04e4eab5cd9c09f00c28c
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# f3f54021186e4f6f9ed61e3b76b6bff6
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 120f672d10e64f2b9dbd711d6fdd28f6
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# c6d768414a264bb1988aa7abb00e673e
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 8519250adc344b91b7e87c119aa23750
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 3f3dd048d71d4bdc9290a596b2f8946f
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# bbf6bc1339cd49599852ca24a8f55d01
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# ceef8a88bff34684bf2a9c562613867a
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 8c0a4422543e40749d6c158737727480
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# b280814bd7b84522bd5b0615fc34eedf
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 3fe0a32f2b934e33ac8bd369c2f0c24c
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# a976b99ee0284afaaf89fa0284a98105
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# a0f8d424c71848d6845634885e43d800
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 516bdc5777284713bc7594f9a6d53d21
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 5beaa15642fd47c69aeb5934a73f854a
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# e4ea9f173ec347d098bbd4e1e5910071
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# bde71ee713d140d18408423c93248bf4
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# d52cfc3dbd75417c99ea1b480316bb96
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 54e7b3458d9f46e7b7929f109a36cc1d
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 30acf8de827c4b7d97ef6d852c35cd15
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# a7e972e6848d475f9b850ecccdfb0361
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 668a3a678f3c4b8bb0c8c62779c214f5
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 5bd7b4d566994a38a97f768a184f6ab7
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# ee8f14246b38422cab6e5444ee6e9b98
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 5125fd9e507a4ba7b2966e225a81d756
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 7bd8b1f46e0b4739b0b84f293ed14dd4
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 9762b2138b8c41928343475a04ba9f4f
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# af09daff53fb4ef09fc6f7e4d4d9e477
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 1336b828618245a99df9295fb72b7c61
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# ec75d4307a2d4fd5ad166cfbb5a7b210
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# 57e85abb6c8d426fb8a768eaadb76371
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# e10e6334da1f4df5b3a7aba96c481bc5
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# c36d03f20ba04dedaf0c90e87d3c888c
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 06d4a7821dcb40a5b36674519557c7c0
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# b5ec2d766e0f4f588fc824eec2a2c64c
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# 1e302bf44490456b82686a5ed39241f9
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 1ead0baa0b784030a4b226c5a34d7030
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 276328e7086c40ad90350b2e1c83c50b
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 55ba88b1a4984bccb30bd526369531ce
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 1c24b5d3afde4a9cb038bce7776610a5
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 4a0a97ea90dc453a82a917bea9553a4d
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 884a81a5aa32488b861e6b12ea1ef803
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 0920be47e5b7414291e252b85e130ec4
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# fbcce3e41a6942fe8dedc4308494738a
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# 0175b643895b4d51bb5206684ad25215
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

