# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-18 12:53\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 334601ebaae2418a9a3737b8df0366f7
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# 3f773cea81e7491c8876387a1747e17e
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# 532690572ddd42e399cfacfd5c27307c
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 8605bcaa236c4c1891a4b512d032a9a9
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 7772ea5f8c704893876721c8323f6dc2
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# 599eead39c5d415b8f064f5269e97d16
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# 1e184b64f8814b9cb09ee6501c4f0ff0
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 658c4115a5694722baaff7f05b147341
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# b4588dce6eeb4022a8a6896687d6e647
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 7015b7c828c241a6bb01cb3489698294
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# d109bff565e549a0a2343b3ab3e79f11
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# 3ee3f05f622a4b2491945438f51130c3
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# 4a1925b42ce14e76a05cd23f0326b6fb
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 54eb99c1ac8049dea0e48d4362bc13f3
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 0d8c24e7c13a4fb3a730451c368d6388
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 9b41b8f7a8e74086ae8792633604942f
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# 79a1201bae66430fa3c2f9062ed26cf8
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 376879dae9014d019f73fbc1bc756a3c
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# 30fb99e46285470888302bfd4fe668f1
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 7acb7ac8117b45b9904b87ec1c262058
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 542c71afb0954484863cffbbb427d33f
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 5dd7c81ec58f43c7b0e250663951bb3c
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# 64ee73b381124e42936f05309ead787f
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# 8b7d665778ea42f3b5ecf7409dde130e
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# db0f9cbf6dc94c6c8cedc7820cfc97c5
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# 123d6858b2f643efab7d4b8521929c34
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# 255e835c92484b9e8a549e194e81d73d
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# b8d5d2c5de0341438cac075fc32bf9b5
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# 53d1ff45fc0344b7965ebc73e3f79f01
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 4c0c368acb1e409d961fbec0f1e0cb7f
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 1cfb6fb781e04d0189b33906e7c075d3
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 882b3bc6d67a425c8693404eb36c0987
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# 05f9399f753c415a91b28baa44dc5b98
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# b4403412485a40b495c64d6580cf02e5
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 2c7a16d1354f4c93bdf15909a1ca4727
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 212cfa8e8be6465ea62b193e7758fcef
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# cc38c876f250437ca2fcca90fc4ee834
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# aaecdf0f666642e7bb74a64638cb3c14
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 9b5f735adc6142c8a21190ac025c9fe0
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# a7fb391fc1794ef1bf4129a2ceb06494
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# f47fa8f64a854413a75adb4499782e37
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# cf81e790017645efb50e20f26f386523
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# 5c0d0347ddd1421ca797b6b999502eea
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 7522f6f308004974b0dad486a2091a8c
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# b177d6f2c910450d9363d4219887a031
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# c5b649dbffa941a192af1073442d06b1
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# d8503d3f9ecd4a27bf03a279f0e6cadd
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 2c086ccb2e5f47c49cc8a0b5ccf3c45f
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 67009356c02c4adcb2d4162785838bc6
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# ae15efd50c0d4749ad9dccb4b4693c0a
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 958c389725064ee9b785872be2e2e1db
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 5d9073e3f04046f187142bcbd53fc856
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 8225dfff0aa4486689d69d6993f4b2c7
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 0ed8c26d63914394b85e6bcb75c5caaf
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# 61eec502861947b68b53d7e358b1672f
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 8666187fdfdf4979b9257efd82894ccc
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 6472f54cbdc14eb5b21b26482dd3fdd3
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 223c6897f2a04d1bbf6c6d37d6f0a40c
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# df864c1048f541acb9d3c5f5d31f55f4
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 23c0376ea7a54a7883ba1182d67b66d3
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 7040c00e9d424550be92fe5a192aad52
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 951305811c454c7baf5a26aecdcda279
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# e5062f97ea6d43fb8a35aaac04fbccef
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 35a4d0dbb8374f4abc3ce204da5dcb0e
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 1cd2caae07f04a3d8c7ae3a6683d5c87
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 5745f6c0bd4b427585f38420458d8044
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 208ca46b47bf407e838cccbd06c5a64b
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 54991329723549ff9eee5af34a021504
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 878bdc8152ee4c58b62ce6201b17c806
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 123b59cd35c348dd965c260923ad6a5f
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 5c742b7fd17e4197aca1d9fb71e3e38c
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# c7c1c21de7334829a2236632ca4b9883
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# de68ad9bc2554d649669c0cc7c44aa43
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# cf3de1e36e8743e98ef5ff74a3e49587
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 6382ac2f39934dec983b61297222f773
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 97736fbc3efd47ca9b2781c796c21ce7
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# c11d9a349ca94596844984c1acd1cfe4
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 4a48dbf7de9b4b1c90e6f5042bfa2634
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 3fc58456bdb74fbc94ffb1e0e3e48a1c
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 0634b0b2c23f47b783bae89cdb6e3c2a
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 14369e910c3f44eabec8430aaf114c81
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# c86131ef4a1340c08c606dc5f1c437fa
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 3168122d1b95425fbd4950c49cbba60d
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 3976ffa993394ed18ba892ad2c6fce11
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 8ac76ee3387240319eceaff2be53032f
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 137e5882b42546129e9ecafc2ece65f1
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 474d4cd3baaf40fca03712df31dd7579
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 423cd6e5e2554ce894ed22fdad7db4f7
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# d2f5dee79a8a486c8e86e856c73098a3
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 4efa8a96c2654e35a59c57045c677ec0
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# 4cbaec19749e40bd9614c0c068b10a2a
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# d1ee7769be8a4b83b41db661a4e61676
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 88fc709ee6bb4dbcb55b79c693f8910d
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# a3af5284d96148e3805e46db6cf9aa3c
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 0fa439b95841465582614210cf142df2
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 7e3eb5c281f9403bb43447ed1cb2c371
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 4f57be029564424490bc9984da7e779f
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 5673c58b8f254406bda7aa1ef6bcdee2
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 0746a93ecc324c5e9d4942c5eb0c993c
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 2364e6d642674cf58729c2b3e2d4576b
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 15d302adbed5426dbcbba6922d504f6f
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 5d7acd23ce744f9187ee9fa7937d34aa
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 54b15073adc74ef38067e2e7be46c91c
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# b27e01f8a38848f0ab422f964abe417d
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 989360e2e0c943708e8d8a4cb64e3d9f
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 23910f4a4985464f8a9b1583d5f186df
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 632a1ed86f2644bd9a8a4ed907a4ca18
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 53b2bbe7682c4fcba3f5719ee4ccf313
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 7e46215e599f41c292988763e621f158
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# d20e69b3b9e9461c87bb3dbbba69d482
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 31df892ce2ca4a9292c9443810873bc4
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 6c2d2885a2374c0484d4d7f3041f5e08
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 10c36b27b8d44609975cb2a209ccd597
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# c0981822738046199d4da85603a2eec9
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# 1b309621323d41d495b4ec31dc51804f
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# d932cdd801944edd870ddaa96afda9f4
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# 8275cfaacd484961b6391a2316119a27
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 7b6b6d11ad614a1588cc43d381a5ecc9
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# dc99c371e4aa494bad7caec603f34bb9
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# 19c68014c009476a9976b7b6a0902010
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 5b3c2b8005d14ed480071e0b37fb010c
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 80fa30ac9e984c1493b02e3d97113691
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 5cda9c85d8d14a47a7e63e3518fffb70
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# d3ca51e3eaeb455bac60c1e4e09acb79
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# a47fef0b0ac349e9851944079d4855f5
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# f9f38d3f8c37428aaa713d2ba1dbf830
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# c24ba488d16e4f218c15e05d03f9290f
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 8854b99d759142e5a39bb212e121fdde
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# d16721b262af4d998bf15f77118c4c19
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 9803c98e91ba41e4be3616fe90e539c5
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# 5ea5cc0b37604b04b9df5ed95e1f94b8
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# d08cd92e811a499fac15c55caa8cc784
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 2dd684fd50d2422c8d97090f30fd4d13
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 177630620bee492e8485f669a1b5c2ce
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 717122e6095348a2b39504d244f7e5c3
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# d4e765c1558644af931a7d8fa2994a97
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 7bb0b38d261041f899814d5adb4f70bd
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 92c5e7f32150493eab03e9b3d233241e
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 847f9ead2f5142e78fc8beaa6ac09986
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# f28c26eab62543c1be9406300d61791e
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# d8c0f174bd454123a15ce2404633f75e
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# d62b234e84be496289744117ef8b5587
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 1788653349db4078bcf8063205a01484
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 16244341fc9342ef865f1ffb4bd853eb
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 4d5069165ffb419d9e2f2046563a686b
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# d0d22e6fcc354165804d48b1c3165cbc
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 13155af44fee4a2aad7d1faf287dd127
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 12c4f3f80d654b2d859fa39ccc6596e5
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# eb12fa0e9fbf4e3bafac0cb35e428da3
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# f67427fca76e4fad85a7e59313c00e22
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 2da76513e6344892b2652396db900b58
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 9a7041cc93be4f9e82ab0996404e5ef7
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 2d7c696a9186442b99e9f9f6e3f08dc2
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 5bce172258344a7eb3ffe8c2f728cff6
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 8a89760e594149cb91c6f0731d9294ae
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 7980c58e772744b496e8ed54e7a35cef
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# a4792f723bba4187a472e523a0b19554
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# adcd1dddfdc945399af09ded2c2a5c41
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# d987aac84ba5484b9e43e548dedb1750
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# 8a2c6ff98a234daca8346b53c89cfb0b
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 43fa9910f7a74663a8d227c3056f2e3d
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 736b89bc5ec64d658e138d87a0b26f6e
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# dab45ec3e9b64f949beda8d623560b48
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 7329120e6abf420ba8df6352c3fc19e4
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# fe860b0c67de4142a7908d151090e5a1
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# a568232ef73d4574b0c8571b5f325167
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# d9b70176c6e4406b956a08536d2cf6ab
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 8a4968178329447186166575066f8e3b
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 91c2f54e91e5425993e44b2aeca42047
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# b7ff84139d1f46fda2e968fe21998e0b
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 6b69ef1009f048ddb73f809657569686
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 5c19093c57c7487bb34092bc55163c4b
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 1458953468be455e850324b91bb7ca22
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 075b7b4afc0844f58e4f823f1eaabcbf
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# b176be686c6240eda232e9afa60cf8f2
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# 73b9f221dc314badae997e026442aa1b
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# c10df0b5f13143798e9239242f0f7471
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# b5f2f4322f6046068423131289e320aa
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 2305baaaab7c47d1a33bb325f1310603
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# d710469772954b74bc437e6c30e22b11
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 10cd17ccb75441a2bde008ef7935d482
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 51f3749a04794717a9f580d3668447f6
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# e8f2e36573f141caa665891a3ded807f
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 82ef6d894490463b93f4d4c5fb61ec7c
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 4cbcc880e83e4fa6b2cd27740c5cf34f
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# e58d0b666de64228b02c6339ee0d0125
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# d831a613c0d5465eac91485854b54714
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# e3ee933413654d1abb94b80e7a9bf430
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# b92e9665d7934012bd38c4685216f214
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# cf709259747949d3b0b40861c5b73b88
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 9f9ce0560a4b49239dd349800a77b15c
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# aeb6bc6f98c84b268026522b2b9486e5
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 2f752f9b301c4b85a2fcbfe9573c0f6a
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# f0564662c5634f7888a4d9f1a204eef5
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 684af2ca32e84112b63917bb9a9f30c4
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# a9d67c79372640d78f5a1b11b7a36327
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# e7dc7432b81343f3b2154ca5c2cb4354
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# a75d294ac1ae44a2a0e1099013ab93f0
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 688cb00d891849a8876d986f4a27cbc6
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 0c238277b3d142049a60bc23ecd8db33
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 263853851f9542af9a91fcbbd5755990
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 62b1f1add732434faeb809a313af30a6
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 48771d51b73d4362a152ef9ca1c45051
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 8395415a143243fb890ddcafb22e7e26
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 78b9f48f5a3b4cec8aa699c9c3aae423
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 3fe8e0fdc5854551bb1cee775ae9b41a
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 2844461219394b9b8da25cc9128d9e1d
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# b59eb802707a44d5a4a17d090265142d
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# e5a53bd449e94f31a4910274a7b1a10f
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# c1c2800869f1453ca0d2b45e926de945
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 132c6f8ad0a94c81a7fb243f7db7bcde
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# cdb4943514984cd690f6e479a1db35fa
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 239cb063d0fd482282fb4d3afccc662b
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# c2931f5069d24f209f517126ef3c7838
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 6f2ffcca7c4f4294856dce16e025a3a8
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# 1e4b1284b5074ceca54cd03800bab6bd
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# ee74ff3caf1a4787a5fb1923d951679f
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# c8645f9ec0874e09b5dd18b5ea29e53e
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# c64af96c1aee4e9c85e55f67d26fc40f
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 83f7df27503f40afa38a545e80f70083
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# 94f75cff1ff9428897a2f0e39ccb1af1
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 76f55e100e024a2f850b9eb84257b033
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 5be87f509cee4511a4fd903169e8f0ee
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 01e85f2169a843afb72976185c9a8238
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 6af11c05a5d9477d8a4323b0efb7c72c
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 98c117c6476d416996078ac3faf51186
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 5193b025be8b432b8cb5e50ab9c14ee3
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# ce3837546252471db59894111518c27b
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# c0a296d310e649208f8218c21f5b591e
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# a24d6b090f9b4f65866bac855bc81cbb
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 29fcd018c9cf4fc591d8f3f8a87babfa
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# e27c9353ac704f06a96472bff4db7dd5
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 0ed864b8ce8a46098092705951847d31
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 7f7cc6cc25bb41d5858aae9d271827ef
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# e527d31ca79b4dd68bbdd0d45eea16ad
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 9f38715477544446a4003c2aeb52a589
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# b26320b0cd954904b0b8a5767a25ccb8
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# fffa8a3ccbfe44bea525410b4f22ac9c
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 537ebe5f237849aba0e2cb45cc3e7d5f
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 8656a59a031a4aaa9cdbabc84eccc500
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 2b5035548a6a412dbc3b3ea6182f560a
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 34e2a43bc3124ccdab3c821f025e3618
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 53159a54b1e84d6a857042df275ea5ed
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 4c34f12cb66544cba82f395450ae73da
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 8e5d423434d040dfa9dd9b27faeab688
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 38836a5358834c1d9738a18e95d89ab7
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 67bbcb37588b458cb42867d67d31d0b5
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 088631e1987144dabf5af4f1732bc0b0
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 67ccc437568d49d7bad4dc38fe2fce33
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# b7e490fb44754edd9c880751556e6334
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 1a9e736c90ac44dfb4569f2f9a0f3b07
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 3b2648d1e0204d85bc1545161bda59be
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# bcc455883e3f40c183aab9d1e5305910
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 7b9e3b54a375430596080b6c36938b6c
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 8f604485d72646e8a51c86e2d57168e4
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 818d47eba4bb4b4a88768ef6702b5d2b
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# fe810bfa4f184e00a3e95e67d987604e
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# a4892ae17b494849b37874390707ba8a
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 877c167a1288415a95c8698bd1e07c26
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 815d282f26c64cc6b6ecb9f5b0e58281
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# 485691fb1b274a87ab88bd6f60b42cdf
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# a7c850f2ce854304b36b4133db34c784
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# a8b299101a044a408528747d5515d685
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 407235e912ba47bdade47ecefbabbda7
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 5ce01b49c22f459ca63ca5f0c38ab4b4
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 503b16fa4655493fb6f76ba2d6406800
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 24e3570ab3b04daa9bb671e78ed4b0af
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 12bca7dca1a847a8963eb464e9a1e98a
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# fddefecda2ba46d58de11b5091e86978
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# d30d66fdbd77443282f62998d3aa5d4e
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 074ad33ea80a4ed2b2b4c76cd9614ffb
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# fe5860c420f246fd9fcc30d573789ab0
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 568ff886a11a422a927a7d88763e0121
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# f8e250feab3e4cfe862b042cf260fdf8
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 9893e4a120ad492ebcacb51b3073b5c0
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 32af0b97457f4c9da9c857158a82fe50
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# b8530172a6d74c26b7a7b9113e30cee8
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# c277a15075004950866435939a64d95c
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 74e491a076b841fe9502713c914b314b
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# f9a18a79bce84a19b79d53390cbb1986
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# cb92df9e2d8140eb809d2ee5fdfe0911
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# e59648cab81a4fb8ab50b8acddf96a7d
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 18ac57929ff144fea84620675ef06fbd
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 18b2a47fc21444459afb5139d432a893
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# d2279fa3eaa14106a5e6dc723cf260f5
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 3a6be62435fe43c299c53511cd98ae94
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# a5e0edca285a4639ba5fddbfa66636c0
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 67800175a68143f6843e818669521035
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# ee3c1d2014254aed81577012c4b92cb6
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 76cd07167f1f4c529d0c8e10d7daa597
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 9088f39e2e934c348cf613e6a5888c73
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 14f4bc887e9348da8548bb29b1ef4785
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 77bab01d19934a8c802d9854dd522888
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 44bdc94f129442bc84b45a1e8df8438d
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 6f736e0469d04935afd18ff833783e81
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 309dec6b0dab4167ae273b78bf0786c1
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 1300e67c715f4aa392825015478a15ba
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 4969ce4323f64965bfcacabe7e228a63
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 11a7120f5bbe40ca8b212defa4be382b
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# cc9f381cd58c4fa0b7c60a36f512678e
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# fb9a86c36b054c89981b9fe3ed0df7d6
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 022bff878b884b94af42967aa9810b4a
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 806622fed86049648562cc245f686c11
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 5cbd59670d8445dba0e2d5484fe61003
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 7603ea59a7f54a3992a7d0cbdef7bf3b
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 4fde66a3c721424dbd5f2a76a3989780
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 96daf92b208e4b01978b1949cbd256e4
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 350ddb7951d047948af59e8f986ea86d
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 6226f4db896a40658d262b7cad85e098
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# bb6802df5d3f46ad8687b56a1799222f
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 56d1e4fbda8741c2ace1227c0de7f40d
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# e5e9bc70026443e8ba06aeed14e944d7
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# b6c12c437dd84d0ca73998934a934a88
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# 47e729dfca9d4b8cb444a2f929fe2f88
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 08479e467ac945d289271e40ca1a17d1
# 9a992edce5714d91a46bf0c89e2c2642
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 51340d3394c74fdcbb025a1904a424e5
# d66a6211084a4fad805850a9a3c1c692
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# d7332e2e5b434bff826d26e89f05146e
# 69f45fc6cc6749558e798dca63e81aa1
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# b746935f05604b37a29cdbc07b96dcaa
# b73e3cfe97b64d98af5be02f2b28a43c
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 066bef90582747f2b214f2c60f8565dd
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# dbb7c417202b4982b9d52c141767e850
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 1a4dfa420ed349118496d7306dd92faa
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 2bd2bb694bd549c8b0bdb600229b31b0
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# f7840f7c9ec24710accae5cee542cf03
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 7a7b098a40814670939958ff76bd8341
# b9839092add041a0a8cceb82b5c347a6
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# dacba4d1af1f450e80ac834993bf9a57
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# ae5194e972b74419abc93fb552c0cb4d
# 31a5a77818894e74962f96a287291919
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 61e9306a55004f469b25d4ac6ca72eb0
# e1e72879347e47769d5688033c04e23b
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# ec965ac1626649ea82c87f1f053edef6
# b4d3d284ae9a405da6918b2ddfd65929
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# be2fae6a1253422299858fc5ede05c3a
# 2dffd538d08b46ad93840f77dfcdb7d2
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 20cb73ca39bb4debb932c6487c49bd76
# ca47854822d74c5d9c9778f5e055daf4
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 70e35b4cf4884943b646ed50a5e48d66
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 97eb541271d54a72ae9d7c05545c3252
# 1a48aaf4d94e4d5094c740b960918ba5
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# ee79ad0773514fdf854f402ecd47897b
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 127a2702215149f79f999e121dc47354
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 7c9963f6bb1e410a9e196798f06c59b5
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 933b958bf16844818b61bebb79dc60c2
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 6b02748ba4e144afa025fc9026fe44a5
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# a229d5e9965945b483763b92926a2ff2
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 684bd5b707c64ff78acd9319483c576d
# 0bf2007ca6564eb6858ca468ea91cfd9
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# c552d9551c444446afd95a2695cd7d09
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# b8116baf3729499fb1de0f8bb0b131ad
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# 239b132022e24033a0dabac9b1fe9d30
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# cccd6952115b489c955886b7a269b410
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 956fe98c92a0427192a9cf3fc0b348e8
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 7b0b3b09ddc14d17b482d25d5b1ba4a0
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 316fd04988264e8fbfe0e83d6384b0b3
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# aa53635c435d4bdbb97508c9c54c9a06
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# 9fc433397a4f4272a824abdf2db250bf
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 44a380ab9c804ec1a89b5613dabc4220
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 1cf78484d9f1459b970375e912dd6ce1
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 4d0bc9e6d4504b6cbe8c458316e3c1a0
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# d14a5c13edc14a389a23513306cf07f8
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 914951d5d0124827b3e53e4c49bd3f0d
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 1a655a1453714c1e91948f26d939df11
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# e8f9f2318ba04961b5e16ddb02647bd0
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 1de17ce856c84a219e00543da99bc3b8
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 62f6f811f6204f6ba1471d98cfca2fc0
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# ea38982c468f4789a150f1d8505f454d
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# a785b0c125ef4e62a90d7c8ac32c6159
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# af14c564f22649a3b8b4e155ad50c9d8
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 3208b6f8e271464c829c0563d82d750e
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# c367798f18384454b92e32bce2d47530
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# ddd9d2c8de3c456696062b54f3d14352
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# acf746f149b54439bb3fc9f713c58b0d
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 69422345f86247d283a737c8fc6b557c
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 32a3bca4943b45689f1e3a69c074227f
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# a4b6709d2a9d4b43bca69da1fef275b9
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 9c8038f22c0045ceb0a30489fa0a3bb9
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 75cb7bb7d24443ea8cdd634e1fbdc796
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# b798ec35331747a28d42050ba5e4de6f
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 972cc17ed40f43df9398f969d2a45fb8
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# c64f519d76614934892bfb22f7b05549
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 1d530a07653a44b1b4ef993c06e050cc
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# cdb71766e5d5423ba8c8d32e0efa5ed0
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# ced44592212049b0a31f5265ea25efbd
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 6a90e951eb9d4121b8e70eb5e98984b6
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# 179fa3f8c66e49c18f1ec44cfcd2bfbf
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# bd4f91a4083e42ef8a5b64635c6c4da7
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# f46062d4d3744c12aa7909f65e4604cd
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 1633b72ed923463dab50e3c4b52fe2b4
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 7bf3eb07cc224b9aa99267bbcef8dc87
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 63b86e9f20ba4fd0b7eda1612ce1f39f
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# e48369b958344c90a5e8380c7fc00b68
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 82eeb0aa0e0d4435889b15e5abdab626
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# c30bbc698d3a41c686d1eb5c82904523
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# bce55b21499945e2acaaa53125b296de
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

