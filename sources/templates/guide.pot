# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-14 18:18\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 3be73a2fffd34ceb83ca4f5a4f3fa487
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# b90308aff844419eacd860b6179fe299
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# d77774ffdba64f8d9d394534dc1c92b2
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 92aaa8fc572348debbcdef25805beca2
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 3fa84f96403b40dc8402ac3af5e91b9c
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# 74c4cf63cf734c47846393a708a4423f
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# 916469cf0824420e8a4d397742e8aa5e
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 8ffe0a276d224848a26288bb55674b60
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 7b422191979341289cf8a3d5fa959e2b
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 912da4467c584aafaf9c59f62ae9c12e
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 91f64f49541d4d4da09fd6e3baf04a98
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# 3563375dfc5d4bb89b9faa7d201a3cfd
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# 26aebeb8fddd43bb898c073b530ac7c3
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 9782db9519974cabb2af7b6c2c2fe57d
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 9ed23e367f394f899e1869f58feda7bb
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 9793024c77c04dac94158f0e881dd688
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# b8b9ef2147fa411193957c9fd5062f58
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# af29a21eb9e146ffb7eab974e472174f
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# 63775f601b234619aa56917fd6eaaa0a
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 48e4c9fc7b1a419a919957001c648a9c
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 00e5c6beac7d4f28b46df24f74f6194c
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# fb0f56b4d34448b1a26bb52d9a2a5805
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# c29f14a66f17447a803431425c4d12b8
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# ef43245e3aba458b8f70031ecfd39adf
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 7919788cba25494abd63c225a64b8f76
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# c9c5ea8a42464e77bf437fb886371a28
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# a29ccdec6c854b23a9ddcb316746a404
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# 44a3740e92ba461695eb3e69432d1a3e
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# 1e3b4df0cd29403e9aa16189b32ee6e8
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# 59f06c287caf463f897ed2bbf356506e
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 265a3fa5ac7a4fe6a5d401e12d068a38
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 7f4898adbe534e92b9a76c3a282a1720
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# ae9350d1f715485192395d4b9dc6c5bd
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# c661f2f980ce4a7eb04ce94bd794512b
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# c9523fb6bbb44de3b2a700e285ab119f
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# ee629afd0a6f4bab8be643841ddb195a
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# a26757a8f0a54a8e937d16504aa29461
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# 260e6c9bd20f4986b2e74154b736e5c7
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 9d0921f06e404dd7b3636aeccd386d29
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 4dd4c0b4391c4e7f8537fef419ace3e9
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 187956e9059540dea0ccbd0fa5eb3348
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 7a228e41437b4a7bb6e033e7b54b1763
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# ef2d0cf19a9946a4bcad254658716097
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 0d0022ca916e40df9ceed15b1625b723
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 9d2d96c0d07d426dacab81938d73016b
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# e9e32d6f233f4ae0bf59b2c465e98f66
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# bbd183a32eb64845980f489b44c9d881
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 590ba0e73d3546daa9df9eb34e476ca1
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# eff38f62ef2140a98e64c35b2681a308
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# d68532b6c5c0448c951787611cb72b14
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 633a26e83ae54618a487497e92de99db
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# b396e9d44a854b1380ee8714254fbb14
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 41fda22732e1456981cc0e44176bc2d0
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 23fbf5f786094cd5af532c65c813caef
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# 24018f5df4c94754b64fc5964aba5a51
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 455c0aa03d114da19ea6df00e645ed35
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# adbde2a2dce74d00a62656ca4b69f8f6
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 4385354783fe4c0ba7b8b414c7cb7c10
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 82a0a8c880b241bfa871c3abc60d457b
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 0a69cdf345e04f1d9394be514474ad90
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 2bcf9cfa4ec24ee0b10952aa2b0f7cd6
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 96bdb3b6a90c4504b8a44f369d903f0d
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# 3bfdb3b33b014a108ec9a72e16058e40
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 8ffbdd64e14a434e841a307a371617ce
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 66a4a06bb1ae4086b2bf844b1882ee35
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 4b62c2517239428a84b70459dc3f3f2c
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 3ae93d0adf6e44ccaf242f88eb7dc560
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# b26d80f6a22d4a94a9faf6c6998e67e7
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# ed39fad54adf4e91ba85d09b857afdd2
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 6b432393411d4e20a22610bff586a07e
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 65e9ad5823ea44b5b9800ba83f299d0b
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 42792c2e8a6649ec88690d5512a900f0
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 9b16d48048fe4fc2a5d360dd1cc0f17b
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# c4a89050696b47e682548bfe352c263e
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# f93af2bd4c7c4ef28b817a1595e058ad
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# ab0686e7aaa24bf5a0641cbab036d8bf
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# be3dbaea881348c59f92833761741c31
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 8273fd38beee4bdeaf40eaf64f4616af
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 2947b96616854d658859aab9f7ba4574
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# f952e5fc2f1b4bc0aa40371c4042acdd
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 385f4cbc55d3473686b6c94398caadbd
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 90d59bf6a1934fd19372f70c9cc9786b
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 2b76eb2b5d1540ef87e1e75717ce74b9
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 65d7382fd9e04432b93214029878fe96
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 067e79793c284238887ff069d0a6ca80
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# c7b1dc787bcd49c5976d210773969fb3
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 9a96d9b21f8441cb9e5e97a39620c3f0
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# dfc7ae7e07df471d836c089abd6af076
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# e518c896071b43a9a90ae1817ad03a50
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 3bf4e25b027f40319199aaf37dfaaffd
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# 15133be963314dbdaff186f0691b6927
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 755ab0ce7efe4063a7c49d84f4ff2bb3
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 8640fc671d794a5c9cc0f40821379ef5
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 30b7c409413948918f50b1f0f919d08e
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 213d32162a0a4b0fa97de2d2c7bc41e6
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# e47563b55d8b4828a3cca8648ba3dd8b
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# b246966c3f9d4627ab9f60c87827ff4b
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 6bcaac8874c24ce0a48ecbf2bf571eaa
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# f31346a577e9457d806d0a75bebbdee0
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# ae81afa69ead49899adc76743f31a876
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 2b1331d367cb47dfa93c483238a52f37
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# e262b6d3243b45d4bf3dc06edc386fc2
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# ba0ef09e3dfc48df8f6028bfd0f62c90
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# f313312c44fb455ab6aee05401c21043
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# bcdec9ee25c5456ea446689433dba18a
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 7d8151ede6694657ace7c6ad3b2b9fc6
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# fac2e15a75d14616b207a23039ffb065
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# dc81a27613764d8ba9d287e09c4ce9de
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 3332051274bf40c3a3c0dfcff6674d69
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 68e08b062aea4447827c2aa1b8d4796d
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# b4c5b77b96914f3ab8e65059f12a962e
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 3ef1e11c58d141ef889a78ada6a09159
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 07ce0a43fc9a43eab425f8dbdd95af3d
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 004682ab360e4fd58cb1fa923d5fc074
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# cc5d2b11f4984e5f8e9216a6d644c012
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 6112ab1a05664afc83071e608dd8c1fe
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# a5710871c5c34da8bcf29e8a94ab0f0d
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 6d060b9768a6496d93ef674e4b5f2f72
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# a811b57b7b4a49049707a95f5d4c268a
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# b474696be472497b816f940cf3b5aa11
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# adbda7480bef4c0ea04d8e738a6263de
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# b6abaf9927ce49b9aa69d63277bc25d3
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 86e853c3e477475fbbacc4adf54edee7
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 792c0b3c2ea84728a04e4bd6e73b1e64
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 2434b93e10cb48c4980452d8e77cb0aa
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 4ad66c32083f4b2787ca650a401360e7
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# 4c8f60b8dc3c40bd872857db5752743f
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# d5a70c3033ed4403a977f2577ccb90e5
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# dc22c4650dc642229e187b3f73cf9f08
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# e7633a8fde584cc88af1c216e6d70de1
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# d0b66120909a4b0d944ae95293da1d25
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 468414378c9d44be8b12311b9197b658
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 6b9317769c1248078c2ecbcd3fd3d9ad
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# c2ffb6eb1f9648d99e49f2da4d94f47d
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# d56942f2cef14419af09d12744fcee2e
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 49a9be5860b54567a22116c9d93e5382
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# cbfce4a7e4274e8691f7dbee9759af64
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 1ddba4dc3f184c359b5b583f6a27386c
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 747b07153a00441ab0354006413603dc
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 3ff64c81b8564d929c34a8f3b2c889e8
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 25c4877102514d889a942be31fed2492
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# a7d0af25896e4ef6959e2d21d9643307
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 4c3f08d53014478e99a4486a2c731487
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# c47946c43f214f83aa82a7213d31975a
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# a8d5ce7608464f05a9f10486d1a2d123
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 70a9c1817443473da871caf123047571
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 27c8d6e01fbd4a6bbaf2df697cc63910
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# ef5b0e4947a84b1eaa82618b7128bc42
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# ffd0bbc0b42849af93606c96a993bddc
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# bb7488e63a3343c8803e667403c57a16
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 3009176e07f245a6acea97b447e09f97
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 12c8db4adea24806bfb2e66cafbc22af
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 4eea87d85ad5439d802eb7ca61c9dcde
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 7e8e399d4aae42b8a974918e9bac50e9
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# b738033bea0e4275b44fede8205668f0
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 438dfbb0a80146248d1487929dad8921
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# 2065b66c72914b2bbbc96fca58221f10
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 90e674252547434ebf3cac1db3981d8b
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 1da231fddbf348369f9dc6d27b5bbdff
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# 090f8920049a4b7cbe040e48eeeaed0a
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# cbe6a4b4993c4ad7b0cc3463618e4ea8
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 16d576dc75ff4105a726def013ba714d
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 9e6a6fbc165044a5be5daf457f4b78cd
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 622e6037319b4ec79feb59439568d523
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 3c9bc2bbbb3743ab833e40859fc31aa4
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# fee59967ced74d6cabe088a9a2465cb9
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 6b2a14d535d543ab9d9d0b9c65b5b8bc
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 5b05ad98062a49ac958a91392092cb4e
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 5f62478f1a854a91af133db7223054d8
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 3eb47393a8ad4a4eb303d8459a504cab
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# ca361bd021a648219669706b717e178c
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 4e69653bd4064ad3b80ea4e8b26f0323
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 73f88e52d82f47f3ad309c56f3b4ea0e
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 22c56a2aa80f4e1581673dcb84bdda70
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 0aa0fbe15a694912b12d7b4e6c31299e
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# cb6f9c91917a46e2a0eecdab0e55e442
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 0f2b1d4af1d9448e976cdf2fa515124f
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 54a1959a447d46cf9d5dd7ddf92f889a
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# a92734151d0941d79ed0f534a6bf7f5c
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 3e5872fb7cb44eac92200cccffd415d1
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 238eb925828b44fc98572e02b4907a26
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 72b927698c944cb4ab460612a8a85ba9
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# a30f188aab014fad83b9ff5b572864a0
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 60e8b84f08e04f11be28798c6aecf8da
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# e6b8617727cd4360b8708c52b0316ae9
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# a2fc5112fc4646fab4dc79fb1b285de3
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# d5710b26fed44687a27dfa6c0a6ea246
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 4ba2d81bb3d6428c925f1b93c6a9580e
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 94d942b01a504085bde65916d535a1e7
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# e0e5c4f1b1174a56a81a278be0dbba49
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 7b2283ff509b4519ad3a919970d67dea
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# fe0dc0adadc04d24b9be432453dc75be
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 055410c5ecf445289008f46d0b6827aa
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# d4ddeb9f24d44101a7c2b5b2eda3f7b9
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 2cf6ef1a58ed47c192d89ee9c9f6da8c
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 7261175e594e45d792e1ac611b6f46b6
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 356e000babb34d8aa82a17369dbdcc19
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 7e9712397ccf42f9b0b16cb18846e8f1
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# d3e8398cd40c47c798a8d990f9c0429d
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 379e7fb284174551b70b10dcdf19e7d4
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 41715edcfc524eba8e439c2d7288b65b
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# c68292a1a23346359eacd9f03a97d57a
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 72ccdba618e349c18f8ddba7ba63b752
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# b0cdc407c8c24ddaafafdd8922e4f3af
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 3ac943acfb3b46cb838793eacac927db
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# fe914baa66a04c98be6458396087eab8
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 00a26541c30a49ab8684390a58634185
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 6c4d6760099748beba354cbc405cbc63
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 46c605d0687948b3afeb806551f49d6e
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# cbd6148eb577486ab4b4dd34064d8824
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# a90517a672a54f2ba3a501eaeb5f4488
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 8687bb2d5a0b4ae19db08cd4531708e2
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 030a8822ec364af3a83610a62090d0f2
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# d8c9107edc8847558f511e7d2260fc0f
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 7391eeb1c6974555903fa5e8af19afd9
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# 6f1f69c371eb4228b2120df7ce1d3c98
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 35fcacb5038b4be395b3fb603cf9f586
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 14bbe324562145689862bcf61b25615e
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 4017a15de195473cb7f43a2a16dbf966
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 947f7584db4c4b14887f37a69e5138bc
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# 8a14c7bc6aeb47b4b3714fb758b10563
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# b24f4a22d5374dac9e989bb11f593057
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 5d0c5a6f96fb49589bc2eb93eeca7528
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# dc02fadc96be4fa9b5420195c269f40b
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 6efee6f1dccd46bdbeb2c2d6bdffa271
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 4e87fea792834587a44421bd54b6bfcd
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 49a4c1d87f284f03818b8f52d0ad5c19
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 63ce996f5c094535bdab1a2d3b8b9f06
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# 5a18c8bc93cb4311a0128871a1a6bde0
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# fe57b05614aa425388086c479317b977
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# f98347d60d1d426781ef03a48d0cb40b
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# bf5393e23ee2440dad365bb5b25808ae
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# e01717f0d07f45588011baccd8799ab2
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 5c478594ad174272b12c516e59dfa42a
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# adcea749f0394abca7c22a8c7c849811
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 4259789f455444b7a65e465ab842bfcd
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# ca0e6dbf6880494aa331389ea567e98d
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 311b9db175d341e295dee2d240e3e121
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# d8ee4b0249da465fb2cbccdabbfbb9cf
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 79d9479c3a8e40939db7aafadf81c4e7
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# c1c01c3820e54068b83ee6bdeeef1167
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# ab1fb7fea50c4fa2a55416a10c7a02fa
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 58ec450d13c84930834773da2cd875da
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 976e343505b6419a924fc99de354ef6b
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 1265a927faa1422292a31637a894e504
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# d75369c4d0da42b2896934034bc574f8
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 2d4ab161c4dc4a2894da117f6c9d8e03
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 244e3c7f7ef7488e8ceec0dcd2e56aba
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# fd65a10724d74e95bae0e7282d31a33a
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# 590bd0555d26465c92ecd5bef2d78a81
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# bc153584900a4c36b7971537bf9f6bfb
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 3fab3b9b194541429f8821c8a566317d
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# ebaf0680fd5f40e79cf591fb66ce9aa0
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 407652657e4549638017f6132e5538af
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 9aa94388f19845bba50fd6ad7279b857
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# a882e29e12ba401c9addcce213c6f99f
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# db75fb1c7cce47549ac8c26f6fb1d397
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# 1583a8c1531f4ab3945bcc150320b4d7
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# dcd8048d121343188ae49377f88d70ed
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# f743c735dcc0498992251c1099288782
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# 2ca04b56a7ea4544997c6e5a9fc52ae6
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 94cc42e1619a4f089b5e68e92b720017
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 0e41f288c0264f4d8e8d339110b470c6
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 717cd2bc87f3497cba0721ad5474c725
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 0c59c3bb3a5b44088a8e05105b2ecc47
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 80cdc706da9b4a029218a02d96626385
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 060ef55b0b244f8f93abea2c787d7e22
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# f01fbf147744459d9512b608ca2c8a23
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# e693cb4ef82946f89712e8144a7f2686
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# fe40994e940e42bf91270a5113452f59
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 7ce3eccd85cb46d6810da5b5e71d9289
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# 29f37f918f054c8d858e68b14f69819c
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 58a0f99a6eb24c1a885b7da1f73d50cb
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# b2b1700684f94f0aa9062c6fdb1458ff
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 3ca2413c09814d4f9a5d6274d1a7a515
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 08ef2c87b382463598adbd211921fae2
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 34b502a3d90c471781ff4031cbc6e10e
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 45ce60d2ecf24e469e6fc156b47f528c
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 291d728a19414c8890c16124c1a51239
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# 4c1ad9360d3b41c69157b5569e6fb051
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# 65bb35d7bd834a4cb9bc9d82b16ec261
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# d93c9be2fb9045319737f9aed070ece6
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 3a5c250fe4cc48e9930a6b6e51042fc5
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 51da94a5227343a9807dee4cdee705d8
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 99f941cc161f49ecbff7ce06d0419864
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# dba53666d77c4c0eb0826cb2b518fe61
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 855d72e5d09f4806a55e3d9c532b4fa1
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 7bb844c215684ca0bf524e43e9258d9e
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# d2721c8cd0ce48a9863303fbce392f69
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# f8a596be946c4dd997ec8b15a85ec1b2
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 3cdcd465ba1c4d22802721220a5e07c4
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# dc0cc215733e42b5b8da92bce08872d8
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 06addf8401e046db8fa93836a0d4fcf1
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 387c69a7442d4114b7af817af6cf9336
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 85e36d6e7d804c77a5e6097b60b64073
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 9f3631fc2b464fcda2f6e08a51b3909b
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# fa3b9c2f1c024739b5590db2e628d491
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 7a10466eb4d442c093832adc0d01a26e
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 24026b5343f54606b3cecfddfb15082a
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 407e087d2ff74e99b4137c4e40ab91b3
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 9590a9899e0f4e73ae3ffec0da155f9c
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 4e9b22fc7e2e4ea88c72e0172f8431a5
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 1310a6343a914d858a74636f1de0aeee
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 3ccfd249f1554d36840ddb3bd4a7f9d8
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 8ba41f357465492584a471939324f55a
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 99ff09fca0e6439685d7d2844e844191
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# fe9a5d5d12514fec885bf3b819dad2cf
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 8424ba5dc2e042ebbe9ad84ed3bce80f
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# a4a2858636dd4bcab60d67c38fec2620
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# c6b72ba86fe44091b499f7b09151ce06
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# 52a2063f47d841f19ab3edd9ed2f16c9
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# a9978c03e50b446ebfd67812c2a06885
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# a71ce502a3ea4674b47a37fa3bf21f8f
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# 2bdfa0042cf14d509255fc467bcfee9a
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# adf132ee6b4b457786c445577f83fac7
# ea066f8568ca4a8c97af6f6ce6715ed7
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# d42fc14c460547a9a59fb720f3c12f81
# 1c9d1aa014374586ba43d8611f6b7b1f
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# b65df6fc87e645d88ea36277da12209a
# 2a759c510cb34d1cab600b99a877ce09
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# f552b31b498841b095d877993fdb49c4
# 1b4ce2458af14b85bc2d69b499d68bf4
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# a6a168a366fd44779b9ae48b4550bbce
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# aab4de0bcfea4b4087977d5091f728aa
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# a48c7d03f704408082dd5dee01e56cb8
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 7db2eed43e6b416e98dd17951e871a33
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 4e097c67f476449abc39f42c8f3c4b99
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 5554fdd26ec949f78979ea1ee767d881
# 3e86ae6eb38e489da1bba2ad06ddd7d0
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# 8c0a3756dbfc4b52aa38167bce92cbb8
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# e5d6578a213249368d273e819dd0c248
# 3f000e88b17e4846a5c01bce3e96b8a0
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 9d3fec7381a247bb95cad16a8cfc4d05
# 3117d028911a4862baaaffbb535130ae
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 86da23983998464986eb7f774708e0d2
# 89d167981963468a834d5301b4a3588b
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# ad58d8bcfbe74a17bfc64c1f9ca59666
# c8047920fa1a46718eda09679b30a581
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 989c6dcdea44499e9da7cd83c393fa07
# 8d0d479126154343b1803c1bd554d809
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 57863e00575640b48840a67785a3b4d4
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 7fc1d540666e48bfbb644d84ce31d1a5
# 729242be12a748e395536b12b3da4ced
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 52d94894618a409d861353e7b606801a
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 13ad33c2e77c4d59936933ad9ff203e7
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 27b3d11c44bf42878037b1612abe832b
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# fb58bb3000844f798c7f13cbaddc81d9
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 30cad23964894dd0a84f187928e56837
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 6bc5034c5649404db74ecb366e1acc07
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 2107f39060d945719f738d88e1d32894
# 45fafa22e310443a8677a551c6dfd617
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 6322c9c1eb494aad9b916afc4c3e5ed5
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 3615f12b918945fca5a216b89854c436
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# 75cdfb70efc547e189954aa519b430a9
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# 24e172d1d4b441cfb1bf171fa2e41bd7
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 2580280f7b9348f99cce3888017a40d6
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 75e8dd09a1da41a7bb666155c24545ea
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 7c877da8b55f46cbb7f2d1a9c82d3089
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 972765b79c5b40e0826ed381982ed906
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# d71b385500f347dc9b60ee3192834205
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# a7061f0ee6cd42089759dbb890c96a71
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 9c20f8c00f8742e48f2ecf16013493b6
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 379b5f70217b4f8c9a1f42a39980d342
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 0facba1f08a44697bc6bc355886abecb
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 3948108f8b914d8690e0edce5bdb23f8
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 03f086f2d01b41f5b2b90b918e5843ba
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# f2a598ecd77948f2910c64b9889fa937
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# cfe9127e14d74f329e06af826fd16b0a
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# e4e2e2b849aa432ebaba8aa687a111d1
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 5ea1003d5a4c4099ab26f1633ddabfab
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# d639b37fb2bb44199760f7f94567f1b3
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# c1c1fe5dc48a4fab8c23c5e66d4f5b9a
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# c3b7a6e265474301972c79911124a6fb
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# f6c0b941cce342e598f7f570ba3292ae
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# e9ed09e31e554201989e8bceb09005a1
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# acce4239e6d34bf78c0f97b60d1667fd
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# eaf29c389dcc45b8b5f2f4e38b6e8200
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 5e9afd049fd1437790ebd00a1212deac
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# cb6482f5871140f6925add7f4e9e1be4
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 28c858f3659741a1948bcf2e51fd9c46
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# be1f6e228a2a4f58a0ac664b1ba83244
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 7b225295c13b48f4bf964bcb75045365
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 0e7e1eef93114d1bb984c7d70a6a34e7
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# d66cf896e8d543ce994db285df7305a3
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 7535e16afd4c4f878bbb3f7531464627
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 8c73aa8508c542b2a2844fc13dc64242
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# e564aa6f0de5447689adfeae654f191a
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 5714ec6529a74506adea60cb70a22493
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# e84bfc122a154e079c08f9abed340221
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# ea05b59cc2d34e87b22da7dd79d9821f
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# c1bdfa58cdf64e8bbe4b60c8a644e58a
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 070ed004b88d4a40bd4698b471e19ab5
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# caa41de5bf68404f8a21833929477d9a
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# c7a8d2152a4d4a7f8552b2559f45e092
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 0d1682513edf4196807afa5755ddfddc
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 35928f956bbc4f00ad4ef28675b937a2
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 9a671ea4b5844ad2803de9e50275e6bb
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# 1cdb170187ab4781ab43e23723ec4d5a
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

