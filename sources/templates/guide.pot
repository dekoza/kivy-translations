# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-08 21:25\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# a4c6820a96ba471badf22f62d1e5658c
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:7
# c78e87f550224bc7896253b89ebeebaf
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:9
# cd60964e4de544deaca761b8bbfa0279
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:17
# 153f1249c9064e4f921d18b8683f75ee
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:19
# 78f3dafd8204497c9a5878774d01e226
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:23
# c643b69b9ad04a71946e997236349b59
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:25
# 88f939d33e454247bd9bb5454ae99ae9
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:29
# 99053a2946f041c9aea77cb227e03ea2
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:33
# 946a4797cb874077a33ec6150e7e0942
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:35
# 4993ce481c2942118e5b1a70ea6a0777
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:40
# 2ec73648b8bf4c1180d1fc14fcd490b6
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:44
# cf6e33e074d8437db545cb9ea86cba14
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:46
# f63f8a2653dc40efa731f2c1002b10e4
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:47
# 4717becc8e944c2eadef6224bc5a9e63
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:48
# 047472ff7e694e3aaa27059ed837947d
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:49
# 025b8bdf97b4420d8911ff8ffadfb29e
msgid "custom start.pyx to launch kivy application"
msgstr ""

#: ../../sources/guide/android.rst:50
# c805aacae26041bea0244cc2e7ea51ab
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:52
# 0dda6c0451f349039f56a55324fcdef2
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:54
# 83f9229f2e3d4cfd8a002ceb3e52e709
msgid "*Video providers* (done in 1.0.8 version)"
msgstr ""

#: ../../sources/guide/android.rst:55
# a182bda5694b40069dee61ee68a35a8d
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:56
# 724918916d504a078b64c17d605dcaf9
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:57
# c865d7c95011409ebb5c6f03b1d84532
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:58
# 0e166c386df848a3bfe6ee2e900c07f5
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:61
# 82925f01538f48269ef0d84c9bc5753f
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:63
# 9280e5f36b6b4b4b92705c185eab48f0
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:70
# 1f27c3113bcb4b998797ed7db981cd68
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:72
# 889c279420c0499eb892bbaa1a94fdc3
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:73
# d1f28e5687824259abbe34bd73dfc654
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:74
# d19fdffa7c0941448700b4b81e7f29cf
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:75
# 4a5a735f6f2f4772b8b9edc64a868e65
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:76
# 2ee826a389144af19d1b60d3a220c02a
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:79
# 161f49896bae429eb5568b1996800dd0
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:81
# 171c2794c0f44ae385a589fbfc22a40d
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:82
# 31f756ff1d114682bf0fd11729c4b32a
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:83
# a25e654ba0924fea82226e50d55d7e08
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 9db7aa33a9294839a30da0b595724829
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 5bebc892fadd4c0e99fa4d0870ee4867
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 5ec67d7649d64cb48a0bcb0919a67748
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 6e2a2e4190fd4d93987c7e4b68c28f43
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# dc6591e51fe040758829d8044fa5cfd7
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 04ecd1b899db412fb64f539fd61fcd34
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 03fbe309021048ebaf4aa680b0d73e0b
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# ed3ae524b2614fc08250c0f6c03b3920
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 048179e84706406497e41346dbfc31a3
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 65a3857be5f344c39a1a394bc3f53dcf
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 2110d97310b247c099ecee043ebb1a36
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# f825ba59104644ba9ba9738771394da4
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# e465a1fbe97a4c1fa45f63f6d0aa361f
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 378dfc2efd7144a9b04bd5f4ecd166a7
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 9042216d652e4e4d937261776ae55cc5
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 19defaeb667b4632b5214e12a92bd0fc
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# af0d8719c9f041e58207ff06aeae484a
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# a7eb39c8a44842c1a0e721424855024f
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 1abe43d51f914ede96ba11f0e1ad7084
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# b66c5ca234c74ae2958b3a8fcca6b411
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# d9a905a44f364e40aa10ab23cae45f1e
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# cb807920cd1f4d17afbafd1fa869c68b
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 95324f673cfa4a8483aa47c8e2268440
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# e9d529af0f9d4f1dab2b144efd4f3ada
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# c4cd517137ef4fddb822bbd16764e77f
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 919d1d31d79c4104805e849e6bcb7def
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# a79a2590aa954ecfb9d9d808edbd0157
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 12f51f2e34de4694a8297f6de66633a9
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 83bf544123284bcab125fcf46479505e
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# bcb4e3c38f0243ab80c8f9aff261edcb
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# b250bc0b55a0446fba71038e5b274a78
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 0d8cd715c44c4ae38ab930d7b332f1df
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 6db28877d7eb4cf5a35a64c5f0384569
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 8ac951a0b4e4495886f9947c3693e500
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 1707ee3457d84508a4dc8336d0398932
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# ee51a6196aa440078318151e8215b413
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# f2a781bba8614c18a016a0f7fc8db372
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# b46726b7bd9043d1b76e3d99d3854b9d
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# b1a8b1b9fdfa4ad7a77a76b8dac8dd68
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# c75205b1cdf6426980fc16551435d8e6
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 8b3498cbb6414e1bb8de6d54d33046c4
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# bb9d0d485e5e4f8b88eb6a2e959f71ee
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# e3c36159dc164f4f84851568d56c43df
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# f4c5a69733fd4e30a717ff0626cb6a29
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# d3508e55a63b40be97e46725d0bd41a3
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 8cf36097c6a741c588b64c57429945ac
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 493d036c8ab146d1abf1512ed2954761
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 5866fe10fcd64d7f9d1e9d7f7b5fed75
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 3ee2ad776a8c40cbb14c54eb8267fa52
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 559aac2ca33e4da3b047f9c847e71c60
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# 5afbac4372bb453c82a158c4e35d591d
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 681ca861f0e1404888c1651d334c7327
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# 90a2508ee42a425a98d7255ff5840750
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 76463ed2a27949d68f03fcdd27857109
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 7241c3f9444747d694f990cf248aa957
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 6bc8a51df03d468fa6ff004b133dc809
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 0a8af98b13ff49c1a3af487169f7ac6f
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 9e124fc0651d4e2982f774a6d218b0c5
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 7030cf9b7afe4034b2a5314a80e24bd0
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 7e546a0eed0d40ce90fc19044509bad3
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# b4b8325c5a144627b812f63f8e57bf04
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 977823e96f0444bf82cf78e73c44131e
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 48fe7acf88104d69bf36f52270d82ce0
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 114a40895a4040959521350ee6d19f27
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 3541494f43574c23b281b208bca359cf
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# 544dba868cb64f6aa25629289db5772a
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 450fa2a64ce74b6384df3db2e4741243
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 4a75159f51214d30843ec12451751f23
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# f03e06306a7f4b429ed2f33491996fe8
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 4b2ad9fada6148f9914edb39c610abc3
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 9f871e7e6a764e91a30cfe8499649ecf
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 60fb0391127142e190a54d39392a85f8
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 4e4f4443ac06464488b8e78734000363
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 9adc1063fc7e40c99c704e5bd0299592
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# d19e23832a504b12849156a51e079709
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# b11db60aa3e440d6974e25c5869b1dc4
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# 1c8f7807ec5842c3a0d3f76da47323f8
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# f80adc9c5dc9474481c8e4f4dd906204
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# 0c465dff7728481bb19f9e2157adc113
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 2fea5def813143fc9b000366dc5dd14c
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# c5c03c3926114450befe9f95a369a9c5
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# e30b44ff89114cb7b72063f6c3f78623
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 43a708cba1b041189698b08bd89946b8
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 1c05d044da394f6f8fa0fb40fdd1f895
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 99ba749cc543466c9a4474a8d63cf1bb
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 76b9cc2c19484c29bc36a4e67e96f9da
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# ea04d44cccb643d9b84aa65bb5482229
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 6a94249534df488ebd52b9290731ec81
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# ee053f7ba396416ba4a367f39fe73f5c
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 39c8ca671a0a4951a1c643a35d0f1630
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 7a6ccc8cfd8d43fb9d54537512f2543b
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# e4026804a96d4fc091d4e3383c22aa61
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# e64a974727fd49f682bae353ef8a17c3
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 139b8078379a4e1fbe1a9e0b977b8af7
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# a011e397c83d4333bc813a6fe39d7899
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# ca7ab81b27d7499582c40568ffea0a3c
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 2c59530ac77a4ecaaffafad0994c52fc
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 5e59d5929f1e48ecb7bcc931a6a2cd58
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 04c990ee0c5a49a5b566f71f62ecdfa1
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# ed2e964a93c74bf184dd702e4a032a2b
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# bd2300ed44fe434c999a7dd7fcc1c2f7
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# ebd83335b2394b9b80636366fbee7afb
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 3ef16b997076406cb87aa8a8598e0453
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 6b07429f0ea349bcb0bb390e788d0878
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 252d20b13cf74a769cbaba88c43a6a38
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 46fc931361934c458b9d7ebb41ec2cef
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# da853090b6a14ee98b0091ee75eca1ff
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 32d1371df4bd4c1b871fc3477779a1e5
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 0c23b19cb02642e093f2fef72e996fb4
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 699f62459c19484c97af6f6619bf5fde
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 32f94fbd6ffc459a90cef02bec49ddb5
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# b24754a8879a49ffab05ed7197f43db6
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 53e3eb7a3d9b4864a864d66958f635ac
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# 6f94faaf1f724679bf64b345a13d5099
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 1d24e06c8c01419aaa8a71b8ecc31d21
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 4779f7c165c04cc39105833d3e0fe3a4
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 804699aba62340cfaf2effbb98094cfd
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 8e764bc940954205b17fd320a5907a02
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# a96afe8525c2493187e942df8542ed81
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# d5d8e533db2f499d8107e93fc87a1bb1
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# a92fa02ee1f6472684045e790100d8c5
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# c27f22c2e28b4aeda02cd26f3fde1311
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# b09d3e6f47db4d7ab9866e7ebbe1a8b1
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# a6503113722f4632ba10e118be599476
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 30ec3ec06ff94bd986f7cd5c64bd434b
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 4e6d88fef51243d79ee31ece3f23301d
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 42e4657ba5fa48b297d4a45ea9750eba
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 8c5378d4dd2747a6ba8896633331dfd9
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# f2e0af144580427383e9fd4396cc0c5a
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 731e09a2b37a4e4596228d3ac444e07e
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 64fa8f38585242fc983a8e397c3cedff
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# baaff5413b1e43cca8248f6ec039e943
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 4253c9d0036843f08206e3cdc9c160ab
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 14f00b4541fe4bfcb04daff4af1b1eca
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 8efe6d7f7e63477bb3b25df3e743315f
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# db600124ec39405ebf74f5b05545938d
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 3523d5a94f204eaeb49cb9fc73ed0d4f
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# 6153ec2108b6413cbe2d44422bdaf8e1
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# c4e96542600a4ff09eb42e808e9fe0d0
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 923f1ff01cb64a6a9500aa1e4dc0a5a1
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 56e0a0e4c18e474a81275457b0ce5fd3
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 6b111c1cda4f4aaea1b5dfcaa2e4bca7
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# ecbf78849cd64068a89810b5c58844e0
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 45b6017ef6394363bb63c5c6e39c688b
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# 59a8dbc7042341d2a44244191cbcf042
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# e61c334c140f4619a724cb02c7336264
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 996c64982097472282c2adfeeaa1485d
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# 60b4a502378943568ca8fd193fcf1d33
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 248ad66d7bec4888bb30f513b0bf6ada
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# be9161f16c0a410d8c432bab44e6fccf
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 295675693e2c4110a28f71fc7987eeb6
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 19d5ff84243941e59fff134cde1b8c88
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# f83fabd8d83c4694bd657be8128d5b40
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 6042b94f844e452da085965625eb0729
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# cfa8da07d34c468288a06dc7b35f1966
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 45073af848574edc98ae357f2aebd197
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# bdeb9f1008094afab0c82e203e7ab5ea
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 25a925c27d904819905244eca69266c4
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# b206d398dfed48d6a84774bb7918cbf9
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 2007e2377e7a4220b2e3514b48240608
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 5d5cd37913d740ac8b513f6a85a69612
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# ac5c2b2bfd20410188de46850746708e
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 636caf4f0ae146cfa563a0277c8387a5
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# d4516b2f810c46459a23c8de67e0ccb3
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 65ec70081b9242bbb70427a9f50dbbba
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 2fe839db220d45fba353d001e01fd046
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 3d66b09cf4404ef683d97f658abe35ec
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 20826cc95d0e44099e6011d8f5195614
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 1a1623eca7e448e09659af46bc55523f
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 66ccb9391bfb4f5c9ec8912bf87302ac
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# f7f135057afa45d5bff1aeb08c21d243
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 9089657d428a4229897b63c39fd5fc89
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 4d6413bc90744481a784db30e82957a3
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 36c44c87346d40c7916c42f1c516a154
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 6ca45ce26b544c75a7238ae8a20cbcc7
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# d1a888f0ea1e4f62b99f54f91fb7e3f2
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 955f87f7d76b41a288f6aaa0950f75ee
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# 1c3dca36dc3b4b2aba9ffee7912d8295
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# bbd38390195048d0b07f684cb81a9f45
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# c5a609508dcb4e53a972ef84ba60c562
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 4eab99d1837947a1bb7e52c445c44f28
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 827f86374c8641adab7ebb66325727d3
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# e9d989b20b864f6fb3f5afb0c1e7ce69
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# de23c82b2ae44e8db8e2acb6c87ee66a
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 6b8d71ff1eb74ccd8653de39a3029e53
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# c79e20d3519741958dc833c8d8ff9b66
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# ed59c7f7cda241c58a97d74f20e00ad6
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# b9e1c28ebd7f43eeaafc983f31abeb36
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 6ff540ae3e574c79bfba28730f88fb1d
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# b19b475b423c4fe8a215e921fcb9512d
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# a4bc872bebf4479c86eeffedf6658d77
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# da14db80f8c1439b833fe8ee9454f655
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 6d4d0508baa74e31adc84aef525e0263
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# cee4f0e9f2c141b38ac281996e2553f0
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# bb4b2f6c6af848f081cf3368a0ba0203
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 6663a8ac8cc34579b1d04a23b7c916d2
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# b9127012caa84d05ab232c9c07625d9d
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 63eaed87a7ff44f4b1194a09f91eab82
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# f8d57fa72bef4e1f8e6d92f7c5230077
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 5df1148f9afc4d39a2cfa93bf090a5b2
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 9ecb024f20a64a02b3c00beb44fba8c3
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 77406255a799478599b010fa99e0920a
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 8f3f66fe91744cc2968cb280e83304b3
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 873555d4b2a04b9493cc194426fdff33
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# a88c2cb0ba7643f59e1439144bbacf04
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 55b663dcb3854d7fb40dabb2c63db56c
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 7357494dfc98467dadbee709e89ac34b
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 0ca32ff68d91459a83480791dc822d56
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 34501e3043bf486d95dfc7c654fa3fc7
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# ea077129ecc64db3b124e42abd6a667d
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# bfdb22ed7b6e44f3b75b7e5cdbbd1147
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# c8da5798fe024e208f09ec6603d96828
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# 75dfd8a8e34b47ef80183d47cc4d4091
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 88b1643e90d74160b2a39e9b0dfee764
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 5a395364188e42b39b6b6a9292ac6b9d
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 69362b816d9642159c550aa0179f6d97
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 3781f5031aab4f82ad4a3a3a163bbe8d
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# cad30d509d5e4c72b13bb6823970b100
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 1a78f8a7c10c4f24a424d9a9b3e7cbed
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# 04fd9eb9abc74d49b8236632360c585a
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# ab0383ec2212472db2d137f6a474a6ea
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 733da20a0619443fb318192fed4f44b6
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# bc5b2a5e05fa40349d666d102399fe83
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 2c4f818a27524341b722f94128dd5b77
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 60e92e25bf934f7896c5aeb77e0c1596
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 7aa33a0e7c674c33ae9353a128105c5b
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 5c6f96a3a7754ec093c34c2569083a5f
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# a4725c62bf874b4d99965abceba442b6
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 69129a4defb442f0bbcf6a6093f6b0a3
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# c3ce7d3f9c84448d89fe75673928ca8a
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# f8cdd0c97bff47b896ec01a0e712d61e
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# 19acbebbaf9d4c9cb4f1585e401aa05b
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 83a44dea531a4c02ade9ad14cce50d3d
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# b698a21d3bd54b5d90d3ba6fbb7d9f99
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 8bcfe4c410b64fa1a433a617e013abb8
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 8d2e767afa7c4d1a9139fd51f0de0d38
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# b6142f9d9f9e441c9b4a7f3791e1849b
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 0aa52ff4ae1e46b39ca71f75ea586b03
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# d67753c9ece9407f9647c33e83c01652
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 4d8482859384491f97607cdcf228987f
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# 5fde9c20073c4129bb81fe38a4107060
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# d7122f91395449e2b22985e79c67b049
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# d214af69e86b42d08a7d8cbc8b6a1bb3
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# db01f62793f1467a98e1e7f09bba33e0
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# cb1d49e9082f4df1a0bc0c6f94dc897b
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# e9c7fd685ca142af9fb4183ae794bc4d
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# b82f75204bf94251a4a92a802dbd8fcc
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 492c61ed93a94f9b81d2bce85fb0be09
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 2dfdb171370e49609fba91a598c697a4
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 43a1ed27cc684af1a4541a60d16dd40f
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 585f223869194187a25b098f2de20ebb
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# e3673e92c3fc4662be3e312705e7a363
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 667e302a7ce446fca80d3749cfab497a
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# cb76bca44fc54000a6fe08e30b06fcc9
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 3aa2db102816463cb07468cd035efcfb
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 218963dd50c14e2d9392d619f5e46601
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 6be1620c1d574f269c0b96c2ffb0395b
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# dbb7a161a1ec4d1098e9b9ece6971b01
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# d2b7d305e3b542288a00b020e8aea0cb
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# db5ca4952b2b4d8281cbf2b0207bb417
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 8eb49d7c705e40c7a5c4ddc8c706b3df
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 0342f6db41cd42199e899981cd91cb41
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# e9e787ef2cc1463b8e9b7cfaf5a69803
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 9f3fc5fc18d3466a8df54bde98895021
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 70c65c77c0e640829247710309766844
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# debf2981f4af42fb8e49f223942e4fae
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 63f698994542483ca7696b6107ac3fb4
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 2e550f4b5466483a92ccf0281193c3d0
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# b1d21d6e364a4ca1b46886376106f496
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 950302abea0c4ec293ac6ba58fdb30f6
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 386f2e661e7f4a018b3120a69dd16b68
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 4e2bdf18b3fa4f7fa8cf83a1f0c0cd19
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# fdb0dc219e3f428c83496a38bdba0060
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 1cae7ca32628499a924a915ce31e3851
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 1dfd36e9c7c241d1a142d6d9dd42b8df
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# a3ac07750896499a9fd016b057714f73
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# bdd5951c34134ecca1d526842876f054
# 11eea08dcbdf44e0b614893ca3034acf
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 87275f8a9ba249b3b188cefd81837131
# ba95504a53c640a3a1cf2eec179a5c1b
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 26cd1d84966b4375adbab2907815ca24
# c9ff184f6db44d6b96e89033b23cc400
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# cc9fc7fec84c455bba2028752f88aeb3
# 8401203701874a66a8e1755aba56d2e7
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 84817961a6ea452aaaa78383a2e4fab7
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 4bb02af4a88d46d1a422299df2f797b3
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# cba53ac8d1394c69b6a16904c48a3afe
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 92568282f9714b7c9c7f370494969fde
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 26ad5cd822e54e7697ecc4b4e2851c70
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# b42db5ea70d34561975833b3b3a3d342
# ce424ec97b244a19bc2910f427dbd4b4
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# d51e8fae2cc04cb19fd240631b49d452
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 1e76569dc4b0418a9ebea548344d500f
# 129901684db246ef8ab5aeb2c787b963
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 246f268c60b143e3a690d44ecb7d408e
# 1c5fa3e6399a415c89316f2694dd72fb
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# e08dd0f55f394c2c9f2dce51079fcd09
# 5c0834ff2a8949999297face727ee1d1
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 8b12bcb19e4748de831179c7e54cb3b8
# 50927a66c0e64a8db965d670738e6049
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# a9524935c10846a8a17f0558a24f66b4
# 862b2ddc4fe8484bae56b3ca5359c7af
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# cd4832360a814b56ae5669e348d3fab9
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# c65a2a7c81274ec686068f888dbf2870
# 2b622cdbda2c408abd781b779724f187
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 33f5ddf33d3a4ad7a72b50041c4c2a14
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 1edf0eb66584466d98c9d83b8a70eaf2
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 592b430fac0d47769cd05eb339c56072
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# e133b83249f6421c839739173723a49a
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 110669086e5e4ef2aa98687b2bd36d17
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 8db43410a12c4fe6835fbab76eecb41f
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 2fc7b0d2f42148a2b7b6ee2df010551b
# 5a03463f9e3740b48732af688aec3899
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# e04010932eeb408581bebc6b46ba78f7
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 967458915db746d08f52882fa4f4c67c
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# a58bdf1bdeb846d4bfc9c006ff61f756
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# 5cab16fca10a4fc8be819fdc9b6e8148
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 71b32df7209a4cbe92559a09ddbe3df6
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# b96adfda6e064bd492722b1bdbf85829
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 9a54664cf5e14b65bf9ddf3b85e7651a
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 91e2ebe4eac14792995534e50029aaa3
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# b6cd1598497840b0860bee7f983f7800
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 8caa8e4ed8ab458e9da4b08782a27b10
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# ee45f6c0e19a499d9e063a931ade3366
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 79eb650b5bc44c23b55e43576e2f0aab
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 00a89081c639401c816dd899828fe862
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 6af2bad64a8b43d6889273c827643e91
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# a3bc688059694466b252b8b13fea4d5a
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 97c4a98061654d27b28b4b6f9a41790a
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# c955826258574f63bedc56e7d1268233
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 5731b2bbe01e4aff851ae5f287671580
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 0a6885cd56f24c95b4cbfc903d77f607
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 1b07a8009ecc40c28aaa6a10e11176e0
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 0022ffd2ce6f4eca9e19da781051afde
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 606ef4a2389e4815857bb9588bfaaffb
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# 3f02176507bc461baa6121f1734f903e
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 11aacb29ed044a8cb0c6722d9c02532b
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# c5143724ef164f22b584a8fbb4d2387d
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 3fd3d5cec82a4cb3a8a30ccbbec07a70
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 9ff0353515604304ba98d8e36894912a
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# cf2990b9393d4110ac6309aa9ee8c365
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# b181b518849a46f58652e0e68bc3136e
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 6ec26ab6cae347deabe04629f5fdfd8b
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 9d812331c6344879830e5dcfe30ecff5
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# eb6121478c8c4185970b721a490722d8
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# da5d1033507b4dd9ac2aefe7d53ae067
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 68ba099abd59416ebbef6a6000d75c2d
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 6a29b2b900c54ed9a1abe4a3568469ed
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# c9d857db2dea4d929599322eaf950c13
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 8d0f6f376ffb41a6b6a20935a2d3d1d5
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# dccbec04915b42eba549a73a3d6fb78d
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 0f1a8500e5674df085e67aa9b427f048
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 148f05a90bf14102971768bb50562212
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# d3c40906e83f49e680fe38cf7c35db81
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 20955c263c1449ea8e76d4fecf113075
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# a4962c5e76b24029a1b7b9691061d6a6
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 2ac4aeb430ee4a90a724606df59a1ceb
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# d3957790631541508859bd6072fa5a60
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 75758670a8c54791997830cea8b1fdd4
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# de9f2b57e9114e8a944592843e72b718
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

