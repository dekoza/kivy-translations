# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-22 01:34\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 9ad5b855127e4f7886803e436a6cd554
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# ef0281dad93742d7930b915aeb1f0bfa
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# e6a6faa60db24717b6a5e1424962c7d5
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# affa04b76c0e4176b93b1668e639817b
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 57a4f1b21b13493db9bae72fd798a9ea
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# f0760a5fe55f4b40b15cdb1f62b68337
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# 0f137e0b30b44c42bc227e201002a42e
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 977098b8b6024dd1b5eba43588d29886
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# e01ede9982f14723ae96e49d081d63dd
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 8de658974fa247f4915a5e3dd2618538
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 07e8dc2657e44cbbb2581c6a69fcc14c
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# d17670c39b1c40eaaba4a04f7d545a27
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# 2769206a165447b09aa1085f37eead94
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 0a2eb600a95346f196d5721bebd0533d
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# d83b3354599748529f0fb59516625971
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 7cc5f187a375497da8849f1efad4c9f3
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# e53a91b5d00f41658ac473bab3b750c8
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 19c0f84d78f841f9b527c7b7a6416d12
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# c7d1784f48184c78986acd9355b161de
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# c8f8ada97e97440a98c1291b0c934c0c
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 7d746bdeb6924c93adf801ffc8195486
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 54bb1af711674feaa1784be90ac4aef5
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# 94208dd0f910435899ca334829d22f88
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# e0789a334f1e4f69a0024bd7401ced61
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 5934b8f990db4837ad5b85e546ef4fba
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# e8a68d8555124daba5102b24105a601e
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# 9f93b943e87244b089ef565794326909
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# 05b4b81b01c74e4c99e44647c81b8127
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# f0d3cb954fa449c6b5087aab8aa56e75
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# e4914e7274e44338b63f159eea7c2ef8
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 065e1f7985c24acca122030177bd6144
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 91a674cd1c8f484a98e4fa8ed82496c6
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# 2a3fb23c51b04515bd36325333afcc47
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# ab1533e8aca84c929a91515208c240ed
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 9faa7f3ddd6c4f8fb044cca5a1344002
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 648611a8d5934b59bba485c1e338aa85
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# 1380eb9fbaf644b4a389a5885024528e
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# a8a43672ab174785ba55f098699417ad
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 2e81e7a619bf4a9d92f456d59ff8439b
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# ac70512c362146cc8f0a34907a1d31ac
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# e59d1578328f4cafaddbb78859557385
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# a29270fb8a7243399c46b1e04bea0489
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# d90ae458d14d4c658d04d1c0beb15529
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 3b56938e6b534b7a83a40d25f285e30c
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 362aa1baff1b43418735e82f5efd0bf3
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# 6fdc6b5eb20343d4abd48ec488a207c8
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 87aea3755f0a481781440b73f7d8004b
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 8789f84817b24c89b6ea66d30036723e
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 3bd108137ae24e7593c04af90fd97ca2
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# b60e8dd7f9954218b586360d2fc98ddf
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 98c9d9fa472c4949b5bb0d166795f5c4
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# 70508a67f7764cc5873ee66b5e1525ca
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 47c965cfb108416ea92e0da346e97c4e
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 29b120d8a96649aabb56fa4800deb687
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# c2047a640d234149b01ef86e56ce16fc
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 032e1ea4132c4f8fb71c21dd45b8d6d8
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 04ec2ec0fb4e41958c951972d6f06e40
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# d83808af6e7041f1b6e31042a3ea135e
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 37fe925b732640bcbd81a70991120314
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 64e708a4bb3a4235b0826a521a47e6b8
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# f738bc9d26b34897ab4482e3141599e3
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 07ce9b92adda41e2a7c4ed8d4e10d8a4
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# 2c8bbd048cda4f949a850bd64a544289
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# b7753c96f42d4580a1c6a1f6c8e1352b
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# b6c8a8ccee784f6897759cc9bfb04456
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 07f2eb322dd54cbf9455947adb7418fc
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 0c467bddafc44a849f5b5b3759c6eb00
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 4139ff36bc744ad48c5689fb1142dee0
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 33690ea5aca345109d36ceafd801601e
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 18b66fcc5ada4d1b83d85ff57e60a752
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 6422e1ecdc004815a3be681e12eace21
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# f8df9795a33c484f863d4cabe0a51bea
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 8aaff63af34a461fbcee47cefd0d85cf
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 9aa72e17cef042c4b8725052773857c9
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 5c7ca3d87b194cb29fc28d4fc52a3163
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 81eb0622ca4f4718b96569c89dbf8779
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 90e59bd4e20f4099887c2f9dbd7ec0b3
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 5f3bb0de88cc4ffe8b24c0783d3e1b0b
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 6aab978066c743b19ba7af1310efc74f
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# ed86c208358a4b50a41951157356a54c
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 700a4670961f4bc881ac8101ca375d16
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 92754a0536ba40d5a54d17421325f7da
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# bd34186e7e53476aa62dd90761b2d419
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# cb8e10adbf384788be22a927e89a7e3d
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# d06609a3a50549a0a1df39aa6ec261a7
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# b73e7ee8d8694a62aaa88dd0c51b2c6d
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# baddc77679da4fd1b0287cf7844ef6b8
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 406b1a4c3a474a73bccb6b544caaaa66
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# b31777e9f95041bc9aa35cac68223046
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 261adb1685d7414cbbf99814f0b71dfa
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# e57d70eadc674741a71cc0a3e1d71db7
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# a8ead1249c334ff7ba9618a095019a08
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 173fc6a49abf492e9833e348a3675bbb
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 1ab9b01082ff40f8b5d03619a2de1162
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# c5b45a24e92f4e98ba508c37de7faade
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# d59dd42629674a8ca92c238e73c6ec58
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 3d2ba9fc7d8a44868743eae29f6464a0
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 3b16bb46a96e45758aaf3b5d803615f1
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 70523f27c65b46e8ae7f04c3458f46c8
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 253da9121495482ba378ae17f3179c06
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# b86d34ffe61e481e9925a570d5bd36cd
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 9df928488d2a4733b751b8a8755244d3
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 798d2f83fbd14333a966db2ebf0eafdb
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# 1f276fde0d44435faf2074a833e4e2bb
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# a440bb1d3bbb4c38807930710e0175e6
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 68653679a3504493882e52e2adbe2382
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 05ebdfb46bbe4e0d8b90d1e0d8a65230
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 728857ef7ecb4408b11e7fcb40161914
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 062ff55fcd2d46b683b8460fc055b4c6
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 985ba3360ed2449788f4ab215e79ca74
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 6bd5ee7cda6e41ac8bc88a2e14f69475
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# a96aea9d833b40e9bf9912167f5f42fa
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 9732d7a1df974baeac0ea3d9a15a1277
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 20a71df456a14623a44e67a41ec74c4d
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# 2134668289cc4807adf2ade5dc55e27f
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 8d14615709c4423f9f7dc2207c8a573d
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# 9c72a97d856746a2aaf27d35b6916e99
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 32a6ae89894f46e09b2aef533c611098
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# 7b032377c88d48e183bec228d6ea7a4c
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# 9be3de32e13c420b9102b01a5969d9d8
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 5aef9f2826d744a280ce4a64b191a5d1
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# fa06185ff4a44c31873b759d3f87014d
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# 6c4f519fc0a949ca8700fa48b20d5055
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 47954da2dcd84fa3892e6a7c8c376472
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# a6771b12623d4b0eb11b7f61639a8fc8
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 8bb49f6e893b480eb6ac814e52a10c93
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# e8f0960f542f447c96f5216bf746d47f
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 48b9529b8dcb4b17be2101eb1bcab53a
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# b2de8acffc324d638ea62fec04f3e53e
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# aa4b64b9356442d584f4aeefdea426dd
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# fc69e3b19e5e41b2a8451e6b3bf13745
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 2cbb6d1e9ce943bd90457c335e4a272c
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# ba046f762c094bfaba5b9a76341b74df
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 15cb1ca8fbc44e63a1482bfcc32f24cd
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# 04e656a21116438bb649da2dc54e91d6
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 0a13be90ac20409bb122d3a0265e4bc5
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 34870d5a078f470d86d9f82dfa08f2d2
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 178a265395534ffd98edfe7ed46f7611
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# e2b92b45b1e74e7a8a69ef911c7c3b11
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# b9cd0ad0943c40bdbb707f4555bfcd2e
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 6683a22d04ee48a984d6a18433c23ede
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# b66c6fc21b0c4b4ba26c38fcb958f409
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 182c8300d11b4090bab964cb5c272ea1
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 6367a8b5360f43c89202e8354058c8d3
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 1e1e0ba652f7472cb1f0bee8936d7775
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# 32e73628a29f47ad82a2f2e1e416fc1c
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# e7b714ebe51745828edfe0fafdc3b38f
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 7e3d2a11622c42f88d007483591625ab
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 418663badc2844ba909ef6ecfbea0326
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# bed5000e3ac34a9cb220a52968eb8024
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 177b305de4084054abdb652a2fb170bc
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# b864572d47f547179d29d9098f1006b1
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 568129e7528e4b968f2dceb75a4f8d34
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# b214f0bd0b9642e78be29e014c5d174d
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# baf0ff456a294d19b7471b702418f6c7
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 056ae5768a1c4e30ad085e77c6bbd370
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# e7534b51ae284af0b62cecdc623e56a3
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 3c716b735b2847799198b77175df0472
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# add3e338dabb40d380bdea881b5e8eeb
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# 5ebaa90ea2054a16980e52c3b514c9d1
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 9f453017a2604060b262e84d622f976d
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 3e0ec69831534f1a88476a093110aae4
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# a866bdfab1a44f438f0f631086203b47
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 1d559f85070e46aa8d960b09986631fb
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 5d53283232414bdeac3f6c0bc6f1249e
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# ac6672a995104cb085d93329e86c54f3
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 3c765cd2f6bb41679a32076881e9fb6c
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 1eb0538a447e4578b51da224beee17a0
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 496661a08857499d8ce969f987e9f5ae
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# b4a2348ff9644a1296b5db6974621c4c
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 83acd5a314644c5e8235c6ba97a94e7f
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 97db93b4ade444b8a6979e6e2b9684fd
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# a46a9e742c6d445fb28a93dbc11bcb47
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 7b189e802a91440db125ef34a12eb0b3
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 80679643711a4cf99d51ecd2526ebab2
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# ec621b73e19f47d8a0faadddcab9c439
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# fb78629039d340fa8c28574853bec7ab
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 8a8d61ed111d477ead847abd1e69d09f
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# e8fd71adcd4c48819ef4847fe05e6d91
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# aa5e779e89094b07abb1ebe80ce8e80b
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# ae52dff64be549e1b53429aaba53868a
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 24822df483d145298bf96ffafbdcb768
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# cc39403ee4a344e9929e79b6113562ee
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 0ae0ef56e6a349e683e08b300e9f046e
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# dfd508ba3e274b72a94d6e95efd9b8ab
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# fc202c5b1343493d8052455461336707
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 3bca6777a7b74d6a822e02ef40ff9550
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 69b217e7d3e04278821e7a7cd826d127
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 5b443b9cc2304eb098a349bf5ce2c44e
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 91edf0deddc54fb68becb82bf55c1b8d
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# e9e4bfb77195431088645d850d96de3e
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 776090c11411493ca9b3588ac0def138
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# 3b2bce5276884275b6abb9ee256c5783
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 295a85f2787c4e0fa7a31df43ee8d16a
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# 309f6cedd53e4d6da59cff51d3dab299
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# a4e3f9a9844c4c5d86a39c2c6d77674b
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 013758da86964414a0f658de74dfc9b4
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 653c1e84a9af4880bfe00fcda38ada50
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# df40a8b3ebbb4ebea001912441e7ab61
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 155b0ff1b30e4cb5aaee6c095cc2f5ca
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 14e3fa6262a0421f9bfad202d10175b4
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 19dc9625b31c4c8482d7a9d74c21e5a5
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 3b479f8d33f54296ae906f5df73b9c0d
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 7807efd0b03e4f559742a37a7873d19f
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# e3c14b6e831e496fb60364edd0142f12
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 90093e090a4640ae933fc4bf12a37f6c
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 462e0e81814141ae8c95ac1108df58d6
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 5fc056cf9e4944fda9949b0a8c1280ce
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 8682a098f9b446258bb6f6cfdd03d519
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 472491727dcb4f96ae40d2f0a63d8b6e
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 215867f0d98347c98e8b738da6209d4f
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 1642d048928541be9dd2dd1742ae1519
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 043065a918ac4e5a9c57c836f69cb0ef
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 21c358cb1fe34034a504d85e6dafbde5
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 6a17f1386b7049aa8c37244d6e578a4d
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# b36c6a543d1440d38e094692a047ed08
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# cf3a857c58a649c9b703edaedb21f252
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 18b26c19fd3544dc9a33d49dc2994f96
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# 1884e2eeb0554450a3f213f656995cd0
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# f0e293a2bbcc454cb534d2dc3cdcec7d
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# ca4afdb96c7d4e63ab742301d1234962
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# f2b7a2531dd2427796cf017bd7364ff6
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# d94a9a85886d43319d2ff7ecd7855105
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# e167011a9fc8452da8f383b423aec56a
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# fc13df76599541bc93e625d39de4d617
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 1ea54bd74e714cd88f3b834409f3ea51
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 6e8a73de0017410594d5027069f52112
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# e0cc1b84db384af1a20be8a5c21b1e39
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# 8f91568c1d904ceab2f39fba612965b7
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# 88a11f99d9f74208908e8bc6e616cb1b
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# e96bef18d6804bd7a727dcee6968789c
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# 8a841e433d9b421a8fe51255695b5d5f
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 998b9840d55448dd9dc892dc3002123b
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# ac5661ba24644ca4870a372be0588e25
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 1c7e8e90818c4fc1a18595d0e642ebb7
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 29da348ba140471986bef2e0c2a4d583
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# ca76ecaab7ea41648eec0e658352c9f7
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# e5a8fc1b1e934a46ae9f6b01c5767f5b
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 07505887fb3448848c984a8aed0ce985
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# db809db6cf064c448191f19f6d99a8ea
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 0333058b79394ac794109a8009b1607d
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 347fa6186d35404e8a8b1470c91f55d0
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# b44fb54052754201890577f56e715f52
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# c77654d843fc42638ee5f6214c8ec0c0
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 12c63e71619940e7ab44521f7721bbd1
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 771daefe61dc4d10bd687ed5ab012b45
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 984885addb2847d7aadac4cc80e17789
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 9471a1b704d44061805f623015d9b5a7
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 3288c3a1370240648f8c290214963a81
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# df53226220024f96b3b0091a2c31cb75
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# f246ac91b5bb41d7a333d57601ee4f84
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 19e3ed79b4604ca999914f2dc5cac0ad
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 41c80a0cb3ee4ba8ab5ecdf0fcac0f65
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 539d4602511c4f11954e176b6df8c30d
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# a2c428cdc97543f28059ecf6690bf2bb
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 69892b3850ff409a88328e8cfce317b7
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 527ab7cc0ee042d0b7a916af66ed72f8
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# b7c73a7ce6c24a439abfb126eb710ef4
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# c896814a5c5443af968eff545fe3e51e
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# f9116b828ea64954b1b69af487aa1b43
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# 001d2203b0604bc4ae24c2ce605d2b2c
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 1f45118fc45f445a9f694bc1e68bf328
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# a773dcbd06cb4a918ef95701efa41da2
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 26c2d6ebc8cd40499b09054898faaa7f
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 2528ff0f7df2416b9ce780f05c853c4b
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# e046624c61334afb918b8d253ed75cbf
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 5f8da6f116704b21ba907c7f377071da
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 0b925c1c904f45a3bd86b7239d73e5ea
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 0d992a468922412aa95eaea3825a34d2
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# ac611a03a9c14486a9a319746ab39aed
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# d298791fef7d4725bbd2154584d1f88a
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# c2bc80d6ced64654a662cdf401bcab5d
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# f412f2eb76ce4d47863232316d2980e6
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 8bf54178c1f24433b0686884837f35ab
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 044e736db9da4a1b9ef5a7e5a3223306
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 666a8e32696a43c6836890e4eb1c9bf0
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 5d96b009e2db4617a330e469214912dd
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 85f10e9bf26e460899c5f7e25b82668d
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# de2cac39f0464fa7930c048329fdf218
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# a5570177d24048e09718c03ca0998ee7
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# f2d6dd679b0c476c92bc2d53162919a2
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# b198a3f499bf478584573c122a23d478
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 0daa2d0aa083493d8db1f9d3305ad3fb
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 950c7afd0b4f4e93a5d0841067d3e242
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 5c3bab2367e542a29bcfc758793b55d9
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 3d410d4c10754e759ff881d9215242e4
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 3c91671d6720491182b447f3987e9d37
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 0b839d40531b41008d7182bbda9f6850
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 8470a83656cb42798a08f297b9932e5b
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 4c6458cc082b4f5aab8ae7194a50c34a
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# bd2dc5a404384f9fb8ecdf8702ee9e92
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 5bc57ad363104001867b72bc6c57aded
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 21b67d59bc224fe3b006d67f3a3309f7
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 413a8e6ca73845deb0a57a38211754ee
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 42162f3d157d4ee5b6642dbe56b58b43
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 3eefc49c484746769de79f30cd816643
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# d8d1357a592d482faaa52e725ed6c3a0
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 8279c997eaa24c5d86eebb99ff0267d2
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 9174d7a2bd774f39a6435e3eed4dcd77
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 6f6b1f327483494396c78b75ea00f2c8
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# d44676774b27462da8c9d067c9b24619
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 255bdb20d4e3484686c215cc3c402e2b
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# f768f36ca42641bd8d5feb92702395d0
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 66eb1a3d5f784e378ee7f324e2f1262b
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# edb6e508f24841e99a18f7dfa993db0d
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 451f4600c3744361ade608dfcffc7586
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# b192fae3af884179b2ebf8b5005d91d4
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 59794241e7e94f6089f99cb325af4a70
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 30a6c27510d545c3bf7633ba92e5a005
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 34378c8f013a4f45b9f3e1d4e167a5e8
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# f9dbcd30e013485fb4f813736ed96653
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 7447fd9e3fed4ae39df43ced4713cdc2
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# cfd1bc3bf76c4f3c9085dee34781261c
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# 0deadb50f29044b2bd139f8ee0731c7a
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 767637165f11441694b6574b70f3079c
# ec2685a7a23241a6bf27d7058d59fbfe
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 4c14405496fa49f3814275f12c298b7b
# ab46cfa3d7c14ce7b830213dbb5916fa
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 33ec1779f9c5485fa78a441e86010330
# fe06dcef385e4f3089de4113cf798b09
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# dd7097a0b5cf47ce943c63c492478c12
# f4436f9a7f804f768415f5e44e77ba50
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 379f97046b9b4257a3259f5573abfc16
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# f9518ffe25c94dfbac0b3b43388f5469
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 48239dbf3d9945ac84943409e06f9129
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 9e197cff361b495e9de7a107e79d7445
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 4c66cf4f882f42088f5d928a17a8a5e8
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 3071e23189ea44c4bf7fe33b920ddc33
# 0a0d0a578e5745d0bbd788346dc4db70
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# 0a5df65ac0624d51812fd224212933f7
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 069d463b25c44c28b57aae0d3c710430
# e86d69549fb44079a2e7193d627386b6
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# c5fb4e9ef45d426f8103af5a696e1538
# 36c6da085d1949529ecfd7d36f3bf038
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 67954eceb4434f4bbe8d063a7d354142
# ac3488f43fee4bf79c115926da39b6b2
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 35ecb83fc7154d3b932cdbb3dd27f511
# 8bbcccce090949bb8b6a7a9c340a04dc
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 82d6dea924344225be048e4d6b868cf4
# 11f19fa4140a40e6b79a128caf89f62f
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# fd3df98468e4442eb05f7fd9f05e2cc7
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 4a7cbe731336468abd9c4a22aeafcf9b
# ec3f2cd8db534526bbe0f75b5049224e
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 84191590d09c4363a932dfb364c081f6
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 2f16e061a84c450fba1469fbf291eaec
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 7df8a8f79eef43cd99058f93158327d5
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# d7c1f00149fe4f199adbce9afbf08b9c
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# e695b631e4b544a68befd581ee026c14
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 4361f584ade34464b387770bc9f5d86e
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 42720ed88b384a4c86ae2dd28803c2c2
# 411af04ad0d84cee8f2cf55650868642
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# daec0b1915fb4c6db5266ed8b4615f57
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 625dfc2a87034bb28e31c87bca503876
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# a553ad9fde524e758e6bc4347479cc3f
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# dcbf6c398938476e90ff7fd5a7574538
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 5ea469bb35d54fd7835d78ffcc4ee82f
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# e5133e0bb3f64c02a05edc5e61586d9d
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 72e23e26423840159aab957fce84913b
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 42f13027025940b7969db2203e686777
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# e8ae6fd807384881a59fb340e27cf729
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 96ce8f81c0db44f08a77dd01e52614b3
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# e2cebb1626884124af913316e5833a13
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 9a099967773343fc9e61d50581c8d796
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 04a5f19e975b471bb516809cd1922076
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 08c917eeb65f41159e56327cf6c02d18
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 57506e648c3a443ea1d5094bf7d6c089
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# bff84b699ddc44eb9088ce66309e219f
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 54a8c30fc7b047e3bfd44ba1de7e2ef1
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 8094d0b6caf9477c8ea98c44f3fc278e
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 210021d192004249b40d56669974b4ab
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 2523c512970b4ae9bb2517e9ce0c2ee4
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 8738f44db11147c8af2ba901c74c2081
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 5997a355b047459ba990f9d7b518a744
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# c04f5674ad12496591d4c139966d26a8
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 196b106d86ae4c7aa9451eeb9fe72a3f
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 7090e783f5074903b309143545ac1dd3
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 1bb62b2f86be4093a1aea1c0893549bb
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 58b075354e0b42aca1f579314c21c244
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 2e0a3cd630054f54a153f2765ea6dc74
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 451b05cad57d4925851c30a157476f82
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 3460ba3dd6254556b15b51057047a11f
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 384966d1883446308b27a49fbf4a3c3d
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# cbbd25768bc245328b96acbd38f18087
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# b8fbccc164044ec08c3acde52b186777
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 3321b95d1b3b4d24a542833e40e1933b
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 2343d9c2a1b9427e9ab26fa9bd40e114
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 51469894205046bd9c78d883ea057719
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 507ff8734b574ba09412082d77ac4e60
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# fd6e92c088dc40dca8afe9e0f6b4acd7
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 044ba9e57e7e4d8b8c12d261ec58ad78
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 100e6bdc676d46af9a9bbdadabdf0b78
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# c1314fdf4fb84dfcb6e5d3e3db3b0095
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 8d15ce85464d4897b1e2a222edb98b2b
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 7cffe481a7184432ba07ada7e05c73ed
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# a16ffe54e4a94573918b27232d5a3784
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 920eb0759480440dbd12193e2f982b8e
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 9d5a85e4bac4489ab18fc851235d6159
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# 9b230609252842eb96eb3f2cf2d6c810
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

