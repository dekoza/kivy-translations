# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-15 00:13\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 933f0eaa120d46c0b5d61bef88bc1efd
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# a1f78a38f43444b6ab5b690fcdd4217a
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# 02029c39516a4436883ce40b8f3d43f6
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 42ebb8a217c841bb9c94d454744d06d6
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# fe6ebddbcf0547d88b8643258726df85
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# 45495524dda749babb613dc33ad385f5
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# bd565d4cf179441c8f085a081489c94e
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# 3a9b730cf4a14cd9b39835b17fd480d5
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# 478d650d6f4c41f284ff08ca51d45f53
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 399c4802b22643a79a35cd5f834e1679
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 150cadeefc024cea90b4e492b71e3b32
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# bfd9edeecf2a44e48df3758d64c811dd
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# f18ca6545d61494ea7b93fee4efb24bb
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 2dab8fc4f50942b9bc7688ccd5bcd972
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 888129be4497463bb69c05646321065b
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# ad99c4b20c144e0baef98ec2af681388
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# 0d36abaa0f9f490696e4c824fd4896e7
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 303c39e756cd4ce3835649c34a515f42
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# c1fc9252b5b446db8e42629f88f8ddc9
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# 9690da3ab5154beda75acf34bf7656a9
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# f2bfa1d5542d4d79827085ed31a60a5d
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 9d71fd2a08bf4ec1997bf2af4aaaad3f
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# dc5d7fbbeecb46cb8b1f70eb75616b47
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# 5380a64a34bb4f4c9001e1166312c83e
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# fc401bdfad394a4fb2bd995567fc15af
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# 713ed23684824cd7b83f4fcb83a3056a
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# f7799c18f9aa49b59da1212f4b418179
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# b6da29746ca14e3ba04c8ff63342bf39
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# 4b9570e6f701429fb5914c37cab05de2
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# aab82947582044a199569f542a83737a
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# 3a61898a497b4fefaf01470bc25ec9b5
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 33ff5cb1d63244979b5162d6cf0d47c0
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# a918e7e93259450a93ef7d6b9e909f98
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# 33401999447c4bd3adb27db6e718cc06
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# f4a7e773415b431ba6b13c9e2848b21f
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# d36c1357152a415d9640e964330a5e46
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# f6c9407df62c4c60b6de6d2b41be55a4
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# 18734821b025458383625b19ef8c9247
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 1861a74ffc7740658c154bb734c2d340
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 9762ac19b0114184bcbd9c5b7259f32e
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 5379bc1759f84c05b3968df0d774fce8
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 8e8b43a3b09a42c882a3c56554f0ba5e
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# 8cbc43f0c92140deb7d4d89783a633c6
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 0ad46146a31d455988af81d6aca13f10
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 767cd5d8498b4abf821683d0425feb81
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# d9127d5a59d0404780767021f39b6263
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# cb137720b76a4141bd865b213f66abe7
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 91cbd0e15e724d269f8790b135b99df7
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 2f81c3d8f38441c081f5e492614619b5
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 2abd797cc2ff4d2c9bfc3a9ca6ab8961
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 45e8f8f2813a47f792fcf50e552a9076
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# b249a6279aa34fe493096af8c7b2949d
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# ea0b54ad1f7347eca251fbfec3e06d27
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 5f2d308e2d7741d098e33c3a971f3239
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# 871ca982294842dfa4fc5899113349ad
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# a656532c15db4049bc95cd9aa6ed861b
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 65ffb99d87f14ef684491df85bd46eb0
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 7aa4835bdb5e4f6a9eff7ffdccb6d3c3
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 2594849ad2a44f6aba612ec88f7da505
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 338282d4abdc4c44a10343317b68dd2b
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# e049a9420fc8457ebe007933d164bd2a
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# c0faf0518cc24d2ba96ba0c6518b3266
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# cc2ff88a62cf4fd5b212bde477d7d844
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# ce517b8bf47b4937863f388b94fef757
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# c8ed8084815845a393134fe2d7289d3f
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 2fc0581f1b9a4f19992459831b364d95
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# d0018fe7810a4b238e0cc79a3b1da982
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 48e0da38329b4868a9fd0510b054c0ce
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# cf4db6b00a9846a4a434792003215931
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 671b957b8e064e3eba9330f43e460915
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# cac45ed0ce044de784327206dddb5343
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 4146c0f8bde74583b4e7efb10b3627c5
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 63ed6d48d20948529d1f34c854a1737e
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 989dc9a9026d42d3ae2a8dc78cf8728d
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 15495b51d786414d896045df2a1ec26e
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 31db7da0f98147fd9aebc1df1d11f804
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 948121816ebe437796dc95856df10487
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# de8c48e81e0f4cc186325cb1731f9317
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 8deabbd8dee043729f625786bae48dba
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 9efda5187424499eb44993ad8ca8d8cf
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# ef47b8e1a8394dc8a694ecc31f440fdf
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# 2b3ea07cd910496c886c6f0baea0646f
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 1ad0a87bfc9c4f51aecc1e4f1435b3fc
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 7e4db410ada9435bbe396a7583171e5a
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 1b81507ddeca4befbf706cbb0651e797
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# 8bc1f96951c54ccbb9e720393a6fb9b0
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# fbbd332865ce49999b980b51ca2695e4
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 406e1a108b4d47aca7c85d7b898a57e1
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# 14973325346d4891a52de4546c5fa93c
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# a5d2cf56562a4e509d5b50dda7df0721
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# 6031114fe1594e4d849560725eb34b3e
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 8ab2f18710f342ce808dd0f0dfa15f3e
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# ed22a78636464cd6b6abae50e103388f
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# a56d47f234764225963b6993b0339171
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# a19e84adfd2940cead491fcda17790eb
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# a0239cbc2df64c3c8b9f51011688b7b5
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 540b9997eac543938748e67ea7b1a2cc
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 96d211451023494780790e27d22240f8
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# 6aea6983fa7d416ab89e1bd373e7641a
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 54ed698fa3544b5c8206e6ff75a4f439
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 83e829b26bc54c66941423135dfe7257
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 905f97f38f3e44d68b065c445229b3e1
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 5456d8b12b324da9905d98935892e3ab
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# 0f73e50178fe4205834e80086a3a6541
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 2e1a6350866d46fc88a4cc081242e1da
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 58d9b3ed998f497aa53e2d7fcf5a55b4
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 05e3be4017fc48c593ca49fe3085846d
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 391ff52297a64a0eaff84804f8a64d67
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 8eee0fd043194e169db68b67c18578fb
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 842c26b5339344128b71b542f9b26a59
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 8f15751ffc9d4258a14118e8a8af5e5d
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 49bf0892df2240fbb005faa160ddeb02
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# ad52eaf400bf43568bc004c7a0587d45
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 70c126b8f4e340d7b664687a81ad38f5
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# f9df81faf7a842588d16d54016df4fcc
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 023c2bf760724588b31c56f06c5e06dd
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# fc809a50cf58478c8b3108f0f38738fe
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 6d9025d3608a4dc39d69f7e391a2c0ae
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# 10cd77b252ad4d059299b255dc9b1f90
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# f21821e4846f45f7bbee4fd6edf812f7
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 461285482a0f4ae8b4a5244f120ff4e1
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 8717cd1511ca428d8b97b34bda1a9f0e
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# baeea27df9194f5eb0c9d29cc414d1a3
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 7ae469fee7ac40c785e6310c19e5ebb3
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 03404f55ffcf4c7888dbce5c5ffffe75
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 4dfe51a3e2fb482b822110024403e7f9
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# 332e987f05184eaa88a5f5a2f3a9c76d
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 844a3229d76545bf82c26522d4d20b4d
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# c7066f58c26147e184afea647618f82d
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 4391a0b0093c4308b5a93507b1021e8f
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# ca6defd82d5a44ee8ccbd8c5a7e5c0ca
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 09544efba3974508b90e1fa85a16424d
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 53d0f3b3dbb84d62b542e4e6ee2e234a
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# b0cf6a6a82c742f9a4531bb980059389
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# e3546761fe8945d0aa883cc3799ca177
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 6466430040ab45269cfb140be7584e0c
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 86dd604e677b498bb60e1f13955f2877
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# 739c6729f5934a6da94f5463c6d0c942
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 740cf6ab8a96469a9ea3c00579211a71
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 25d74e6d4d6040b19ee0ffbbf636971b
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 555cc77837b34d4fadebbf54e1868841
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# b4c0d1347e7f4814a63147fc5b0d70c5
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 5c51dc5497e94bf1b7272d1fd686af76
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 2fb640bff5b34eb48df77486ee08ae3b
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 86da43b77f994319ad139ef006aa366d
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# fac07db08f734d1caf4d8cc96a7e2295
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 70a13ef289c2489faa255131e4d79b7f
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 7639b86cc7884977a7e165a2272b0592
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 12d3f5e2a889494e8037135ea8add6cc
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 3e70443db2af4ef6a8d2ba933540bd20
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 6eb5fdd20e9449e9881f7ef580c109ba
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# d47df474a87546ec920867e49df9226c
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 28ab755f99ca41dcbb7747df74b1748f
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 052f6ccf66e34b979f4254efb9297777
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 9906eb2e533b4c19998459b257fd088c
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# 2f5f757f5e4044d6b14dbcd04d2fe685
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# ab68c43296d34397b585be07ffe0178e
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# a6d436ac859148b987391ce6e4d88f6f
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 9f279dbed7684a90ada6755ddb8d2c53
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# 5cf30da9cc3a43e0b0b4011c7eaf9e5c
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 9b5fe22b1b9a428a916db37493d5e3a2
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 0002d5c4bcf74dd08f2f4fad3a2df91b
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 6435a4c49cde4daa974079004b6e169e
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 374dd43438cc4a49abc597eef43271f6
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 9e57a2c4e19844ca9715fde8b0392433
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# e9eef924dd4c40a7a07b01a7359279bc
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 4218841ef22344799c36e5db17babe2d
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# b21c44ab40a845d8a147d281a8ccb516
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# 22b13ae67cff4f95a6c3ce1ac7d7c57f
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 26d2d88660a542ffa734026b0fd893e1
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 497abc6a68e140e486be84d93b5ff4ac
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 1b800ab2436a47729fea415d3d796bf8
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# f54a59c2b1864ca6a98e97c90986714f
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# bfb96b3c2e1c4dcb84992fe2aba0c87b
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# d449e50d80414634b2c4c0545e75a957
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# d65182e5387741c482884d80ffa5659e
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 89922452b98f48dcb9a2ed077df3cb03
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 6af8518bf46d45c1b829c570e153f1c2
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 492cc14640d147509b9bc0115a2cc051
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# af7531827cb44e2da940e42eb82b2146
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 70614cbba7dc4733b2dab5e8992a0427
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 14097b929bf14397aa2eee6af489942d
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# d2d48e250ee64aba99d64b5e3b711e95
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# a9a9eeaa5f0f474d9a488d5e985eca77
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# c29f1bfc996a4e4486791b4ea09ff5c3
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# 22d1d9aece954b7493612142e4daa04e
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# 375f66c027644ae794bd30d41e7ebe80
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# c5dae028ed4d46548a1af640b84f3595
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 30b782c5c9e0467f870bd7bd3ca1dc33
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 72cbeeeee12c43bd807a987a4eaeef74
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# bf35de4f5ade4e699a35a68d684054f5
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# 368a65a1fe2346faa854949f74df5c9a
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# bc14d81792a244c0a9e2b8a071152962
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 6043680ad8054c2faed7bf1d2e45c442
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# ace5a80551364e7c887e1ff30575f57a
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 6df8a87261084e7ab866c55698725137
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 78ab1815eaec4baf930ac4dabd343eff
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 5c2b8735e44948a9981365ce1227aedf
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 12b8956f125e4c0dae7733990ee3653e
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# e662b9635c40407f9de774d3d153ce10
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# b81868e0b0cf4e71b6d2bcc3cfab7bbb
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# c0052c008e624cd2957095b8fd9db893
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 343fd2a524634d6792be58a579432ba3
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 5cf6ea0b45b34a959b21f7b77272bbbe
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# e0e5dac878f444c7af881d371d25df05
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 4a677ef6dd76474790593e3146cbdcd0
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 77883eeb12894b6da93c12f1e6d8cf79
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# f316ef18ab374295a1ea50a9cee00f6c
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 25b0d604dcc84f608c1c7b327b996df1
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 5a5a9079841144528e0a9329df20cd1c
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# abd8fab80cbe43dda59aff4f6fcbf812
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 10b8dd89de844ecd8e2795f6d9650b6a
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 4319476714ae4dd9a0f4518c4a53a188
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 122ff5c888af4ee3a181bde6b6206899
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# e2b8dedef2cf4cee879c6990c2edca99
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# e3ad68a778d4476490218c63acf362a4
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 436d97b9461e4d89a6d260901219e3b4
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 9132899efa644929a45dc336ec4c9fc1
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# fdaa96c65349437f8483153d1967562b
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 7abd56824bed419e93239f248bb305ae
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# b9a188d078d9406b9db3ba3e18cae6c2
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 1a70c14e6f104989b3cdcd074cf0eca0
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# 33a65728c7de45c083375fd381dca551
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 26152dcecf264df9993262c0b44f580e
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 38a3f438ac6343b291215534dff0c66e
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# f6ae35859971407f899e8fe0fb1f9095
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# a27048a2c28042439b29ff697234c79b
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 5fda3b09a8b64e6bb265ad4359f52fd0
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# 313b553535194c57bc22f591c9401f6c
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# 3e24e0f8ffb24a5597e37d600465daba
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# d941644a336f4724bd316fa30fb08148
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# eaee1cff7f6142bb9cda3a0d09a482fa
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# 2a18e1ef54314a32b13ede90e49aa0b6
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 6888cf9cafd44c8abd5ca77ab1a88ba8
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 5c285d0ad5ac41e198e75813be1cba51
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# 15d0c5473ed04b6f9a436d1b787f089e
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# b8ed57fab44e44ff8202d7e7d6e1a884
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 47e5ba04efb64e8497b6f745c609f848
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 70041140f5624f8291946927b368ae7f
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 9fdc4d0c4a20459b8e73b638751bebd0
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 6ec3724966df4e2d9fd5de7dffd93c9f
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# 4091c952a3fc432f8af5365adcb83ca8
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# dff46f54e80d4bde949934cab5567ff4
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 97064d45aaa34f95bb0b7c2e103fa6e0
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# 2aeadec2955b44a7a8809d0b7f07b4d0
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 085af6b2edce4eaa8c6a3af5ef48e8f7
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# eae8b51347764f50bff7adba0fd601a3
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 63e4c88362154673a93985f23328fd85
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 2549aa11f4bd4956a421d6c61d7bd619
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# f10260eefc6e41f9aa0e539387465c96
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# a8abb802ff2948ca80ce52684119d94d
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 2b0ed5d3eb0a4322b7a0b3de44b58283
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 408a28c06ca44a0792e14d5dba6ab6f6
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 124203a6c2794fedb30f9f3551fcc56c
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 12a7a12fe64d41d18b427bd0e9b2bf2a
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 39fbd95e36344952aa9f60a8b66fdb0c
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# a57b4e595a6f4f45b6e5677e3130db05
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# 6a2b77dc301549ad9cd75b9679b564a6
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 92c76873769d458ab98d7bd794d96cef
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 8ba8204596bd466ca1b09e807fc2493b
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# b060ba25e7a743ec8ca5fa07f2626189
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# b92db222b4cd4f79bc0764ed4bdd9a4c
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 47b9c7e6a47b448e9bad5335738ed24f
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# a7e5659a21944ac3be3c1b1d663face0
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# f133f6f5853c45cb80d58441d9ea2c6d
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 2f9d7b6a08624c0fb0b79ec494587c3d
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 155524bdb8914883b423f922309e664a
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# ef783e6b44eb43e197d8bf6c20379e91
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 164c2c1d06f742eb9a4b9f4a55be1af7
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# 4fa2b64708b8442aafe9d7d6742c073d
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 4fe5db50fbfb464cb138f2a2b5e63d66
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# b4e496413dc048f396370f6f9e1cb433
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# ca09e59b119746a5b94e6679cc84f828
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# f5a74427bfda4978a02f0eb8adec892e
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# dedb84d4a1d44cf49e992f90facd3fc8
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# b1a7aa402c06471eb48a0bfa318ad84e
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 70a4019bfb914df9a92a572cccbd9e25
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# c3527cc02056446098aefc184a489372
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# fda63452ec024628b457683cc4a1d23f
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# b18eb17520ce4779967034a406ea9dee
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# 90d71d6a016649629992280e0d635979
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# 218a4ec00c0241c08e71be92ba00cd70
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 1fd1bbf5b6304307ab907f54484e5597
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 89b3af8bcbf64383b8c983ab6fc323ff
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 05ae21a49aec4daf9017203d08018fd5
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 8dfede31d53b49d38344f4e71592cdf1
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 5c3d58b73b1746d7a5f4ba98c0904cae
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 754b2d8e445546baa12529efb9df55b0
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# cc56c606bcb64c47b5d4d750536d737c
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 9d5ffce95c6d44629d0ad8c8d8f3a734
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 222a9fe103b74505b1f7dd6e459efe90
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# cddb5b0896bb4852863ade6393a9d461
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# ef934110554d473196c494016f75c6ae
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# b9dd304fa17a41aa97cc7c3e6277e696
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# d057107f45f444f7af917f78b175e8c9
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 64307ea7240d44208ace062c087f1f2c
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 2aaadccb9c7e4aeb9a97d68ec38e0d09
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 02899b2b198247e9886caa090db15ef3
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 5ced670641fa49dcbaecc8cf8bc8a090
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 5d815e0a908045cd86a2379dc0b6b3c7
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# ce803fac7e454c10baf8667074d038d1
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 2c709bc3994f4de3bb8ec0df40fa51d3
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 6d78a175712a4ca0afeaf57fbac665de
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 8f78ed5ad1374c12b5192509a4ee325b
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# c476f8ea4aa44ec1bbdb34c9fa76ae90
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# fa84e3a749da44aa8b568a38dabe9047
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# c36676824f1e470abf23d400aaf50cc9
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 9cfbd202402844ba829b126e41b648ba
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 88f8c587e23f4a0fa05f42740ca452d4
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# f3d9f86c5c8d432991bb041168ee70a9
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# d2d63125244a4a92baf4320cc0392a55
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 7bc5ff11addd44f5aa4c460b70f2f220
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 18fd973d7e254a148410e39e42f7291d
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# dcae75c7165849e3acd6e84547f51bbe
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 50f9f1b4e9954f66b0bf06857bc63282
# ec8db6a614704a29aa99113c43555445
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 9cf733cac3fc44ff91c036c1a5edaf15
# cc54dfe7d15748558e36b1466434a532
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# e125178d6b0848568badeb670a997726
# a6355b9d10714e33b20f2818111d8527
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# cf8a36d512f948899bcf8fbc26b59f1f
# e5ef732b1222423baa77e0eb5be4eb4b
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# 96231f61d03d4e73bb44c7c1221255ec
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 369dd70d7a2f42f88e5cadd34ca88a1b
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 7e4773094e17436988ad995f1020b7a7
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# ccc5dd3c07ae4a578373d90646b00515
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# c4c9e79ffe9247f797f7e67bcbfba788
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 90756621dc1741d2a83b475a2cca687e
# f928dd8d69ed42f289ac739af644850a
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# 10a94ddbb9374e97b5769773d756fde2
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# cdc574c7badd46bc9fbf67bf166e0453
# bab25eb2c78c4512841bc4316ecfdcb6
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# fc3128c830c84b76a01246d95ba3be73
# 88655c7999244aadb959a067df4d8d1b
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 53181306df744aa49bfa3faa39a7f05a
# 22ad9629f1f749bf95b2a48ecf9b797f
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# f8a6243867ba42c2ad90a24c96663947
# b3a7ebd730c04646bc17e5b48e28956e
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# 6714442e56e74b159d4e16408fcb8ded
# 6587ce4b80f849cc8116620b299bc2ca
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 9b1b83ee23e14ffba570b98bd6a02d6a
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# b025741eb4744db993207015fae51ef2
# 189a0f8c114d45019f84e9e6eb155dd7
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 7ba0246b8f084b7d9687ff7297fe44e6
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# c1bec855aab94070a1c15a26b7f713c7
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 5f7c572e9e2541528ea99daf7d262e34
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 534c3434f7804a2cba2a41293a719b7e
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# 3d2d66cfa83147b89a2cb9611a685bef
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 60703b01faf04f6ea109467fb3fbe61c
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 278367ff530349df963f2f822b0698f0
# 9a473a54094b49adaca72df785d995fc
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 7d1882bcbd8544a49649e077e658c1b7
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# ad524cc0d1c84f7ba0069860895db3ea
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# ab0d94de99a94383869f8639253082d7
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# 3969a9243c9e4359bd09926ec990cbdf
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 0060ae1253614b5faa1a2a0fb20896d6
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# da0c245cf4d9455080f8fb7415717348
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 77bb4e909b244b05b08f2e31fd22258d
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# eb659e3d99c34157bb0af01a71dea309
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# d0134e8fbf8d4b10ae5e163338c1c7b4
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# cb438439c64444e588f1e3a912046ee9
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 8bffa779b7444adb8aae0b3ab7d865fb
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 2013a8ee6deb46be8e9a71ce67cd0c32
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 8c1cfd5a2b654155935ad8998ff7cf87
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 4754dbea652a40329902d742ba6764cd
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# fde5d418cc10422fb433e27b0ab5fa89
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# 08d60356e66848d2a11c761a57a3e34d
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 628941287ef64de695311cfdf67379b1
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# cd55c7b225a24253bec269b49ceb9517
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 63966a410b2841fc83ad74490bdd4108
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 6c1d65678f5b4227bc4eaba10ebbf444
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 86950bae55584749a544c4b9050d81ae
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# ac0380db9f3a4b68be3876d4bbbbdfc5
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# 178fae8a67a24fc6b1c12aab2af16a2b
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# e8d3e29de02c4014831112e2623c62f6
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 18b1f62bf48a4602a74d9f6259b41740
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 77b3652f6a67440a881a51f7b033b447
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 8ab86144db1e4eddb6cdda5396c8f868
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 7c382e4170f3400c8f13f3673a81aae3
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 01b9a862bc0143059f0d085962ca499e
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# b52467b4133f48e1a82a7a08e22ea83d
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 9b171481e1de42a8b215802523a03934
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# faa7628316a343f08bd5054a9c09d971
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# feada9e0b46f462398f9cb1b88f60ee7
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# ed91260d0b2d42159361eb46d139e92b
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# ca20389fe069417fbed8eb3f58c837e4
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 20af873c30d74ab7b95113759475314a
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# aab03f2bc4d64ccfb7079b686f48453f
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# b9955b691f3844cbba30f03ecd4b4e15
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# fbf19db5a5de40048dea8d5e4d9a9a9d
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 77b0d165aa614260a0a7b209ef13fbd4
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# e6264145848249c8bca945389aefbb32
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# efdd3f84ab3d49be86751b6e1f4f8f18
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# e014dfc5805a4f2d9413f5bc429ce8fe
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 076d1ec6a6114479ad4ec73dee3bf8a8
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# f1e0935c8bd647feace08a27fd282480
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 9072a17fdb4746d2897647cc241fb50d
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# f42a3dfe3139404a8e2ad752bcd749cb
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

