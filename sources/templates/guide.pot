# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-04 16:26\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 83940901d1c94e6b9d6732d767bd3e47
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:7
# 6f6936ab7700478f8b04ac0946e63623
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:9
# d23ab6d334b64c83bd9beecb827250fc
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:17
# 48bdfe4da01a48979b63fbe41a968445
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:19
# 46aab781c8634c3eb4b8cc43de96408c
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:23
# e4fa61dabdb44b28aa76deac9967de77
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:25
# f48dae779ca94da98359f73bc2200bfc
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:29
# 4810bd5dc7114d1ca104f4845d196180
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:33
# c694a85ccd5841018875016e55fedcce
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:35
# 1f8263ff07684b10846987cb438ae531
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:40
# 855a6be5e6804b7cb4e800120a890bee
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:44
# 4da2b153ffdf444696582105affc6d67
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:46
# 967cd003fc384e8a9b613d930d2c8885
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:47
# c61aaedbd3884f8e844fbbc6500e7460
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:48
# 855edf0ba6444ced92a0900bab7a91f3
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:49
# 65f93a1d94514accbf57515f8093dfa0
msgid "custom start.pyx to launch kivy application"
msgstr ""

#: ../../sources/guide/android.rst:50
# 57001551d5234a1aabd247b572c701fc
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:52
# a8f8a4460fd24da493edcad60cad3546
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:54
# 2671cf90e4b34a8a8b83c2a98498ddda
msgid "*Video providers* (done in 1.0.8 version)"
msgstr ""

#: ../../sources/guide/android.rst:55
# 291590e4ddc94d6a943bc5676f6ce80d
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:56
# bd4e61bb13234c5f9845d0a5321dabf5
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:57
# 645f7dc59fd14c728dc4918c02dde483
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:58
# 7d60f8cf59a643a8ad61cc6777cd7b4e
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:61
# 5c1e0504ad5f4ed0ae65526db1ec6098
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:63
# f78b80a50aa2409cb6242876bb354b51
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:70
# 3c401fd2d27c486fb15e59149217481b
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:72
# bdd5453800474b44a86eefd93153dd72
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:73
# ab66b02a4573412dab432357d72f1e2a
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:74
# bc32c8e55182403ebaf4809b769a866e
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:75
# a0343c4423134a8eb913d175f6285fbe
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:76
# 5d4fc504e76a4db6b92feb9d69a68e25
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:79
# 94cb7377aa3348a6b626eb2d608fbb9f
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:81
# 7f356d18c27649d393825886ca182016
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:82
# 51ed5f715eb04e2097e6e46f7637ff7c
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:83
# b5fc4eac9f03457485faca46b8da7ad1
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# 4871135844b14747acda7d4a725bc0cb
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 536f3269d7664ee6a6abd66f03f7507f
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# 906a9b8d382c4c418f7748506ce1cb95
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# 5e939db11fa441bca6ef67e56000c942
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# 039a74e60def4a35bcf5ea5c10ce208a
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# 233f6f03e5fa4923b3a76b12aa755b02
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# 3931a50d92a5488eade9c058e9989d4e
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# 674c3680e6e94edda18ec7023570c466
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# e90f78e0aaf14ffcb1545ee110c3e7e3
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 63c12ee10e694e5db550fa27a12e21ad
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# cd51c6c841f94b94868a77d10ab32244
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 9389f2380a8649f88f30049cf1390f2d
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 2fc4a9f278824d49b8cd16d4d676d4b1
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# babc661783a649458908189e4dfd2fc4
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 8a7f81a0925a4d03b76ba2e80463d3b5
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# 147badcbb7154e0cb72181d045a0672c
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# f717715177b7462187563c6f993b84d3
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 5a93c147177642958214c64a2668bae8
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 92f2edb431a24a9eb76fa98b5aaabfbb
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 018a47e256274931ad1520936a29ba28
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# 9da86f19320545e8829e0877721bff9d
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# af2caef086874abd9267bf70802d9ba4
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 9150ad5c33794f51b0d1072dd16246a1
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# bd13d19191cb414d802619c80db902e1
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# f827c82347844239b24f89c6a460062a
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 46cb75fb3bf0463c8b4f518d2bd13242
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 09df7bcc137c4031b2fe3e151efb59ae
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 6d33e158ae494232b8dd1a21c77feea8
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 0b83c093ec1d4fc0b8d2668bb679a16d
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# bdd88201a3584ad79d6d8a336174d05f
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 00a963de0f824813a380f72211faba3e
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 6614b47b2b8d4f75adeb7223a6ee5fb6
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 57a95009ee1749bd9a43186b9e783502
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 5f79d2eda1db4358a2e079ce2be0213d
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 7017a0e088d44bac869080576eb798d8
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 960afbc2a9b04192b1d0d040d531c325
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 131d31ffb4a549d289690f15195967b6
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# d2a3ee28ab4240a68cd0ca489c8430bc
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 42418f4b52804fe4ae817e34cd2f1ee5
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 7fd43e1269dd471c821c34148c6cf3f6
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 1b4ceafaf0304c399793053c0aa5378e
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 19cb013acecd4ba7af3d410b0ebc237b
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 2ba471fbc72b4e58bac17cb18122f195
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# b7d35dfeb27f416d92bc12a90cb5c856
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# 81dccc403bd045a79655e14427eb2147
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 9dd9c5c0ecc54903bc5e65e2a5e89ae2
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# 8ce511f426df4c528fcc0e3880222ad9
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# d51ee325c9544d00b6c6117f501c3f5d
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 3197eb7a28f8478aa04b4941dc4e9bb7
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# 452d28c2d7254a749efccefbb53c7853
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# 9ac1f9e9c36d461682231b7b48482c83
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# ea30116d92394208b3c588254187c55c
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# cccf5c3d3b7c483f8aeaefdc7ddb1f6e
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# ed9bca0c098d44f58c45b9e96d78939e
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# f2259279e5cb4f5682daebc6a8e50ac2
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 97dc7a58a0fe45d4ae9f28a946c949dc
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 0c0dcf8781b94ac887f58311fcd59dfd
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 5df372d93d25451b91bdf3b41216f353
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# e9c19ab71053424ebbf0b2c7a445ddeb
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# b55941ae92b3408a82bab7acfaa51e22
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# eea4f517e44e46a4a9d972c1bb757e58
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 92b81b23a8844299b22264e43e4fb855
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 2789a0d5e20a486ea591dccde3190f2e
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 52eebe6a8bd04290bf3242622f4f1ff9
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 7d8bd979c2f5490f9b0429363bdcd731
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# d9cbf3d1b3ad4ceeb72b861ce258cf77
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 7f23ffb47c9b4782b3fec8942c5d5ea7
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 9a050bbaf322412c9c3a25f2dce73d03
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# a9efd127d8704001ab9bca2db2ed109c
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 7b50cced1f344754bd4ea5ae478f7d0d
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 39722417af90489a84ec1b1e09cddb0a
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 714b595877c84fdc9db84ffef9871042
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# c644ce6c2a524b37b52fbadb6d8dcb54
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# 7a4676567b9f4b2ca317cdfcd9b86944
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 0a8df1cea9b94ec383c0b8d0ffe5178b
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# 040c847f509c4188a7bcc9627e7f8860
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# b0325db945244d619a096029f8c68f50
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# 09b05dc3d3d8400c80682a021d02d432
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# 08457e00e9f241a7a80dbf8592584250
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 9ad45b8960be4e7383e7a43542903889
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# e6abbd68d59c4ea0b5b377219b9a25d3
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# 1d172d5b5960470b83fc062fe0138c69
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# a464e91da1d342ab9850ac4b3374ca35
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# e8816c36c2704e25967b9134af99410a
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# f50c5b9e90634f9a8074cfb3a08396b6
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# ec287c9fd3a14fc9b9984a1155b47036
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 428ec3e0683041519f567dd8f1a3c09c
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 874fae72192c4f12914f19e0f3cfa7aa
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# 3997eb8b4cbb442cb925e14c22767f6c
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# b947a7ac4cff4967bd829215df3037a2
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 44c2d1cfce4a49968d4d5213e0606ddf
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 2bed98928dcd4f9ca980b8aae57107d6
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# bfd1bba5c17f43da97b468bb37dca707
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# 9712cda5228b409fb03492e1527b6a9a
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 234ddc26cf194b5c834247cb59eb6530
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# 1086d79d07ed460da87d5d22654b3e21
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# b3c426f64ad848b8b385cbafe91786f4
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# 2761140a9eb347b78507bf305f4bb116
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 4f95dec30c4542beb94f48e8ed5f67b2
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# b1c73779ea624a528a1fbdf7df78d3cb
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# be4f18b55ccf47418b6a0b552c75476f
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 1e1442244b544d33a3c44d3c310e487d
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# d993e7d2d7ce4c72882dac7daa270ab6
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 6c2aa26eaeda4b838fac3c4e1b00154a
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 78e1f7e5b85d4c2ca03e6f494c31c475
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 8b5c4b11576b4a9a967f7f4316448b5c
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# f9b9975732d94396bb0b1ca70359722e
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# fb4dc66dfbc14bc2acd0199a9e4738a5
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# bd0c281bc07547fb88c3cd5b27a7fdb8
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# 68808bded82b491db0043c3f474b27e5
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# 8f87d54383ed49bdbeadd97b6ad03d1c
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 3be47ffd28df43a481d2be578827c4fc
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# 69ffc17aca4b4bf7921f18b27f36d571
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# fb49486041964aa7baea8aa1eff9bc5e
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 37c08a030d1746bb867b186d7c810120
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# 5d7cffe13f354621ae658a382787962d
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# 3078206b7f1d45d49f15447901ca5a9c
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# ceb09b4f867d457fa7b8a21e512a7ab8
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# bcfdc47afa3249519b64cf620639be46
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 70beffffd7e147fa80b404898bdf43a7
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# 85a5969cef934b9b8487ce93801a0068
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# 6b7a11181fde4b07a65a17dc14ab96df
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 273b0947fc3c472f9b40c9ba3376cfc5
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 94af4d1a94054e60a4bcadc97ea535df
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 578ff5e31cdd4d7a8678a5dc02e21455
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# 0d848671f32341de8f94a0741fe7476c
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 02f165c550064b95a7a42266d88c615d
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# 79dcb8e6eccb4de1af6c10716e4dabc7
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# 45ee1d7995704d48af66d2a0aebf5b91
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# 7b9772d068594b3498c11df05814aab1
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# a89422d179e74bb5a73f6ee6b3e1cca9
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# 5aa969890df34c2f89ce81e18c254827
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 2295966f338846d287d9664b8f777cf5
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 736aefcd6d554de6a4df7f4869e5ebe8
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# aa7ecc5e94694063b0d2f83d4d9b0e13
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 619feda1e29c4d6baac7f95d53fc45d5
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# 119fee2d7bf549c6b2b2b8668b449b2a
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# cf19338e24e1434f897bd11c260eb3a3
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 219ff447882a4996a6e003620430768d
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# 9892d96208b349a5b411875bc3ac6785
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 1a1e0064db7a4d428288b53e250f9d7c
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 7c2b8372fba04aec93cb8e8b9d2a9e75
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 6bd45c833b72409cadc92065cae0c422
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 94f48ac615734b628ebdd564d60ff955
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# 969387546d644caa9eb15e1df910f91d
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 89df255d52c34c66b83975c8837dda1a
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# 6e0372abd7f34ebeaf2a9b9a34140576
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# 8434a8f7bfb540d6bbb1c92be23a725b
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# ed429672d2314613ae0ac5f9a542da8c
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# abd248bd95184c26b17f96572d5ce518
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# 8ca755dc63ff4c7aa4aa6db86a32702f
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 84d7e5a5f5f64330b3ed92a0670b3fc5
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 3954e6d73bee49eb84c7e327296918fe
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# da50f93fbaeb4989b6d31174a0d343ef
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# bdafae4539f647c4864a14e82987f374
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 56026c5f098049f8a523a727ee91fe01
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# f8abe99c97394d11bf6a1cd32cb3f819
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 3a1b1a946cde46ea9652eb286459d1bc
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 9ddc855a399e4fe3b8ee8e718bcd0bda
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 428b27668e7e4146b853dbb83dbd53e5
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# 1817effd2d2740f18835214c163aed32
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# 0be9acdd511b40b09a5d8cbcdaf5e68a
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# b0665f97e8d44ef6ae5a0607105604b5
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# 47c5b2255ba448bebbfb92aca717404f
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 47aa52ae9ce94f328471bed7151977ef
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# f186846d227f4813bbd96e28e88243bd
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 69847bf8b1f743ac85141c675a587751
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# a15c55463c954b8bb6eb24f089984844
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# 771811b73ac948e08019b9c373cb0f07
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 19a21999f2704a458a6459da43f43b99
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# d5da439394e146f3acfb21ab7ccafe2a
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# 0f99a5c3da2f409d81d1425c19560466
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 9ebeaf66cb79414aa0e9e4a928bfa8d6
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# 57c05e893492433ea178e6d3161aaeff
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 0ea286ba395f4a298ab817478fa27852
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 8f0ae35e825a4f8baffae004641e89a7
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# b44c681fffbb412cbf128629f6487eab
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# f769a3dec42d4fed8b2e2936d437336f
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 455e6f146f2f4a02afef39d5607335ae
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 36bc968f82b7421b9557dd5d76fa2b42
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# f9e5d63b6a2449f0a366977e8e3e8442
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 0046936d1ce14767a718ce97522f592c
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# 4185ca23dafb4e3cb71dfd6a31793028
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 985f2c76b6d348fea092f63408988dd8
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# fcffe6d74d784338b7cb3242cac0e7bd
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# 13d5c3d61d684e18876b81b48c75cfeb
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 075ed016250c4ba1872b72214492d250
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 99b72fc4f4bf4ba8b936ea19ccbaff48
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# c8b171af2633494fabfded3b0df3f852
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# b2e0fd8b225e448f9259b4afe21cca8f
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# c71be91bbcf746ea98e1d31f88f8a34b
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# b4242dde4faa4271a9fb60f8cc94506e
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# 3d0673abb3d84ac9bb36906c1929f1b3
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# b2bd6eebf50142ffb2299298bb2c7aaa
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# b9c7608cfb6b4df89491ee402076a2fa
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# df1b451f17214d3190281708183b3839
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# af7d0b5c160e48bdada89aa031cabc2e
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# efc45d406a9a4de49a850bdbffd2e313
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# 6e51339a6e294ddd97d62ad3ebc4fe63
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# 827bb093ba8745509f187f6b1cc582ca
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 3aea88a95d724c68bed53438f2a85144
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# d5b71355f509437c9ef9216cca8f9dd2
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# 9fca362e7fe146d686f2aafac346fedf
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# a621a10bb1e6456c85d88b21aadb0a0a
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 7849dff4b66f4efeb669ccf04ab3570b
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 4ec4bbda780841a68e46b087f720edca
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# ae7170137db14cfc88438948497cf1c8
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 4b28dcdb58124644bbe03a8bbaf463b1
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 3ebcf097f2ad4d9e9477daa2293e1bd6
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 9008814edade4ce8bec26b57187b0c2f
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# cd328754f71c4aa995e68cb2ad5615c4
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# 762425931da24a108219a8fb18d6da80
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# ff2d3073e2524b8e80ff4e222fc22b55
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 30c86b303bfa46b18af4a775ba2ceaf7
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 8c12d04f64ca4a6fbe9c4a9bee72f6d1
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# 8626b5502ae245da8e5e45c638e75289
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# 0b52cc92580f4921aa4bf6c4ea212470
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 5d32bb20deee47d1b6058e0cf6e8ee6d
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 936675cbe4fc4ea787869a1db6a89d9e
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# de3c2eff71374d009382542626f98b9f
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# f80adfa619614cea8eaa0c69ebc06b12
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 19ad580ecd1e4de08b3f123731ffb175
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# a9cb13a0b8644adfb42052e7803bc46d
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 2a20db0059384a2d8cee2a8827b9fbbc
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# a548ed85d3344d0aaa6473a4b363000b
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 522c0afd654843fa9588cfbd203bc47c
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 1446e9d85c1a4818bb92f3283292c3cd
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 3d0888ba882a45adb18028f5b454ea96
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 98a6dee04ee94572b4e16ad1efd6aba4
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# a0753ecd0c10467a99bbb8acafea9110
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# d5d2879280c944feb289d87a05c8f31b
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# 934c25781099408aa3076db967efdf51
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 48c03dce998b40d1acb35416f4a4984f
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# 1005401e109b478fae9a6fdf0627f7e9
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 3a9dc50cf8c54f86bb70413248347772
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# 6210de6c9f844c249fb9db6e59814850
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# 29fe139fa3d84f40b9fd72096cf571d6
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# 531a71b9b30b4fc8bd51313229f507f1
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 7c29e5450deb432e85fcda0f4b01ac18
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 9fe962c1d777431fa92b13f25292f33b
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# fd4203f275fc45dea4f168f007310757
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# e4b3d218cbc74f3d879e39a7b1cdf4fd
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# 6b923e11925143c58870f85938e630d6
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# dc48f1419b694cb6b02cae572b83c086
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 6b7362d1e4cb4239bd0b249524ac2706
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# d720068fefae4a3e98fc085ddd120266
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 40b29a93f9d94c048c6a995abb6810ef
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 43c7a7ed236c4a49bf536a881a054876
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 51c53e065d0c4077b8261b044180e655
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# 14a17512af1a46be9894b8c3502db7d7
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 23c54c1fdc4c480880fa6f0a1162e2d5
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 90ed57f1da214133b0336814a358bb9b
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# 755eeadee5974bc799e44b596950d4f2
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 9612ec138c794914a9b2c169ae4d094a
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 008d7966c10f44f59894039d63712896
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 3beee03fb92c41c393bd56d184576e50
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 0bcd84121d6c4ed3a1936c371f210c7e
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# 49fba3ed6c6745d69bece845b3d49423
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 6b44d635cdab40de887af0f8d4538052
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# 3456760676484eea8760637b1c847b08
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 09c9d37a8a814f53adf6f072d7f7759b
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# a973b85f938448738c2f6317d110015e
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# 9b8e5a3a032343b093d287f47990cc1e
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# 127a5d95ae1042dda402e44f190649af
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 8c40930cd09d434cad5b71e4e47de444
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# b99381b89ac549a0b40506e00be7fb83
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# 5a21b84def294f6dba0ad68c0206b95f
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 133f483a2f514149a467052377bfa609
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# f453854bce2f4feaaecd2d8bb32766d0
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# 48a327e8ec9441aca4c3c7aaf29ba65e
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# 8a0c4c01dc294cf99e5f94732c2777be
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 8c9d7a811b7e4dd3bbaf2e78cbd8d49a
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# b3c827f7ee5343d0bd51dabdfac70a76
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# bca096ce828e48f7b4c0f08eb5db8959
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 92d7f10d5e994df4bae2de81d9d5efd8
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# ebba5f49786f4beebf0dc2244bc7d9a5
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# 6e15f9aa09f04e6a91f50dc33c6f89b2
# 459d601bb2e94e679163b53d790bd908
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 8101ec219f7746c88c1cfb360582d24c
# 3a762eca47db4c28bc1b5e7009dcb35c
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 31d45f4200144cb98b1264f11797ec89
# fbef73fc0be2490c8103ed98ef1732c8
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# c7a5638c74894315be4aa996c6158f72
# de171eb48eaf4ffdb30de4baf09ed6ea
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# b0bcb7746d01470e8650bb2df9ce407c
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# 3150541ff7a546639fcd57f7f51c0cd9
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# 5d8b2461673744a1954254320301c8f4
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 7ed86f81078b467998eb2e9d8d74c9b9
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# 7d4700efb4224b799e9f5f99d1f74ec8
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 8e1e27cd35134d359fc4bdbc76a02c2f
# ef7396f2630d4bcc809f1901b90c9c9d
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# a62bec12f72d45e3af1a90fa041eced4
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 76b288c3614f41239cf1d68f9ef31805
# 9614cbb99d4441a6b10def8d60484928
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# ad000d1ed2f0406488d1c0f87aafdc0e
# 69809c71f97e4048adde9cfa681c0f22
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 84aa5d1372da488faaf0a5933551afad
# abf3ccc73e4f4319883289c8f27e3c4c
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 2484bfd19ad843b5856870dee88fd9c2
# 9288f7bc9f2c4c308abd5d1da5ee5c99
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# b006ce17ac654ef48b98ce7e6164fc45
# ac7e2ba5a7134d82951309fc038bfaa1
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# d1bee608e78f4e0092e2333767564b04
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# 8f75b7358a4a4aa49558b99cd36ed6d2
# 96862c007a4b444792300fe99d6d1a75
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 9479cd40a03d4598b3152030d33b7345
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# aa6e46427633429eb4da386aaf0ecd6e
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# a4cd0106aa6a447db37cf3a346229f94
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# a06869022f824333bc5a0ab71d2081d0
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# e5ddcec0f5284ec58d28376dbd2c5ef6
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 7cf60ff3bba5414eac4d2bdd0c3de5b0
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# 4747350d25c544779aceb8ccc2ab2def
# c955f36b98274816a9a895a5f1d8b67e
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 7ad741aee37a4e9ba39b37bb482c5748
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 5f64c74eaec54980aa2b7ca5028f5011
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# e67740d7bcb04e7db6bca0debcdb9aad
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# a270f04f537b49f98dbc88ec66a403e6
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# d4a2e7af0e4e463996d3e9fd8396f95a
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 53dbc58f35c64ac6a89dbdb57faa3686
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# 101217d2da7d4c509c9e654a95a2358e
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# bf1f407281d043f0a2ca08f7b2c1655f
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# c9ce886ecf4442a08ac0b08cd0e3b35a
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 69ec2463beb340afbfb3e6c888a623f8
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 604926f1eab24fb1963405194c83b722
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 3202e827cd3947ee87fac85a92279463
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# 36149986089948b4b296eb9a0b8c47cb
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 19eef8088a244a74b542fa8b02d58a1c
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 9f0b57fded37460aa0ecc64bb555cd1a
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# d9bb4caf16fc46308842f6aef2e0d49f
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 261409f0778040a9b037d89947eb9bba
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 6b965f95dbaf4a46ae80ab7fd8421f60
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# b07f3a1b09aa4820b95b074fd7ba6158
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 83ae3d8c283e44028a4a3e46d1fcfe47
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# ff2b5042753642be8bfd5007820e8084
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# 834cd9216dde4718a5634370d56846db
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# ace0d642496b4a6c84a0c17afc9f3405
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# 9210b3e7cb0a4b2d854552a10ec35bf2
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# b3e24342b19444cbb140b94ef39097dd
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 3886a0d3a0c04b479573a827e5d1adb7
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 169dc5077f7d4ef8859c6e664d401863
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# f3e3a04c4e70472095b52c5028f37885
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# 697881aeec3a4571a9c06fdffbf4a7b3
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# af1a1a107b9a4794b946b8781fc209b0
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# df50338424d84930978cc5b6911f6398
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# ee21e53b178e4247b4875b0d4d1c1649
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# fcd7da38c42246afb9538280c5564d1e
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 66d7f71de2814895a574110f94d5392f
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 585208518efd42ceaf7a811b711b2f45
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 6be70a2354894f27bcdeb71c595ec085
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# 17ff3c0ce1e044278ac89520b030128e
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# 4b16aab3214340eaa6349071234d093f
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 15d5b04f9d6d4c7aad7be3c69c3aaad0
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# dcb4853452db4a459169d6aa49d0432f
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# 170d89dae1e74828aeb77cfad700da30
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 6cedc67055d542339aa6703dc11bd9e3
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 101bc05507df4e4b827e6c2b3dfd3bd2
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# 6367209dada942bd87dac2b9048f131a
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 856e043043c54ebc8ed0b5ad25ff0e24
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 33da04880e8f486a94c9bd7c424c225e
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# b06ac82e6b5c4ff7ba7979d40f36459b
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

