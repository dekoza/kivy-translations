# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.5-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-09-28 17:19\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# f4c26223328f4c16b3e967579c28b88f
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# f7710c3d94864430976014c44815003c
msgid "We want to thank Renpy's Tom for being able to run pygame on android, using his `Pygame Subset for Android <http://renpy.org/pygame/>`_ project."
msgstr ""

#: ../../sources/guide/android.rst:9
# 1bd2630f43c24b8abebf449587f33f5b
msgid "We made some changes to his project to be able to use it with Kivy:"
msgstr ""

#: ../../sources/guide/android.rst:11
# 598da30192194054b74bb183246c7e1c
msgid "Support for multitouch events"
msgstr ""

#: ../../sources/guide/android.rst:12
# f6a9a6184d4745f1a1bbe10025103e0c
msgid "OpenGL ES 2.0 surface"
msgstr ""

#: ../../sources/guide/android.rst:13
# 30d2882a839049939a33160c4f90c265
msgid "Include more Python modules"
msgstr ""

#: ../../sources/guide/android.rst:14
# d8864398f02b4e2d8ea0c6244836006c
msgid "Removed main() function and use __main__ approach"
msgstr ""

#: ../../sources/guide/android.rst:15
# 2054ab86036043b599b0f238439ad280
msgid "Various enhancements on the build system for Kivy"
msgstr ""

#: ../../sources/guide/android.rst:18
# b31755605b5a47569a154b405773ec51
msgid "Introduction to the Kivy Launcher"
msgstr ""

#: ../../sources/guide/android.rst:20
# 37d32684f9c84fda8a9dbd46f766950a
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/android.rst:23
# fea8c77a2269445bb1f15939c1028691
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/android.rst:27
# 800f802cf2a24d3c9a7979331c8d01f5
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 70e55601f688412a8f4c3518a50431c0
msgid "The file `main.py` is the same as your original code. If you want to support android, you must change the __main__ line to, though::"
msgstr ""

#: ../../sources/guide/android.rst:40
# 88c0a024ca9147cca0e543186aeb6523
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/android.rst:47
# 8f61c8a57c8b45aa85fccdd626ab3135
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:49
# 0f354867b53f49b09e82a8c6eb9dc3e6
msgid "Missing providers:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 39300b01f2f142e6851f5cf74274407f
msgid "Video"
msgstr ""

#: ../../sources/guide/android.rst:52
# 142780e327724178a4e941d616243a4c
msgid "Camera"
msgstr ""

#: ../../sources/guide/android.rst:53
# e8d24d0ecffb46b1b2707181b6c99a17
msgid "Audio (can use RenPySound)"
msgstr ""

#: ../../sources/guide/android.rst:55
# 08a842b89d8b481aa02752122a1c5de5
msgid "Missing features:"
msgstr ""

#: ../../sources/guide/android.rst:57
# 1eab847b2ce149e2be7dbd595ed9ee1a
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:58
# 50a37ebd5c5346a98f0e4f9b0738ed52
msgid "Keyboard support in TextInput widget"
msgstr ""

#: ../../sources/guide/android.rst:59
# d428fed633e34779b46fd83d71ab415a
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:60
# 3d4925b446574df6b6886780d6a9f43f
msgid "Ability for an application to have a settings screen"
msgstr ""

#: ../../sources/guide/android.rst:63
# 94c14e16c3c14731bc516f27a92fe340
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:65
# b24c235a6a0940548749e1c1b3860c67
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:71
# 67025a095ab5467f944ecfba2634c6b3
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:72
# 357bc9b6ba694737b5c5fceb8240321c
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:73
# 3927e92f8a3b4260a56bcba4dff36078
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:74
# a742c84f1a9f45999280e660960fafd0
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:75
# 7ac86b3fd70f4dfcb72d125a5a6e9f5d
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:76
# faae0b39fe334b6f861b8cba3959dc61
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# e1db0f5bc8e34b5bae5e2588f0522225
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 60d15a773a66485692a86b3dfb513ae4
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# edda8c601aea48de907e3378d8abe683
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# f664be0271014343b016252aa0c3ec8b
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# 196269a448914d9c88ee99e3b1a58d8e
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# f3f5fe6ee8b148a993de23de7aedc9e3
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# fe3f3f186692405ea02f342eca8ae818
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# f767448363ce4ea1ac1fac6a00d62427
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 4cc9abf91df840f08886de5c905ce2de
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# a1e357dd814f45e2bb4eadb1e83781c6
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 3c73ca06902c41b4aac8d17d95b57abe
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 3f49aea16d414b80933d5ab22edfe083
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# 06fc13f6e3dc4fbaa3e0d814995a3c7f
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# f1cf83ccde834cb3ac79d5237f3b3955
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# bbf76432130f47f7b11be379a162b9e0
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# fe2b851f910f4bfbb0e7836c6f9a9c1d
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# 6052405084fc4be38828090e154d29d7
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# 117712b49e0b4e55967e69d5337f378d
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 7550c5bb1d1745b9a856e2424ed679f6
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# 6c8fde415ded4a58bfd0bc6c60dbdc72
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# cd4f8f5f32954913b7a759d617f6b738
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 642738fd47b14f6589f7a64c0c7dac27
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 1266c67b8f7c47c19665ee4126ca7a84
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 460891ebc91c4cc4bf1de475f721fd8e
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# 99d767ffb06545618047a61c0359111c
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# 38528c0efcf3461885bfe5286f059a67
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 6433459510ab40659c4f2b09684af139
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# e16f188b2ffc4661b67d02707c191c34
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 969a3c4ca6184836a9d6071837f1064d
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 0e1c31c6fd7c499a826be3292018657b
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# 4c60d7f3730347639a52a1525958318c
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# e67aae24ecd341b6bf4fa4e4e5a85e61
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# 9c485871bf504a5e8eb11004a1461d00
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 89475e8ae00b46a9ab18ca5c2f6db276
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# 54c3730af6494977999cb3d909e1e217
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 88d9febb72f14550a538e7492436b921
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 5c2f2e60261642b1a7e339debc3c68d4
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 4d3dfce2e95242d3a33926f10570decd
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:8
# d7fc04d949484d59b1425009dbadd000
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:10
# 74d328cfe3cf4092ae59a49b2000d347
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:17
# 498bcd373dff4dff9c3c056c302502f6
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:19
# e97ea55d39f84ff5abfa89e82afd95ad
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# ce60f661546249688417a786825e131d
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 622640d734de464a944d30abd7b553ea
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:23
# 06612dce5d96408f8483ae49ea261628
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:25
# 477927bdba984c288d8bf53953a5dcd7
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:33
# 4b29c9ec21fd43839bc555d4fb216796
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:46
# 1a6a8d398ef3417488d231ef215aa759
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:53
# 628f8c2695fc4512bcf4d213e05da61a
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:55
# d3a334cea14547cbb925afc907975592
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:64
# cef79a9660b44fdaa9d9467b69b17977
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:66
# 0418125830824734856af4940f9d6724
msgid "Let's start by writing the very basic code structure that we need. By the way, all the different pieces of code that are used in this section are also available in the ``examples/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:76
# 66772690ab664b7aadb814aec4a01353
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:90
# b97a3bdcf0404931aeee11d90f0c2d70
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:99
# c7d33d9df2df417da9c355f6963d9379
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:101
# 35e58fe9e82c4763b0e51240922a824b
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:108
# 2fa9e43ab4ac4752b12d1bda4302ad59
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:116
# 282f81d746214136b0e9b71073249cca
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:122
# 6000e00284824cb7820744d699d5ad30
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:126
# a6ef7920dd844c50931c26fc8eef70f6
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:133
# 327eb6b290c247849a51b921d62937a6
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:139
# f24eae03caec4082938c28ba32f43a56
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:143
# 94a56bd5350a4318b9411b606f33e7dd
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:153
# 768fa527c3df465d83c5525eed6b5c63
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:160
# 0a22d63a8e4e4a9ea4e4bd79c4562038
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:167
# e5af4c9fee694ac89ccde6c9b7c01702
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 2c1e19eb5aa44f09a6111fc1130c6de1
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:181
# 6fbad12a0fe44f5d8a72755cb9df7b2e
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:189
# 244890361d40409c8adf04f0ab87d7d1
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:202
# 5ae1cc1695154da88243b2c5ef15b16b
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:209
# 8eb836a47e0a47dbac7f745ed3a36a1f
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:211
# 79702984acbd491880ec9a9f1668bc06
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:213
# 4de9ec7c87114f77b5c36717738c5e8b
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 280cbf23010947b2ba9af5e4b7fbd426
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:230
# 806f2597b455402183bf0f7feeee9ec2
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:234
# 16bddc22fbe14fd4a63306065e76f1ab
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:249
# 6a0aae4908cb4ba99217d8c38fe386c6
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:251
# ad066098cb244050ad754c5d01816030
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:255
# b0924c85992a4b27bc36683381ad6b89
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:261
# 7cfeabfc910f49699dad6965a00acb86
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:266
# 83f7659af5c342d7ba5b6b17610437d4
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:269
# bad76af84b794a79ba559c6b5ac55366
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:278
# 7aae59ab4ad44fe2b68e4750b09f904a
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:280
# 1360f57e6c72448b9512292f1e6ebc23
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:282
# 258e8e87030f4a418dd95e1592b4b412
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:288
# 73c95e94a2c3425f9694ebe8adf8445d
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:290
# b1388a711d6d414383ed0dde18434200
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:292
# 24e381736cd34b95a9dfe002472c8207
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:296
# 1ce8b37e2190445bb9b0ffcaf1edac21
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:302
# 4084b646641d4894980b7813ff92d05f
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:306
# 88211f0e33d04e218a547fc30bf7651b
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/platform.rst:2
# d2cdec3d5e814d1a821044f503497509
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# d681234f62584d72b7793980b7d19111
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# ccf0391c6e1e48ceb9b06e5fa365c42d
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 28dedd4370db45e2941c7e633f07965d
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# f6892c57f49e48cda9c32d54e416769b
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:31
# e0fb3cebbdcf49a6b99006d470d76261
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:33
# 3adb0ae97da74420979673d42fb181eb
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:36
# 77fb3c3cf89745138d15e8f792afee00
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:41
# f5e9cb2484cc430a8e0ee0128b6af295
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:48
# 32ab604489b940bf99154d2e1f5c6213
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:53
# 8bb0777b1dc441a1a978e7f8ae842cf4
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:56
# d42816bb10dc423ba732041241c09d07
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:59
# 56863bd0da55431686b1b4ed594935fa
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:61
# 79684fd256984beab4e15160a2a7b64a
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 0db2a1e0c5944583836948043fd04df5
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# c4a267a7bf5b458ebfc9f17a7c29328a
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:71
# ea052ff34b1a49b1ac5c8fd345e2c42c
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# a25eccb3e11b403b957c72ec7efedf66
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

