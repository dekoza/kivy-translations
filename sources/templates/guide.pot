# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010, The Kivy Authors
# This file is distributed under the same license as the Kivy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: 1.0.8-dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-10-17 22:29\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../sources/guide/android.rst:4
# 3cc0a15f09aa46ebb56ef6130d03f10c
msgid "Kivy on Android"
msgstr ""

#: ../../sources/guide/android.rst:6
# 6a0c4faccdae44d984bbfea280f1d6d6
msgid "Kivy is able to run on android, but you need a phone with:"
msgstr ""

#: ../../sources/guide/android.rst:8
# 7269a9343f674ba7a036da26b08c1999
msgid "SD Card"
msgstr ""

#: ../../sources/guide/android.rst:9
# 8a51972edc2a4d6c9d587b32b3c0be43
msgid "OpenGL ES 2.0 (Android 2.2 minimum)"
msgstr ""

#: ../../sources/guide/android.rst:12
# 83f7cc26064545aeba21d0cda939029d
msgid "Requirements for android application"
msgstr ""

#: ../../sources/guide/android.rst:14
# a753003643034f7985a161f7c4943326
msgid "As soon as you want to do an application for android platform, you must have a file named `main.py` in for root directory of your application, and handling the android platform in the `__name__` test::"
msgstr ""

#: ../../sources/guide/android.rst:22
# ff2e1cc158a24cddac03bf540012421d
msgid "Create an APK"
msgstr ""

#: ../../sources/guide/android.rst:24
# fde66e9a29234a50a706420253a9b84e
msgid "The whole process is described in the :ref:`packaging_android` documentation."
msgstr ""

#: ../../sources/guide/android.rst:28
# ffdb38a362bb4da6b29bab33cf003eb1
msgid "Debugging your application on android platform"
msgstr ""

#: ../../sources/guide/android.rst:30
# 08a5d329747e441188d4bea834612996
msgid "Android SDK ship a tool named adb. Connect your device, and run::"
msgstr ""

#: ../../sources/guide/android.rst:34
# 5bebe80ea3c94fbc8a7714f11d77016d
msgid "You'll see all the log, but also your stdout/stderr, Kivy logger."
msgstr ""

#: ../../sources/guide/android.rst:38
# 8a20bdb87d864d849dc01eaa1d7f145e
msgid "Status of the Project"
msgstr ""

#: ../../sources/guide/android.rst:40
# d44394e070694e1cb87d962e3166b0b3
msgid "This project is a derivated work of Pygame Subset for Android, made by Tom Rothamel. His work is available at::"
msgstr ""

#: ../../sources/guide/android.rst:45
# 7d5604f819d44b3aa6722d4ca1edbb7b
msgid "This project code is available at::"
msgstr ""

#: ../../sources/guide/android.rst:49
# 1dd86684d21246c2bff34c4bf0008c5f
msgid "We made that branch to be able to:"
msgstr ""

#: ../../sources/guide/android.rst:51
# 581c62a23ba34ecd85f8e3bee07d6b06
msgid "integrate Kivy android-support branch in the build"
msgstr ""

#: ../../sources/guide/android.rst:52
# 64efaee0f7f04173b7ef50b18d252edb
msgid "create opengl es 2 surface with stencil buffer"
msgstr ""

#: ../../sources/guide/android.rst:53
# 8fcd2b28e0d34d7aba4563db87cdb78f
msgid "enable multitouch event"
msgstr ""

#: ../../sources/guide/android.rst:54
# 3a754d60e9d04ca5b2c1c0754dbd86d3
msgid "custom python native launcher that run the main.py"
msgstr ""

#: ../../sources/guide/android.rst:55
# afa9d9b059dc480aaf6d955ab330e74e
msgid "default activation of WRITE_EXTERNAL_STORAGE permission"
msgstr ""

#: ../../sources/guide/android.rst:56
# 504f0c5d1dd04b76a77b22928ec6ca0a
msgid "*Video providers* (done in 1.0.8 version using ffmpeg-android)"
msgstr ""

#: ../../sources/guide/android.rst:58
# 1140903a2f6e4acfaf124fbd68256e44
msgid "Currently, Kivy is not fully supported on Android. We are missing:"
msgstr ""

#: ../../sources/guide/android.rst:60
# 9b1912a58e8d45719ab630f1ca8323f2
msgid "Camera providers"
msgstr ""

#: ../../sources/guide/android.rst:61
# d4990c35829b4922902c769c7b971f47
msgid "Audio (can use RenPySound) providers"
msgstr ""

#: ../../sources/guide/android.rst:62
# 5957f94a33c042789a3004b23122499a
msgid "Keyboard mapping for main button"
msgstr ""

#: ../../sources/guide/android.rst:63
# 5716cf247ffc4c869442608596ea9404
msgid "Ability to hook app on sleep/wakeup"
msgstr ""

#: ../../sources/guide/android.rst:66
# ca05845ae6be4a01bc07b26a9dd10384
msgid "Tested Devices"
msgstr ""

#: ../../sources/guide/android.rst:68
# c23a6a2b834f43fba7552623f56fe408
msgid "These Android devices have been confirmed working with Kivy. If your device is not on the list, that does not mean that it is not supported. If that is the case, please try running Kivy and if it succeeds let us know so that we can update this list. Note, however, that your device has to support at least OpenGL 2.0 ES."
msgstr ""

#: ../../sources/guide/android.rst:75
# ed1bf0f0fe9446e0a768db63ce167687
msgid "Phones"
msgstr ""

#: ../../sources/guide/android.rst:77
# b22755859c154fc3a3e2942922fa6a10
msgid "Motorola Droid 1"
msgstr ""

#: ../../sources/guide/android.rst:78
# f7a59ebdbb3f4b40bb4f262ec068fee0
msgid "Motorola Droid 2"
msgstr ""

#: ../../sources/guide/android.rst:79
# 783aaed39f394e35b3d7038b2593bc2b
msgid "HTC Desire"
msgstr ""

#: ../../sources/guide/android.rst:80
# 23efa35bef8e43dfbb17068d7947b66c
msgid "HTC Desire Z"
msgstr ""

#: ../../sources/guide/android.rst:81
# c34225fb0c2d4545b4605e7b5150f974
msgid "Xperia 10 (custom ROM 2.1 + GLES 2.0 support)"
msgstr ""

#: ../../sources/guide/android.rst:84
# 5d58d7daaceb455fa2de7ab9c4a71a69
msgid "Tablets"
msgstr ""

#: ../../sources/guide/android.rst:86
# 032a9be95d1a46b79496955eda79b8c7
msgid "Samsung Galaxy Tab"
msgstr ""

#: ../../sources/guide/android.rst:87
# fec83cc22965438683d9d8dd7c228fbe
msgid "Motorola Xoom"
msgstr ""

#: ../../sources/guide/android.rst:88
# c9474e416e8e429ba06c775616a980a5
msgid "Asus EeePad Transformer"
msgstr ""

#: ../../sources/guide/architecture.rst:4
# a5087298ddd94842863845f0e9cbe44c
msgid "Architectural Overview"
msgstr ""

#: ../../sources/guide/architecture.rst:6
# 662ffb621c774d6b8ea91da4f6142c44
msgid "We would like to take a moment to explain how we designed Kivy from a software engineering point of view. This is key to understanding how everything works together. If you just look at the code, chances are you will get a rough idea already, but since this approach certainly is daunting for most users, this section explains the basic ideas of the implementation in more detail. You can skip this section and refer to it later, but we suggest at least skimming it for a rough overview."
msgstr ""

#: ../../sources/guide/architecture.rst:15
# e27e1af398614ce08cb8aac27cb2d91e
msgid "Kivy consists of several building blocks that we will explain in the following."
msgstr ""

#: ../../sources/guide/architecture.rst:22
# ea1f36a948db47199ce2a87c18dbf401
msgid "Core Providers and Input Providers"
msgstr ""

#: ../../sources/guide/architecture.rst:24
# b0da37147ff243a4916343b2f08623ab
msgid "One idea that is key to understanding Kivy's internals is that of modularity and abstraction. We try to abstract from basic tasks such as opening a window, displaying images and text, playing audio, getting images from a camera, spelling correction and so on. We call these *core* tasks. This makes the API both easy to use and easy to extend. Most importantly, it allows us to use -- what we call -- specific providers for the respective scenario in which your app is being run. For example, on OSX, Linux and Windows, there are different native APIs for the different core tasks. A piece of code that uses one of these specific APIs to talk to the operating system on one side and to Kivy on the other (acting as an intermediate communication layer) is what we call a *core provider*. The advantage of using specialized core providers for each platform is that we can fully leverage the functionality exposed by the operating system and act as efficiently as possible. It also gives users a choice. Furthermore, by using libraries that are shipped with any one platform, we effectively reduce the size of the Kivy distribution and make packaging easier. It's also easier to port Kivy to other platforms. The Android port did greatly benefit from this."
msgstr ""

#: ../../sources/guide/architecture.rst:42
# fd0e7f10d9a7456896b23adebe601d18
msgid "We follow the same concept with input handling. *An input provider* is a piece of code that adds support for a specific input device, such as Apple's trackpads, TUIO or a mouse emulator. If you need to add support for a new input device, you can simply provide a new class that reads your input data from your device and transforms them into Kivy basic events."
msgstr ""

#: ../../sources/guide/architecture.rst:51
# e44c53214c424280a944d5810afb610f
msgid "Graphics"
msgstr ""

#: ../../sources/guide/architecture.rst:53
# b90056677c234883a35ae481818a6a3a
msgid "Kivy's graphics API is our abstraction of OpenGL. On the lowest level, Kivy issues hardware-accelerated drawing commands using OpenGL. Writing OpenGL code however can be a bit confusing, especially to newcomers. That's why we provide the graphics API that lets you draw things using simple metaphors that do not exist as such in OpenGL (e.g. Canvas, Rectangle, etc.)."
msgstr ""

#: ../../sources/guide/architecture.rst:60
# 91f594ded4bf46f1a64ff72fb1d19ebe
msgid "All of our widgets themselves use this graphics API, which is implemented on the C level for performance reasons."
msgstr ""

#: ../../sources/guide/architecture.rst:63
# 0f9a6022f68d41f8997d6b4e57b3e884
msgid "Another advantage of the graphics API is its ability to automatically optimize the drawing commands that your code issues. This is especially helpful if you're not an expert at tuning OpenGL. This makes your drawing code more efficient in many cases."
msgstr ""

#: ../../sources/guide/architecture.rst:68
# 4977ea34d2ba42f79120375015694e52
msgid "You can, of course, still use raw OpenGL commands if you prefer that. The version we target is OpenGL 2.0 ES (GLES2) on all devices, so if you want to stay cross-platform compatible, we advise you to only use the GLES2 functions."
msgstr ""

#: ../../sources/guide/architecture.rst:74
# 970a5f8325eb4b33b1696a8043b6382e
msgid "Core"
msgstr ""

#: ../../sources/guide/architecture.rst:76
# cd84bef2b2ef492eab0e0e1d27d4a95f
msgid "The code in the core package provides commonly used features, such as:"
msgstr ""

#: ../../sources/guide/architecture.rst:79
# cd2da58b8607424f84b34134bd9df2b4
msgid "You can use the clock to schedule timer events. Both one-shot timers and periodic timers are supported"
msgstr ""

#: ../../sources/guide/architecture.rst:83
# 31f26f1421ad4d8eb9b049c3da4750c6
msgid "If you need to cache something that you use often, you can use our class for that instead of writing your own."
msgstr ""

#: ../../sources/guide/architecture.rst:87
# a113c7dab7b94cd9a7730fdab6557faf
msgid "We ship a simple gesture recognizer that you can use to detect various kinds of strokes, such as circles or rectangles. You can train it to detect your own strokes."
msgstr ""

#: ../../sources/guide/architecture.rst:92
# d9ca5047f345433ab12389b456b5a17d
msgid "The kivy language is used to easily and efficiently describe user interfaces."
msgstr ""

#: ../../sources/guide/architecture.rst:96
# a678aeb337084a64b79f3a320663d1f4
msgid "These are not the normal properties that you may know from python. It is our own properties class that links your widget code with the user interface description."
msgstr ""

#: ../../sources/guide/architecture.rst:102
# 8a91339efb404e2b8bfac65437d28fdd
msgid "UIX (Widgets & Layouts)"
msgstr ""

#: ../../sources/guide/architecture.rst:104
# e1f7e794d11f487cb07ad0bd9ae6d686
msgid "The UIX module contains commonly used widgets and layouts that you can reuse to quickly create a user interface."
msgstr ""

#: ../../sources/guide/architecture.rst:108
# d125b2a6236e488f8c52cb2bd334cbc6
msgid "Widgets are user interface elements that you add to your program to provide some kind of functionality. They may or may not be visible. Examples would be a file browser, buttons, sliders, lists and so on. Widgets receive MotionEvents."
msgstr ""

#: ../../sources/guide/architecture.rst:114
# 10e28e5a85664334b62806b4d8b42e85
msgid "You use layouts to arrange widgets. It is of course possible to calculate your widgets' positions yourself, but often it is more convenient to use one of our ready made layouts. Examples would be Grid Layouts or Box Layouts. You can also nest layouts."
msgstr ""

#: ../../sources/guide/architecture.rst:122
# 5153fda4146b48bb872653d18953874d
msgid "Modules"
msgstr ""

#: ../../sources/guide/architecture.rst:124
# 89f2500b874d4eb2823697273374299a
msgid "If you've ever used a modern web browser and customized it with some add-ons then you already know the basic idea behind our module classes. Modules can be used to inject functionality into Kivy programs, even if the original author did not include it."
msgstr ""

#: ../../sources/guide/architecture.rst:129
# cdc47a66a40e406d9284f8988a4f34bd
msgid "An example would be a module that always shows the FPS of the current application and some graph depicting the FPS over time."
msgstr ""

#: ../../sources/guide/architecture.rst:132
# e9de2f94ef58442a8dff7d0243c5ff5a
msgid "You can also write your own modules."
msgstr ""

#: ../../sources/guide/architecture.rst:136
# 839eeba439b249fda7592e76f02a2043
msgid "Input Events (Touches)"
msgstr ""

#: ../../sources/guide/architecture.rst:138
# 778b5b84324b473a870edd6b579b1485
msgid "Kivy abstracts from different input types and sources such as touches, mice, TUIO or similar. What all of these input types have in common is that you can associate a 2D onscreen-position with any individual input event. (There are other input devices such as accelerometers where you cannot easily find a 2D position for e.g. a tilt of your device. This kind of input is handled separately. In the following we describe the former types.)"
msgstr ""

#: ../../sources/guide/architecture.rst:145
# 2c899174edf04378bd841a1de601c203
msgid "All of these input types are represented by instances of the Touch() class. (Note that this does not only refer to finger touches, but all the other input types as well. We just called it *Touch* for the sake of simplicity. Think of it of something that *touches* the user interface or your screen.) A touch instance, or object, can be in one of three states. When a touch enters one of these states, your program is informed that the event occurred. The three states a touch can be in are:"
msgstr ""

#: ../../sources/guide/architecture.rst:155
# 0bffc895a2624b8faa0a57cb78c19821
msgid "A touch is down only once, at the very moment where it first appears."
msgstr ""

#: ../../sources/guide/architecture.rst:158
# e48e6e8b921f49009ff3000e93927b9d
msgid "A touch can be in this state for a potentially unlimited time. A touch does not have to be in this state during its lifetime. A 'Move' happens whenever the 2D position of a touch changes."
msgstr ""

#: ../../sources/guide/architecture.rst:162
# 5f0cecad103a4ade9c696396f150d1a0
msgid "A touch goes up at most once, or never. In practice you will almost always receive an up event because nobody is going to hold a finger on the screen for all eternity, but it is not guaranteed. If you know the input sources your users will be using, you will know whether or not you can rely on this state being entered."
msgstr ""

#: ../../sources/guide/architecture.rst:171
# d7e9ed2a7b2240b79c2ef486047100c7
msgid "Widgets and Event Dispatching"
msgstr ""

#: ../../sources/guide/architecture.rst:173
# 9246331e64ab4a32ba1c70b0554a122f
msgid "The term *widget* is often used in GUI programming contexts to describe some part of the program that the user interacts with. For Kivy, a widget is an object that receives input events. It does not necessarily have to have a visible representation on the screen. All widgets are arranged in a *widget tree* (which is a tree data structure as known from computer science classes): One widget can have any number of child widgets or none. There is exactly one *root widget* at the top of the tree that has no parent widget, and all other widgets are directly or indirectly children of this widget (which is why it's called the root)."
msgstr ""

#: ../../sources/guide/architecture.rst:183
# eff4146b2a4c4d4ab6092020bee42a13
msgid "When new input data is available, Kivy sends out one event per touch. The root widget of the widget tree first receives the event. Depending on the state of the touch, the on_touch_down, on_touch_move or on_touch_up event is dispatched (with the touch as the argument) to the root widget, which results in the root widget's corresponding on_touch_down, on_touch_move or on_touch_up event handler being called."
msgstr ""

#: ../../sources/guide/architecture.rst:191
# 5b040be7401a4ef8ad0abb133e77eaeb
msgid "Each widget (this includes the root widget) in the tree can choose to either digest or pass the event further. If an event handler returns True it means that the event has been digested and handled properly. No further processing will happen with that event. Otherwise, the event handler passes the widget on to its own children by calling its superclass's implementation of the respective event handler. This goes all the way up to the base Widget class, which -- in its touch event handlers -- does nothing but pass the touches to its children::"
msgstr ""

#: ../../sources/guide/architecture.rst:206
# 50e5ff8c4ae2469da730862b7104d111
msgid "This really is much easier than it first seems. An example of how this can be used to create nice applications quickly will be given in the following section."
msgstr ""

#: ../../sources/guide/architecture.rst:210
# 317f5ca2c7ab4f46b74b0c0a4f3a99ab
msgid "Often times you will want to restrict the *area* on the screen that a widget watches for touches. You can use a widget's collide_point() method to achieve this. You simply pass it the touch's position and it returns True if the touch is within the 'watched area' or False otherwise. By default, this checks the rectangular region on the screen that's described by the widget's pos (for position; x & y) and size (width & height), but you can override this behaviour in your own class."
msgstr ""

#: ../../sources/guide/config.rst:2
# 1e52b3336a104334a2a06e6a54ec4bd3
msgid "Configure Kivy"
msgstr ""

#: ../../sources/guide/config.rst:4
# 71445b7035b244ff9e1c470b363b91ea
msgid "The configuration file of kivy is named `config.ini`, following the INI format file."
msgstr ""

#: ../../sources/guide/config.rst:8
# 477f5b481a9f4ab0b24971f011dd839e
msgid "Locating the configuration file"
msgstr ""

#: ../../sources/guide/config.rst:10
# 21cd6d1ec9b24101a40a5f9f7de5051b
msgid "The location of the configuration file is in::"
msgstr ""

#: ../../sources/guide/config.rst:14
# 3a387f3b9a314acb8021fe8187995536
msgid "If your user is named \"tito\", the file will be located at:"
msgstr ""

#: ../../sources/guide/config.rst:16
# ae56bdef3af84c268f99c8967bdca7f7
msgid "Windows: ``C:\\Users\\tito\\.kivy\\config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:17
# b7bfe08d59ea443e8ad7496c4d5e4a04
msgid "MacOSX: ``/Users/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:18
# 3a2be00758274783854de368ba66cdda
msgid "Linux: ``/home/tito/.kivy/config.ini``"
msgstr ""

#: ../../sources/guide/config.rst:22
# d0a4652683b640d8acdc8832dc416bf8
msgid "Understanding config tokens"
msgstr ""

#: ../../sources/guide/config.rst:24
# caef24e46a1f49748b09d9ea384456e4
msgid "All the configuration tokens are explained in the :mod:`kivy.config` module."
msgstr ""

#: ../../sources/guide/designwithkv.rst:7
# 4613a04e21dd4436bc6164ccae29a9ec
msgid "Designing with Kivy language"
msgstr ""

#: ../../sources/guide/designwithkv.rst:9
# c27db54957cc4df796f4ef6732f68a0e
msgid "Let's start with a little example. First, the Python file named `main.py`:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:14
# 606ef8b5dc8641dab13760bbc8d740fc
msgid "In this example, we are creating a Controller class, with 2 properties:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:16
# 3fb1ef0db9044d079f8cf7486aad1b32
msgid "`info` for receving some text"
msgstr ""

#: ../../sources/guide/designwithkv.rst:17
# d8b342db4ba943d5a28ebc849fa04a12
msgid "`label_wid` for receving the label widget"
msgstr ""

#: ../../sources/guide/designwithkv.rst:19
# 59ed067ad5ad4a4d9983c94422e9798f
msgid "In addition, we are creating a `do_action()` method, that will use both of theses properties: change the `info` text, and use `label_wid` to change the content of the label with a nex text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:23
# 58967ad3f6864c60ba3cd77db910375a
msgid "If you execute that application without kv, it will work... but nothing will be showed on the screen. That's normal: `Controller` class have no widget in it, it's just a Layout. We can now create a kv file and create the UI around the `Controller` class in a file named `controller.kv`. The relation between the previous file and the kv is described in the :class:`kivy.app.App` class."
msgstr ""

#: ../../sources/guide/designwithkv.rst:32
# 3ee8feef69434222871719228744936a
msgid "Yes, one label and one button in a vertical boxlayout. Seem very simple. Now, we have 2 things here:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:34
# 96d14f0ee4ac4a8bbcad713623814624
msgid "Use data from `Controller`: that's the goal of `info` property: as soon as the property is changed in the controller, the kv part that use it will be automatically re-evaluated, and change the button text."
msgstr ""

#: ../../sources/guide/designwithkv.rst:38
# 97130af3b58c4301ab7cbf1a9a58e6cc
msgid "Give data to `Controller`: the first assignation `label_wid: my_custom_label` is to assign a new value to the `label_wid` property. Using id, you can give the instance of one of your widget to the `Controller`."
msgstr ""

#: ../../sources/guide/designwithkv.rst:43
# 9878f9f9ceb24fdfb72dd9ff5bee9235
msgid "Also, we are creating a custom callback in the `Button` using `on_press`. Remember that:"
msgstr ""

#: ../../sources/guide/designwithkv.rst:45
# 66fe63ea13164040bbb871879d300cd2
msgid "`root` and `self` are 2 reserved keyword, that can be used anywhere for evaluation. `root` represent the top widget in the rule and `self` represent the current widget."
msgstr ""

#: ../../sources/guide/designwithkv.rst:49
# a8754446faa045f6bb3d5ce9ee522535
msgid "you can use any id declared in the rule same as `root` and `self`. For example, you could do in on_press::"
msgstr ""

#: ../../sources/guide/environment.rst:4
# 1f7022f78a594636adcd24f0bcfa933b
msgid "Controling the environment"
msgstr ""

#: ../../sources/guide/environment.rst:6
# 4f937c169c064d678345a7957516db7c
msgid "Many environment variables are available to control the initialization and behavior of Kivy."
msgstr ""

#: ../../sources/guide/environment.rst:9
# 8bdea725655e44a8bad0af2ffdcf5dd7
msgid "For example, for restricting text rendering to cairo implementation::"
msgstr ""

#: ../../sources/guide/environment.rst:13
# 6bc78600ec454465894c5a0c649789c8
msgid "Environment variable can be set before importing kivy::"
msgstr ""

#: ../../sources/guide/environment.rst:20
# 05f0f67386384642968f550ddcfbc9cb
msgid "Configuration"
msgstr ""

#: ../../sources/guide/environment.rst:23
# 68d4c152782d4286a2fe230166d56bb3
msgid "If this name is found in environ, Kivy will not read the user config file."
msgstr ""

#: ../../sources/guide/environment.rst:26
# 74abd6b34f78454da6a09fdf5510f55e
msgid "Path control"
msgstr ""

#: ../../sources/guide/environment.rst:30
# 4b5c97d9dd8144f1a870a08eb2bd9a01
msgid "You can control where is located default directory of modules, extensions, and kivy datas."
msgstr ""

#: ../../sources/guide/environment.rst:34
# 0fdcd9a4ef9f43a28db16ad267822870
msgid "Location of the Kivy data, default to `<kivy path>/data`"
msgstr ""

#: ../../sources/guide/environment.rst:37
# 6c6a9c9ebce14c9a879ea9432f2ad677
msgid "Location of the Kivy extensions, default to `<kivy path>/extensions`"
msgstr ""

#: ../../sources/guide/environment.rst:40
# 5cf054b95142417f8eeb8967a978d35d
msgid "Location of the Kivy modules, default to `<kivy path>/modules`"
msgstr ""

#: ../../sources/guide/environment.rst:43
# 3ca2676f749f4bdba631a912fa7b1578
msgid "Restrict core to specific implementation"
msgstr ""

#: ../../sources/guide/environment.rst:45
# d395ffc19e8d4de6bc6c7ce29107aa6e
msgid ":mod:`kivy.core` try to select the best implementation available for your platform. For testing or custom installation, you might want to restrict the selector to a specific implementation."
msgstr ""

#: ../../sources/guide/environment.rst:50
# 0fc7187cf192471dbf5f5f48ccb70b62
msgid "Implementation to use for creating the Window"
msgstr ""

#: ../../sources/guide/environment.rst:52
# ef9065d84dc04c1982d6e99e3bb7574f
msgid "Values: pygame"
msgstr ""

#: ../../sources/guide/environment.rst:55
# c96fc670e9b543f8a2396594dd6a8c5c
msgid "Implementation to use for rendering text"
msgstr ""

#: ../../sources/guide/environment.rst:57
# f7d25aa3f0294daa9dcfb02753cf3921
msgid "Values: pil, cairo, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:60
# e1c3cb7702844d18aeaac1bb0507db80
msgid "Implementation to use for rendering video"
msgstr ""

#: ../../sources/guide/environment.rst:62
# 2e05b192671d44d293c89419cb0e8b5d
msgid "Values: gstreamer, pyglet, ffmpeg"
msgstr ""

#: ../../sources/guide/environment.rst:65
# f573f750b46f4af8aebaaad4bce35dba
msgid "Implementation to use for playing audio"
msgstr ""

#: ../../sources/guide/environment.rst:67
# d42a425620cb415fb29ee31bb6e89ff2
msgid "Values: gstreamer, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:70
# 126a8af911bc43e288da2d19f9340630
msgid "Implementation to use for reading image"
msgstr ""

#: ../../sources/guide/environment.rst:72
# 9f2b0eefcf344b51b1e73084ba23515d
msgid "Values: pil, pygame"
msgstr ""

#: ../../sources/guide/environment.rst:75
# b486e60cb6a741029a836e521594b240
msgid "Implementation to use for reading camera"
msgstr ""

#: ../../sources/guide/environment.rst:77
# 830e7b5f13d646daa31e03b1b31a46c8
msgid "Values: gstreamer, opencv, videocapture"
msgstr ""

#: ../../sources/guide/environment.rst:80
# 996666b1507f4196a0662e35b2773828
msgid "Implementation to use for spelling"
msgstr ""

#: ../../sources/guide/environment.rst:82
# 259262c5453043999b7bee99e2b9fe7d
msgid "Values: enchant, osxappkit"
msgstr ""

#: ../../sources/guide/environment.rst:85
# 4254716001044142ac5fb64b7cdd51a0
msgid "Implementation to use for clipboard management"
msgstr ""

#: ../../sources/guide/environment.rst:87
# 5b20c1c7779846a58e62458bd3e40ce5
msgid "Values: pygame, dummy"
msgstr ""

#: ../../sources/guide/events.rst:2
# 417bf015d1f14779940ca0eca99438f2
msgid "Events"
msgstr ""

#: ../../sources/guide/events.rst:4
# 6b4f449834004f78acb133a7f3d462a0
msgid "You have 2 types of events living in Kivy:"
msgstr ""

#: ../../sources/guide/events.rst:6
# 390dfb45d8614edea140fb0bb0c9cbbc
msgid "Clock events: if you want to call a function X times per seconds, or if you want to call a function later."
msgstr ""

#: ../../sources/guide/events.rst:8
# d95cc7e050d3421cbb4e7c1bb160992c
msgid "Widget events: if you want to call a function where something change in the widget, or attach a function to a widget specific event."
msgstr ""

#: ../../sources/guide/events.rst:13
# 603383a9190f41ecab1e4c1102be674a
msgid "Clock events"
msgstr ""

#: ../../sources/guide/events.rst:15
# ef7ccb26bad943b9b7d0b709fcdeadbf
msgid "Before starting the event part, Kivy have a main loop, and must avoid to break it. The main loop is responsible to read all the inputs, load images asynchronously, draw the frame etc. If you are looping yourself or sleeping somewhere, you'll break the main loop. For example, here is the biggest mistake done::"
msgstr ""

#: ../../sources/guide/events.rst:25
# b361abb8ac9e47edbc4dbe7e8af133db
msgid "This is wrong. Because you'll never go out of your loop, and you'll see a black window, no more interaction. You need to \"schedule\" the call of your function over the time. You can schedule it in 2 way: repetitive call or one-time call."
msgstr ""

#: ../../sources/guide/events.rst:30
# fd7dd26833e3414b83b988788c1c8b14
msgid "Scheduling an repetitive event"
msgstr ""

#: ../../sources/guide/events.rst:32
# 2c6f504f996b4c9e9cbb1ba37bce2711
msgid "You can call a function or a method every X times per seconds using :meth:`~kivy.clock.Clock.schedule_interval`. Here is an example of calling a function named my_callback 30 times per seconds::"
msgstr ""

#: ../../sources/guide/events.rst:40
# c059337cf27f4760a5af4e8b20b0cc33
msgid "You have 2 ways of unschedule a previously scheduled event. The first would be to use :meth:`~kivy.clock.Clock.unschedule`::"
msgstr ""

#: ../../sources/guide/events.rst:45
# 1f7831fbaeb44cb48dd64e8eaf031319
msgid "Or, you can return False in your callback, and your event will be automatically unschedule::"
msgstr ""

#: ../../sources/guide/events.rst:60
# 8eb65c4310354122a954c90912d4a8e8
msgid "Scheduling an one-time call event"
msgstr ""

#: ../../sources/guide/events.rst:62
# 7a3303865b5d474bb34b283fba079050
msgid "Sometime, you can to call a function \"later\", like in the next frame, or in X seconds. Use :meth:`~kivy.clock.Clock.schedule_once`::"
msgstr ""

#: ../../sources/guide/events.rst:69
# 8771a8d7abc34d4f85ef403eb1da6e69
msgid "This will call the callback one second after. The second argument is the time to call the function, but you have achieve tiny tricks here :"
msgstr ""

#: ../../sources/guide/events.rst:72
# 60c2c633d40d4170927bf1704ef6f110
msgid "If it's more than 0, the callback will be called in the X seconds"
msgstr ""

#: ../../sources/guide/events.rst:73
# 99e38700a24b48bda31616d72559447c
msgid "If it's 0, the callback will be called in the next frame, before the drawing"
msgstr ""

#: ../../sources/guide/events.rst:74
# 26eaccd084814ff191090966102307f9
msgid "If it's -1, the callback will be called before the drawing, if the clock is not overflooded"
msgstr ""

#: ../../sources/guide/events.rst:77
# e2d83fa66cc54978a47ad416fd2c63eb
msgid "The -1 is mostly used when you are already is a scheduled event, and if you want to schedule a call BEFORE the next frame is happening."
msgstr ""

#: ../../sources/guide/events.rst:82
# 295b585041cb4e72bef6817417917144
msgid "Trigger events"
msgstr ""

#: ../../sources/guide/events.rst:84
# e4ad50958c834ede9636cc7548b9e84c
msgid "If you want to have schedule a call only \"one time\" for the next frame, the trigger events is for you. Before, triggering can be achieve with::"
msgstr ""

#: ../../sources/guide/events.rst:90
# d827321f37b247a19568db6906f69e10
msgid "That way of doing trigger is expensive, because you'll always call unschedule whatever if the event is already scheduled or not. In addition, it need to iterate into the weakref list of the Clock to found your callback, and remove it. Don't do that. Use trigger::"
msgstr ""

#: ../../sources/guide/events.rst:99
# 15296283cc9949189f3c870857f3e01f
msgid "Each time you'll call trigger, it will schedule a call of your callback, only one. If the schedule was already done, it will be ignored."
msgstr ""

#: ../../sources/guide/events.rst:106
# bb0f21d5f5614943bb261b33763ea134
msgid "Widget events"
msgstr ""

#: ../../sources/guide/events.rst:108
# d39590dfed8d4c3183d8e0fc62fc4bca
msgid "A widget have 2 types of events:"
msgstr ""

#: ../../sources/guide/events.rst:110
# 68d57c402bbc458182cedb60d07a9d79
msgid "Property event: if your widget change of pos or size, you'll have an event fired"
msgstr ""

#: ../../sources/guide/events.rst:112
# f5a1a97f06104fc281444db8ee81a8c4
msgid "Widget defined event: a Button will have even fired when it's pressed or released."
msgstr ""

#: ../../sources/guide/events.rst:117
# c6b3b0aab7c04c8e83096c213181bfeb
msgid "Property event"
msgstr ""

#: ../../sources/guide/events.rst:119
# d4a663e02fb64a3ebed4e0f6f374216c
msgid "A widget have many property. You'll find in the doc that every property have a type like :class:`~kivy.properties.NumericProperty`, :class:`~kivy.properties.StringProperty`, :class:`~kivy.properties.ListProperty`."
msgstr ""

#: ../../sources/guide/events.rst:124
# 485c9fc3d2c84a14a2ee91da29b85bee
msgid "Usualy, when you want to create a Python class with properties, you'll do something like this::"
msgstr ""

#: ../../sources/guide/events.rst:131
# 7f5fddc0a0e5444e969db6611205185e
msgid "By doing that, you have not a good way to know when the prop1 is changed, except by rewriting the class and hook the __getattribute__. But we'll not get into details here. The Kivy way is that::"
msgstr ""

#: ../../sources/guide/events.rst:138
# e8fd3310d51043f1a55771dd20b00021
msgid "You can connect a function to that property if you willing to be called when the value of the property change::"
msgstr ""

#: ../../sources/guide/events.rst:151
# fa72ffb3f3e549d78bdd717f10ad4761
msgid "If you want to resign of receiving event from prop1 property, call unbind::"
msgstr ""

#: ../../sources/guide/events.rst:157
# 96ec5ad32af84ea9b19dc2d7ea6bc392
msgid "Widget defined event"
msgstr ""

#: ../../sources/guide/events.rst:159
# 81414ce1119b493695cf79121d3f5e05
msgid "Sometime, the properties event is not enought to hook on it. For example, a Button can have a state property that will indicate if the Button is currently pressed or not (\"down \" or \"normal\" actually). We make the choice to add additionnals event for that: :meth:`~kivy.uix.button.Button.on_press` and :meth:`~kivy.uix.button.Button.on_release` event::"
msgstr ""

#: ../../sources/guide/events.rst:170
# 033fe0df25dc48d4bc71ca64381a3b5e
msgid "Every widget defined event are in the documentation, at the start of the widget class. You can find a list of widget defined event that the widget support."
msgstr ""

#: ../../sources/guide/events.rst:173
# a7fce4bc7a8f48abbdda42fb3454b100
msgid "If are designing your own widget, you can create your own widget event by using the :meth:`~kivy.event.register_event_type`::"
msgstr ""

#: ../../sources/guide/events.rst:185
# 4eb87618ce99448392611074485f0f10
msgid "Then, the user can hook on it, same as the Button.on_press event. But the event is never dispatched here. Let's just add a function for demonstrating how to dispatch a widget defined event::"
msgstr ""

#: ../../sources/guide/events.rst:196
# be02c75f238a40dab032f1b8a8de2675
msgid "Now, everytime you'll call do_something() method, it will dispatch on_custom_event, and call every function attached to this event."
msgstr ""

#: ../../sources/guide/firstwidget.rst:7
# ce93ae45dbd543daaa9fd622773e6646
msgid "Your First Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:9
# f8bb30c811aa4a488e0922ef65055fcf
msgid "In the following you will be guided through the creation of your first widget. This is some very powerful and important knowledge when programming Kivy applications, as it lets you create completely new user interfaces with custom elements for your specific purpose."
msgstr ""

#: ../../sources/guide/firstwidget.rst:16
# abbd3ccf99174e52bd2c7e1390890178
msgid "Basic Considerations"
msgstr ""

#: ../../sources/guide/firstwidget.rst:18
# f60c391e494b419a84db3390b3effba5
msgid "When creating an application, you have to ask yourself three main questions:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:20
# 4480be446d3346469db05407b8625e95
msgid "What data does my application process?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:21
# 619d6e1516384751bd07f5c53afabceb
msgid "How do I visually represent that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:22
# 07528b74db2544d6800152bb4045e05a
msgid "How does the user interact with that data?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:24
# 1c677314472a4df59d23f02de90152ca
msgid "If you want to write a very simple line drawing application for example, you most likely want the user to just draw on the screen with his fingers. That's how the user *interacts* with your application. While doing so, your application would memorize the positions where the user's finger was, so that you can later draw lines between those positions. So the points where the fingers were would be your *data* and the lines that you draw between these would be your *visual representation*."
msgstr ""

#: ../../sources/guide/firstwidget.rst:32
# eb823952a5854ed9bea3f721651dee9d
msgid "In Kivy, an applications user interface is composed of Widgets. Everything that you see on the screen is somehow drawn by a widget. Often you would like to be able to reuse code that you already wrote in a different context, which is why widgets typically represent one specific instance that answers the three questions above. A widget encapsulates data, defines the user's interaction with that data and draws its visual representation. You can then build anything from simple to complex user interfaces by nesting widgets. There are many widgets built in, such as buttons, sliders and other common stuff. In many cases, however, you need a custom widget that is beyond the scope of what is shipped with Kivy (e.g. a medical visualization widget)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:45
# be5b74f6f9654d428589c1c467fd9373
msgid "So keep these three questions in mind when you design your widgets. Try to write them in a minimal and reusable manner (I.e. a widget does exactly what its supposed to do and nothing more. If you need more, write more widgets or compose other widgets of smaller widgets)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:52
# 8103903c18da4b80bf625a058927cdc3
msgid "Paint Widget"
msgstr ""

#: ../../sources/guide/firstwidget.rst:54
# da1fda4dfe444039b35bcf55376ceba2
msgid "We're sure one of your childhood dreams has always been creating your own multitouch paint program. Allow us to help you achieve that. In the following sections you will successively learn how to write a program like that using Kivy. Make sure that you have read and understood :ref:`quickstart`. You have? Great! Let's get started!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:63
# 774f062460eb4023a46d91300f1dcad7
msgid "Initial Structure"
msgstr ""

#: ../../sources/guide/firstwidget.rst:65
# 5b6679310e034466b1130985cdf72436
msgid "Let's start by writing the very basic code structure that we need.  By the way, all the different pieces of code that are used in this section are also available in the ``examples/guide/firstwidget`` directory that comes with Kivy, so you don't need to copy & paste it all the time. Here is the basic code skeleton that we will need:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:75
# 4a8f1ac37dc34f67892d2726e7f5bca1
msgid "This is actually really simple. Save it as paint.py. If you run it, you should only see a black screen. As you can see, instead of using a built-in widget such as Button (see :ref:`quickstart`), we are going to write our own widget to do the drawing. We do that by creating a class that inherits from :class:`~kivy.uix.widget.Widget` (line 5-6) and although that class does nothing yet, we can still treat it like a normal Kivy widget (line 11). The ``if __name__ ...`` construct (line 14) is a Python mechanism that prevents you from executing the code in the if-statement when importing from that file, i.e. if you write ``import paint``, it won't do something unexpected but just nicely provide the classes defined in the file."
msgstr ""

#: ../../sources/guide/firstwidget.rst:89
# 723cd3d7a2804c1ea6e083b1d71343b5
msgid "You may be wondering why you have to import App and Widget separately, instead of doing something like ``from kivy import *``. While shorter, this would have the disadvantage of cluttering your namespace and making the start of the application potentially much slower. It's also not as clear what your application uses. The way we do it is faster and cleaner."
msgstr ""

#: ../../sources/guide/firstwidget.rst:98
# f811b593c09b40b48d9282a89f3897ad
msgid "Adding Behaviour"
msgstr ""

#: ../../sources/guide/firstwidget.rst:100
# 1bb6e23dc7444e04bf13fd9c1ae650d1
msgid "Let's now add some actual behaviour to the widget, i.e. make it react to user input. Change the code like so:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:107
# b9e0ef2d05a34a9bbcbd1f95f2552063
msgid "This is just to show you how easy it is to react to user input. When a :class:`~kivy.input.motionevent.MotionEvent` (i.e. a touch, click, etc.) occurs, we simply print the information about the touch object to the console. You won't see anything on the screen, but if you observe the command-line from which you are running the program, you will see a message for every touch (initially). This also demonstrates that a widget does not always have to have a visual representation."
msgstr ""

#: ../../sources/guide/firstwidget.rst:115
# bc7913e7cd5b40ca926dd3d85fdd339c
msgid "Now that's not really an overwhelming user experience. Let's add some code that actually draws something into our window:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:124
# ee0567ad915e4249b75ded8d5f33b36e
msgid "If you run your code with these modifications, you will see that every time you touch, there will be a small yellow circle drawn where you touched. How does it work?"
msgstr ""

#: ../../sources/guide/firstwidget.rst:128
# 79997b752edb460284580b886999b967
msgid "Line 8: We use Python's ``with`` statement with the widget's :class:`~kivy.graphics.instructions.Canvas` object. This is like an area in which the widget can draw things to represent itself on the screen. By using the ``with`` statement with it, all successive drawing commands that are properly indented will modify this canvas. The ``with`` statement also makes sure that after our drawing, internal state can be cleaned up properly."
msgstr ""

#: ../../sources/guide/firstwidget.rst:135
# c1701d45d8d54ba9ab6ff457c7e03a00
msgid "Line 9: You might have guessed it already: This sets the :class:`~kivy.graphics.context_instructions.Color` for successive drawing operations to yellow (default color format is RGB, so (1, 1, 0) is yellow). This is true until another color is set. Think of this as dipping your brushes in that color which you can then use to draw on a canvas until you dip the brushes into another color."
msgstr ""

#: ../../sources/guide/firstwidget.rst:141
# 48f1839f267e4bc7a69ab39c69e41b34
msgid "Line 10: We specify the diameter for the circle that we are about to draw. Using a variable for that is preferable since we need to refer to that value multiple times and we don't want to have to change it in several places if we want the circle bigger or smaller."
msgstr ""

#: ../../sources/guide/firstwidget.rst:145
# 288d3903cc5b4d508a731b3a23b69402
msgid "Line 11: To draw a circle, we simply draw an :class:`~kivy.graphics.vertex_instructions.Ellipse` with equal width and height. Since we want the circle to be drawn where the user touches, we pass the touch's position to the ellipse. Note that we need to shift the ellipse by ``-d/2`` in the x and y directions (i.e. left and downwards) because the position specifies the bottom left corner of the ellipse's bounding box, and we want it to be centered around our touch."
msgstr ""

#: ../../sources/guide/firstwidget.rst:155
# fc4b52bbb464417fb85f0ef8f3aa48e6
msgid "That was easy, wasn't it? It gets better! Update the code to look like this:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:165
# e9b8ee8b2c4e4fe8924cd530506ab59e
msgid "Line 3: We now not only import the :class:`~kivy.graphics.vertex_instructions.Ellipse` drawing instruction, but also the :class:`~kivy.graphics.vertex_instructions.Line` drawing instruction. If you look at the documentation for :class:`~kivy.graphics.vertex_instructions.Line`, you will see that it accepts a ``points`` argument that has to be a list of 2D point coordinates, like ``(x1, y1, x2, y2, ..., xN, yN)``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:172
# 9f60873d537b422d9f9f1b4453166b9c
msgid "Line 8: This is where it gets interesting. ``touch.ud`` is a Python dictionary (type <dict>) that allows us to store *custom attributes* for a touch. On this line we simply get a reference to it to make it more clear that ``ud`` stands for ``userdata``. You could just as well write ``touch.ud`` instead of ``userdata``."
msgstr ""

#: ../../sources/guide/firstwidget.rst:177
# c2307a1abe72450c9d117a62df75e0ae
msgid "Line 13: We make use of the Line instruction that we imported and set a Line up for drawing. Since this is done in ``on_touch_down``, there will be a new line for every new touch. By creating the line inside the ``with`` block, the canvas automatically knows about the line and will draw it. We just want to modify the line later, so we store a reference to it in the ``userdata`` dictionary under the arbitrarily chosen but aptly named key 'line'. We pass the line that we're creating the initial touch position because that's where our line will begin."
msgstr ""

#: ../../sources/guide/firstwidget.rst:186
# 3252bfed4ea542bfa1e64323823da69a
msgid "Lines 15: We add a new method to our widget. This is similar to the ``on_touch_down`` method, but instead of being called when a *new* touch occurs, this method is being called when an *existing* touch (for which ``on_touch_down`` was already called) moves, i.e. its position changes. Note that this is the **same** :class:`~kivy.input.motionevent.MotionEvent` object with updated attributes. This is something we found incredibly handy and you will shortly see why."
msgstr ""

#: ../../sources/guide/firstwidget.rst:194
# 652f19cf106142b082b3e076800968ef
msgid "Line 16: Remember: This is the same touch object that we got in ``on_touch_down``, so we can simply access the data we stored away in the userdata dictionary! To the line we set up for this touch earlier, we now add the current position of the touch as a new point. We know that we need to extend the line because this happens in ``on_touch_move``, which is only called when the touch has moved, which is exactly why we want to update the line. Storing the line in the userdata makes it a whole lot easier for us as we don't have to maintain our own touch-to-line bookkeeping."
msgstr ""

#: ../../sources/guide/firstwidget.rst:207
# 994c5f2252774a869a28243be1859cd8
msgid "So far so good. This isn't exactly beautiful yet, though. It looks a bit like spaghetti bolognese. What about we give each touch its own color? Great, let's do it:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:217
# a82111760f254516a14ac1d21bf6c6eb
msgid "Here are the changes:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:219
# f1aed40496694dcb81c671325229ab2a
msgid "Line 1: We import Python's random() function that will give us random values in the range of [0., 1.)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:221
# 62f3a92a7fdd40b780f28c20f9dc7936
msgid "Line 10: We want to memorize the color for this touch, so we store it in the touch's userdata dictionary. In this case we simply create a new tuple of 3 random float values that will represent a random RGB color. Since we do this in ``on_touch_down``, every new touch will get its own color. Don't get confused by the use of two ``=`` operators. We're just binding the tuple to ``c`` as well as a shortcut for use within this method because we're lazy."
msgstr ""

#: ../../sources/guide/firstwidget.rst:229
# ec53e68a100544dd81247ec920f2f32f
msgid "Line 12: As before, we set the color for the canvas. Only this time we use the random values we generated and feed them to the color class using Python's tuple unpacking syntax (since the Color class expects three individual color components instead of just 1. If we were to pass the tuple directly, that would be just 1 value being passed, regardless of the fact that the tuple itself contains 3 values)."
msgstr ""

#: ../../sources/guide/firstwidget.rst:238
# 407580b582f74620b0ce65658579bcb2
msgid "This looks a lot nicer already! With a lot of skill and patience, you might even be able to create a nice little drawing!"
msgstr ""

#: ../../sources/guide/firstwidget.rst:242
# 4ad8ad1bf5be426ea4bf1d1c831e4790
msgid "Since by default the :class:`~kivy.graphics.context_instructions.Color` instructions assume RGB mode and we're feeding a tuple with three random float values to it, it might very well happen that we end up with a lot of dark or even black colors if we are unlucky. That would be bad because by default the background color is dark as well, so you wouldn't be able to (easily) see the lines you draw. There is a nice trick to prevent this: Instead of creating a tuple with three random values, create a tuple like this: ``(random(), 1., 1.)``. Then, when passing it to the color instruction, set the mode to HSV color space: ``Color(*c, mode='hsv')``. This way you will have a smaller number of possible colors, but the colors that you get will always be equally bright. Only the hue changes."
msgstr ""

#: ../../sources/guide/firstwidget.rst:257
# 7da5c6c55bed4c159e1f0f7a37da9e1e
msgid "Bonus Points"
msgstr ""

#: ../../sources/guide/firstwidget.rst:259
# 74f2e7859ac94df1866dc209f6a9123f
msgid "At this point, we could say we are done. The widget does what it's supposed to do: It traces the touches and draws lines. It even still draws circles at the positions where a line begins."
msgstr ""

#: ../../sources/guide/firstwidget.rst:263
# d269cbc19e944fb39eac4ea434950a9a
msgid "But what if the user wants to start a new drawing? With the current code, the only option to clear the window would be to restart the entire application. Luckily, we can do better. Let us add a *Clear* button that erases all the lines and circles that have been drawn so far. There are two options now:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:270
# 259cdad66d25497b8312f2345ceca3c4
msgid "We could either create the button as a child of our widget. That would imply that if you create more than one widget, every widget gets its own button. If you're not careful, this will also allow users to draw on top of the button, which might not be what you want."
msgstr ""

#: ../../sources/guide/firstwidget.rst:274
# 50237941ff0c40cba14ea45263077634
msgid "Or we set up the button only once, initially, in our app class and when it's pressed we clear the widget."
msgstr ""

#: ../../sources/guide/firstwidget.rst:277
# c30d55f8c6e54c7d9b21c68c03e37116
msgid "For our simple example, that doesn't really matter at all. For larger applications you should give some thought to who does what in your code. We'll go with the second option here so that you see how you can build up your application's widget tree in your app class's :meth:`~kivy.app.App.build` method. We'll also change to the HSV color space (see preceding note):"
msgstr ""

#: ../../sources/guide/firstwidget.rst:289
# 1996fca150a54f53afdd70b839e1d120
msgid "Here's what happens:"
msgstr ""

#: ../../sources/guide/firstwidget.rst:291
# c1758e2a0f3e473c87601d013a3315c3
msgid "Line 4: We added an import statement to be able to use the :class:`~kivy.uix.button.Button` class."
msgstr ""

#: ../../sources/guide/firstwidget.rst:293
# 0e6f4acf667e44c5a97a79211a1ecade
msgid "Line 24: We create a dummy ``Widget()`` object as a parent for both our painting widget and the button we're about to add. This is just a poor-man's approach to setting up a widget tree hierarchy. We could just as well use a layout or do some other fancy stuff. Again: This widget does absolutely nothing except holding the two widgets we will now add to it as children."
msgstr ""

#: ../../sources/guide/firstwidget.rst:299
# 18f396accb874d23840c5cc3cfb4dc5b
msgid "Line 25: We create our ``MyPaintWidget()`` as usual, only this time we don't return it directly but bind it to a variable name."
msgstr ""

#: ../../sources/guide/firstwidget.rst:301
# 7b4df111997748a5a0eb8102b8a82ccb
msgid "Line 26: We create a button widget. It will have a label on it that displays the text 'Clear'."
msgstr ""

#: ../../sources/guide/firstwidget.rst:303
# 010e617f2afc49f59ca285a06d07c235
msgid "Line 27 & 28: We set up the widget hierarchy by making both the painter and the clear button children of the dummy parent widget. That means painter and button are now siblings in the usual computer science tree terminology."
msgstr ""

#: ../../sources/guide/firstwidget.rst:307
# 5d11ee9ccc61408c9d17255ffd65303c
msgid "Lines 30 & 31: Up to now, the button did nothing. It was there, visible, and you could press it, but nothing would happen. We change that here: We create a small throw-away function that is going to be our callback function which is called when the button is pressed. The function just clears the painter's canvas' contents, making it black again."
msgstr ""

#: ../../sources/guide/firstwidget.rst:313
# 73d7f6dc57284ff5ad0ebea20348ddc3
msgid "Line 32: We bind the button's on_release event (which is fired when the button is pressed and then released) to the callback we just defined."
msgstr ""

#: ../../sources/guide/firstwidget.rst:317
# bfab0f62e82e496eb114eef7f1ca28d8
msgid "Congratulations! You've written your first Kivy widget. Obviously this was just a quick introduction. There is much more to discover. We suggest taking a short break to let what you just learned sink in. Maybe draw some nice pictures to relax? If you feel like you've understood everything and are ready for more, we encourage you to read on."
msgstr ""

#: ../../sources/guide/inputs.rst:2
# 72d2c7ed48e2413c966db68df3cde0e8
msgid "Input management"
msgstr ""

#: ../../sources/guide/inputs.rst:5
# 3df3eb02e6db4c43b766a19d9875a687
msgid "Input architecure"
msgstr ""

#: ../../sources/guide/inputs.rst:7
# 3a06ef9babd34d5098d531d7d349a68e
msgid "Kivy is able to handling almost all types of inputs: mouse, touchscreen, accelerator, gyroscope, etc. It handle natively multitouch protocol on every platforms: Tuio, WM_Touch, MacMultitouchSupport, MT Protocol A/B, Android."
msgstr ""

#: ../../sources/guide/inputs.rst:11
# ea159817f82c425f84187fa58a788b72
msgid "The global architecture can be resumed like that::"
msgstr ""

#: ../../sources/guide/inputs.rst:15
# b97cd007709449d393b1a5c3a52490be
msgid "The class for all input events is the :class:`~kivy.input.motionevent.MotionEvent`. From this, they are 2 kinds of events:"
msgstr ""

#: ../../sources/guide/inputs.rst:19
# 3ce2483f30714050ab2612cc44f3bb68
msgid "Touch events: it's a motion event that contain at least X and Y position. All the touch events are dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:21
# 6d0221daf2654d009f7ed75a619de1dd
msgid "No-touch events: it's all the rest. For example, accelerator is a continuous event, without position. It never start or stop. Theses events are not dispatched accross the Widget tree."
msgstr ""

#: ../../sources/guide/inputs.rst:26
# 1728c91dfb434e87b1c373814c794ac4
msgid "A Motion event is generated by a Input Provider. An input provider is responsible of reading the input event of one operating system, from the network of even from another application. Severals inputs providers exist, like:"
msgstr ""

#: ../../sources/guide/inputs.rst:28
# 6a32fbf885864b80b03623b45ec0214b
msgid ":class:`~kivy.input.providers.tuio.TuioMotionEventProvider`: create an UDP server and listening for TUIO/OSC message."
msgstr ""

#: ../../sources/guide/inputs.rst:30
# e0627ec4e8b6400ba13212a79f818746
msgid ":class:`~kivy.input.providers.wm_touch.WM_MotionEventProvider`: use the windows API for reading multitouch information and sending back to Kivy"
msgstr ""

#: ../../sources/guide/inputs.rst:32
# 725d3f21b4c84d42afb9a3f0dd273ab3
msgid ":class:`~kivy.input.providers.probesysfs.ProbeSysfsHardwareProbe`: iterate over all the hardaware connected to the computer on linux, and attach multitouch input provider for all the multitouch hardware found."
msgstr ""

#: ../../sources/guide/inputs.rst:35
# ebd11654e2914dc0bf2866edc3fd8db8
msgid "and lot more !"
msgstr ""

#: ../../sources/guide/inputs.rst:37
# d013753e2ed04bccb60a333f08da4660
msgid "When you write an application, you don't need to create input provider. Kivy try to detect automatically the hardware available on the user computer. If the user want to support custom hardware, he will configure kivy to make it work."
msgstr ""

#: ../../sources/guide/inputs.rst:39
# b3adf32b5c3546a2a9ffb86463288845
msgid "Before the newly Motion Event is passed to the user, we are applying Input post-processors. For every motion event, we are analysis them to detect and correct the inputs like:"
msgstr ""

#: ../../sources/guide/inputs.rst:41
# 2f7ba0e362d74837b8042ff005088436
msgid "the detection of a double-tap according to a distance and time threshold"
msgstr ""

#: ../../sources/guide/inputs.rst:42
# 567f850ff6cb4bacb2479cb266d02872
msgid "correcting events when the hardware is not accurate"
msgstr ""

#: ../../sources/guide/inputs.rst:43
# a8ec5e8778a04cafa73ea123a516808c
msgid "reducing the amount of event if the touch is sending nearly the same position"
msgstr ""

#: ../../sources/guide/inputs.rst:46
# 6897dd83ed74439e9c9c727292a11659
msgid "Then, the motion event is dispatched to the Window. But as explained at the start, all the events are not dispatched to the whole widget tree, the window is filtering them."
msgstr ""

#: ../../sources/guide/inputs.rst:48
# d6bfaa638bc94072960b64ea68a2f654
msgid "if it's only a motion event, it will be dispatched to :meth:`~kivy.core.window.WindowBase.on_motion`"
msgstr ""

#: ../../sources/guide/inputs.rst:49
# 057bdfb9e95649a39b42b3ef335c58fe
msgid "if it's a touch event, the x/y position of the touch (0-1 range) will be scaled to the Window size (width/height), and dispatched to:"
msgstr ""

#: ../../sources/guide/inputs.rst:51
# 571814b30c274bc3901de80a1b11f4a8
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_down`"
msgstr ""

#: ../../sources/guide/inputs.rst:52
# c9bc4ff44e67494aaf06f33558d82a3b
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_move`"
msgstr ""

#: ../../sources/guide/inputs.rst:53
# b68a70e7056a403baaeaa3b14882994c
msgid ":meth:`~kivy.uix.widget.Widget.on_touch_up`"
msgstr ""

#: ../../sources/guide/inputs.rst:57
# 4eabe25425ba49fea6f5a17a4fbf1cc9
msgid "Motion event profiles"
msgstr ""

#: ../../sources/guide/inputs.rst:59
# 0f9b86abe1e64150b262a791719468f0
msgid "Depending of your hardware and the input providers used, you can have more information. For example, a touch have x/y position, but might have pressure information, blob size, acceleration vector etc."
msgstr ""

#: ../../sources/guide/inputs.rst:63
# d3728e0100204de59be9d4b57c767212
msgid "A profile is a string that indicate what features is available inside the motion event. For example, let's imagine that you are in a on_touch_move method::"
msgstr ""

#: ../../sources/guide/inputs.rst:71
# 8fae8f914eb947b7babaf1779a73476f
msgid "The print could output::"
msgstr ""

#: ../../sources/guide/inputs.rst:77
# 21dc4e30655b4f5dae30f3e2e760d7ec
msgid "Most peoples are mixing the profile name and the properties available. Checking for 'angle' in profiles doesn't mean that a properties 'angle' exist."
msgstr ""

#: ../../sources/guide/inputs.rst:81
# 84ddaeacbb4c4073831c7c096a48b8dc
msgid "The 'pos' profile mean that the properties 'pos', 'x' and 'y' will be available. The 'angle' profile mean that the property 'a' will be available. As we said, for touch event, pos is a mandatory profile. But not angle. You can extend your interaction by checking if the angle profile exist::"
msgstr ""

#: ../../sources/guide/inputs.rst:91
# 9b3b805be67c4a7caf5edebeadd97e9b
msgid "You can find a list of available profiles in the :ref:`motionevent` documentation."
msgstr ""

#: ../../sources/guide/inputs.rst:95
# 0344b0b14c5b4e84a7e279a798667494
msgid "Touch events"
msgstr ""

#: ../../sources/guide/inputs.rst:97
# cb943291cad2427d9ee6812f3c364084
msgid "A touch event is a specialized :class:`~kivy.input.motionevent.MotionEvent` with the property :data:`~kivy.input.motionevent.MotionEvent.is_touch` to True. For all touch event, you have automatically the X and Y position available, scaled to the Window width and height."
msgstr ""

#: ../../sources/guide/inputs.rst:102
# 16eff17d5c574e05a2e4682ad302702f
msgid "All the touch event have also the \"pos\" profile."
msgstr ""

#: ../../sources/guide/inputs.rst:104
# 9b5c6c39cc5548fbb2d20437c32d9523
msgid "You must take care about matrix transformation in your touch as soon as you use a widget with matrix transformation. Some widgets as Scatter have their own matrix transformation, mean the touch must be multiply by the matrix scatter to be able to correctly dispatch touch position in the Scatter's children."
msgstr ""

#: ../../sources/guide/inputs.rst:109
# a952e2f0f25f4e43932291558a86596f
msgid "Get coordinate from parent space to local space: :meth:`~kivy.uix.widget.Widget.to_local`"
msgstr ""

#: ../../sources/guide/inputs.rst:111
# c4d2574c0fa94ee0b06400a9bf3e0136
msgid "Get coordinate from local space to parent space: :meth:`~kivy.uix.widget.Widget.to_parent`"
msgstr ""

#: ../../sources/guide/inputs.rst:113
# 9697461b2bad4de889f77f9079f9cdfd
msgid "Get coordinate from local space to window space: :meth:`~kivy.uix.widget.Widget.to_window`"
msgstr ""

#: ../../sources/guide/inputs.rst:115
# 6acdfab641194fce97fbb7444313a987
msgid "Get coordinate from window space to local space: :meth:`~kivy.uix.widget.Widget.to_widget`"
msgstr ""

#: ../../sources/guide/inputs.rst:118
# 9509573f55f845e1ac825d0cdd03553b
msgid "You must use one of them to get the good coordinate. Let's take the scatter implementation::"
msgstr ""

#: ../../sources/guide/inputs.rst:141
# 587196e407cd44caa2024b50d5377830
msgid "Touch shapes"
msgstr ""

#: ../../sources/guide/inputs.rst:143
# 0b07cb80fca0499aba2aba39c62a2d8b
msgid "If the touch have a shape, it will be reflected in the 'shape' property. Right now, only a :class:`~kivy.input.shape.ShapeRect` could be exposed::"
msgstr ""

#: ../../sources/guide/inputs.rst:154
# 1586cae4f76b43b58e5e64051c506fbb
msgid "Double tap"
msgstr ""

#: ../../sources/guide/inputs.rst:156
# 9bc11cc5cf9c40e385fb797bf150630b
msgid "The double tap is the action of tapping twice in within a time and a distance. It's calculated by the doubletap post-processing module. You can test if the current touch is one of a double tap or not::"
msgstr ""

#: ../../sources/guide/inputs.rst:169
# 152b4b419bde4c4380dc460206e6e193
msgid "Grabbing touches"
msgstr ""

#: ../../sources/guide/inputs.rst:171
# 5cb47f8cb80941f68b405e65f17dfe44
msgid "It can happen that your parent dispatch to you a touch in on_touch_down but not in on_touch_move and on_touch_up. They might have severals reasons, like the touch movement is outside the bounding box of your parent, and the parent think that you don't need to know about it."
msgstr ""

#: ../../sources/guide/inputs.rst:176
# 3580802869904fb2a5301a8356077126
msgid "But you might want to do an action when the touch is going up. If you have started something at the down event, like playing a sound, how can you do to have the touch up ? Grabbing is made for that."
msgstr ""

#: ../../sources/guide/inputs.rst:180
# 496159ef60ad4d9f899b5268929883c2
msgid "When you grab a touch, you will always receive the move and up event. But they are some limitations to that:"
msgstr ""

#: ../../sources/guide/inputs.rst:182
# 9f49874a086147f7ae2578dde3f57c6a
msgid "You will receive the event at least twice: one time from your parent (the normal thing), and one time by the window (grab)."
msgstr ""

#: ../../sources/guide/inputs.rst:184
# 562a2bed9bfe46d78d4b7988abe1e41d
msgid "You might receive an event with a grab touch, but not from you: it can be because the parent have sent the touch to the children, while it was in grabbed state."
msgstr ""

#: ../../sources/guide/inputs.rst:187
# 902dcafdab7d4db89de7b54b552316a6
msgid "The touch coordinate is not translated to your widget space. BBecause the touch is coming directly from the Window. It's your job to convert the coordinate to your local space."
msgstr ""

#: ../../sources/guide/inputs.rst:191
# b0c0261518044bf981e2e1c7d2a3a0bf
msgid "Here is an example about how to use it::"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:5
# 96875dbb88254bc896d3d02886426619
msgid "Integrating with other Frameworks"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:9
# edadb05b3987489b9a3202853b5ce820
msgid "Using Twisted inside Kivy"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:12
# 687ed2f1d14d4085b4f50d4095d242c0
msgid "You can use the `kivy.support.install_twisted_reactor` function to install a twisted reactor that will run inside the kivy event loop."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:15
# c1cf3f975fd142a88573a316de6137af
msgid "Any arguments or keyword arguments passed to this function will be passed on the the threadedselect reactors interleave function, these are the arguments one would usually pass to twisted's reactor.startRunning"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:20
# daa40b9450fb44a7be5ad445f3e7f5df
msgid "Unlike the default twisted reactor, the installed reactor will not handle any signals unnless you set the 'installSignalHandlers' keyword argument to 1 explicitly.  This is done to allow kivy to handle teh signals as usual, unless you specifically want the twisted reactor to handle the signals (e.g. SIGINT)."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:28
# f561a11cc57845e38d33cae423778b6c
msgid "The kivy examples include a small example for a twisted server and client. The server app has a simple twisted server running and log any messages. The client app can send messages to teh server and will print its message and the repsonse it got. The examples are based mostly on simple Echo example from the twisted docs, which you can find here: - http://twistedmatrix.com/documents/current/core/examples/simpleserv.py - http://twistedmatrix.com/documents/current/core/examples/simpleclient.py"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:36
# 61da15a3015b43fa8da08a3e32c87db7
msgid "To try the example run echo_server_app.py first, and then launch echo_client_app.py.  The server will, reply with simple echo messages to anything the client app sends, when you hit enter after typing something in the textbox."
msgstr ""

#: ../../sources/guide/other-frameworks.rst:42
# 71840a55e8a04de7b009fa64ec019f64
msgid "Serer App"
msgstr ""

#: ../../sources/guide/other-frameworks.rst:47
# f23067c878334d9cace5119435633e3d
msgid "Client App"
msgstr ""

#: ../../sources/guide/packaging.rst:4
# 2c9db2838fcc4c8ab47231a2a0cc904f
msgid "Packaging your application"
msgstr ""

#: ../../sources/guide/packaging-android.rst:4
# 899fc713bba241e18add893cc1cf5b4d
msgid "Create a package for Android"
msgstr ""

#: ../../sources/guide/packaging-android.rst:7
# 9a706f8ed68349dcb52731a58a9d6bc3
msgid "Packaging your application into APK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:9
# 3b52a10494814e06a1683a035ec38b6f
msgid "To be able to package your Kivy application into an APK, you must have some tools available in your PATH:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:12
# 9ffe83fcfa844811b98bb0599edc6d8d
msgid "Java"
msgstr ""

#: ../../sources/guide/packaging-android.rst:13
# 21d13393351244498bbd01a7ebd87daa
msgid "Python 2.7 (not 2.6.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:14
# 9f1a0d091041463592b6e311963fbb56
msgid "Jinja2 (python module)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:15
# 01291ce077864dbebf317746b9c3d79b
msgid "Apache ant"
msgstr ""

#: ../../sources/guide/packaging-android.rst:16
# c9d10af58d094362960f4a0cbe59fabd
msgid "Android SDK"
msgstr ""

#: ../../sources/guide/packaging-android.rst:18
# 5ff1dccb820e4905945b230a27ec9810
msgid "You must download the tool named Kivy-XXX-android.zip, available at http://code.google.com/p/kivy/downloads/list, and unzip it."
msgstr ""

#: ../../sources/guide/packaging-android.rst:22
# 1f668ca0a4404fae96cb240bc74868f9
msgid "Build in debug mode"
msgstr ""

#: ../../sources/guide/packaging-android.rst:24
# e982099df75f40089791354401f69397
msgid "Inside the package, you have a tool named build.py. This is the script that will create APK for you::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:36
# 7a064d5b63514512a7b708ce8845b771
msgid "The last argument stand for:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:38
# 243916b37d0244f6bacec9e0043c6d1a
msgid "debug: build debug version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:39
# 91ba3c5c21764ffdb872429883f6034e
msgid "install: same as debug + upload on connected device"
msgstr ""

#: ../../sources/guide/packaging-android.rst:40
# 1cedd4ff86654a03aa7ff536095210ea
msgid "release: build release version and save to bin directory"
msgstr ""

#: ../../sources/guide/packaging-android.rst:42
# f4619360c67b40a0b62a9ef13b780e70
msgid "For example, if we imagine that touchtracer demo of Kivy is in the directory ~/kivy/examples/demo/touchtracer, you can do::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:49
# 8279f6820c2c40a0a17e355b4ef5583a
msgid "The debug binary will be generated in bin/KivyTouchtracer-1.0.6-debug.apk."
msgstr ""

#: ../../sources/guide/packaging-android.rst:51
# c7113f7706bf4882ae96873240802d3e
msgid "Then in later time, you can install directly to your android device by doing::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:55
# 87140f20f6174c049c7183bd25c69522
msgid "Or you can use the `install` method instead of `debug`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:58
# 412995b24d3b4f56bec46b35ab7c10af
msgid "Video support"
msgstr ""

#: ../../sources/guide/packaging-android.rst:62
# b36d4fb445c844aa977df7747aeebf06
msgid "By default, the produced APK don't contain any libraries for video support. You can add ffmpeg library on your build to activate it. The default ffmpeg compiled is the \"minimal support\", and will increase the APK size of ~8MB."
msgstr ""

#: ../../sources/guide/packaging-android.rst:66
# bcc16220e95c412ea2448ba09abf2201
msgid "The option to add on the build.py command line is `--with-ffmpeg`::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:71
# 7e68dfb1002c4464b689df7c993e5b7e
msgid "Release on the market"
msgstr ""

#: ../../sources/guide/packaging-android.rst:73
# 1b14926e7b434bc483d76a53a8e45e87
msgid "Launch the build.py script again, with the `release` command, then, you must sign and zipalign the apk.  Read the android documentation at:"
msgstr ""

#: ../../sources/guide/packaging-android.rst:76
# f5a5b7fa053a4a33b7275a5096c0f4a0
msgid "http://developer.android.com/guide/publishing/app-signing.html"
msgstr ""

#: ../../sources/guide/packaging-android.rst:78
# 4bcae3a5337a4c22b913ac0c3ae1b9ec
msgid "The release binary will be generated in bin/KivyTouchtracer-1.0.6-unsigned.apk (for previous touchtracer example.)"
msgstr ""

#: ../../sources/guide/packaging-android.rst:83
# 1f2cccd020564d4799db4798a5f28247
msgid "Packaging your application for Kivy Launcher"
msgstr ""

#: ../../sources/guide/packaging-android.rst:85
# c6cff93a3801400b9667bce1f3b0f9e8
msgid "The Kivy launcher is an application to run any Kivy examples stored on your SD Card from android. See :ref:`androidinstall`."
msgstr ""

#: ../../sources/guide/packaging-android.rst:88
# b66af4fc3b9f4fe3afd89b6f039dcf9b
msgid "Your application must be saved into::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:92
# 9976003d61d8431580635eae8c692533
msgid "Your application directory must contain::"
msgstr ""

#: ../../sources/guide/packaging-android.rst:99
# cb3d9d3a92e3496ba741288e82ddb826
msgid "The file `android.txt` must contain::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:2
# 43689be894a64d8aa03d860581ce0d2c
msgid "Create package for MacOSX"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:4
# 383ba517494343f9861a651996671cd7
msgid "Packaging your application for MacOSX 10.6 platform can be done only inside the MacOSX. The following method have been tested only inside VirtualBox and MacOSX 10.6, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:8
# b74832cee4974ffa9a41cfa40fb96b12
msgid "The package will be only for 64 bits MacOSX. We have no way to do 32 bits right now, since we are not supporting 32 bits MacOSX platform."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:12
#: ../../sources/guide/packaging-windows.rst:12
# ccf63901d5d54d558cb2d86d60e41eed
# 9bfc41d2bf9d42b2859063f420efff0f
msgid "Requirements"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:14
#: ../../sources/guide/packaging-windows.rst:14
# 12a659bd5752436dbbba13fcf0a266e8
# 6309fa2ac4884b308b5bca935f9204b9
msgid "Latest Kivy (the whole portable package, not only the github sourcecode)"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:15
#: ../../sources/guide/packaging-windows.rst:15
# 44536cbb0b254505bc748efb2bcdeb5c
# 5124c9c1d30a4b488ef0ffdc90d2fa1d
msgid "PyInstaller 1.5: http://www.pyinstaller.org/#Downloads"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:18
#: ../../sources/guide/packaging-windows.rst:18
# 3052a47042c34c3bbc61f510f3263f4e
# 0c901d2643f0449ba8486b55c0d4004a
msgid "Install and configure PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:20
# c228c9b5c9ac4fb7b042ef69cfad3da4
msgid "First, we need to setup correctly pyinstaller for 64 bits if you want to be able to package your Kivy application."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:23
# ea30c984974a461197783e177966c8da
msgid "Decompress the PyInstaller"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:24
# f127663265e648d980264ef6739d03c4
msgid "Open a console, and go to the pyinstaller-1.5 directory"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:25
# 056455259c3f44099e18eb284fc951e4
msgid "Execute the following::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:37
# fd84681ee66344daafed45bab023b29e
msgid "Now, your pyinstaller installation is ready to be used !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:40
#: ../../sources/guide/packaging-windows.rst:28
# 3a6590b32ab24035ab59eedde342b33a
# 14841c47653e4edc9d3c0f402ec134cd
msgid "Create the spec file"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:42
# e7d59ed0aff34a4d9872d42a10639489
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `../kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`. Replace both path/filename according to your system."
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:46
#: ../../sources/guide/packaging-macosx.rst:76
# 38339155bafe4347b321e4b0f6b22d52
# 3fdd8e01e1474f53b657423a067e432d
msgid "Open a console"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:47
#: ../../sources/guide/packaging-windows.rst:35
# 6407a39c93cd431ba15e0f572adcfcc8
# f4c533057f8c40c48cbe3b2f7d796cc2
msgid "Go to the pyinstaller directory, and create the initial specs::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:52
#: ../../sources/guide/packaging-windows.rst:44
# 71858b762fdd4021abe20342887399b2
# 00405d7fa5ce4d309f39ff15fd378afd
msgid "The specs file is located on `touchtracer/touchtracer.spec` inside the pyinstaller directory. Now we need to edit the spec file to add kivy hooks for correctly build the exe. Open the spec file with your favorite editor and put theses lines at the start of the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:61
#: ../../sources/guide/packaging-windows.rst:53
# 3ec2434b0ccd4533a1d3cb840f738611
# 865b6d6904c7473f82f09b4394ef7ba2
msgid "Then, you need to change the `COLLECT()` call to add the data of touchtracer (`touchtracer.kv`, `particle.png`, ...). Change the line to add a Tree() object. This Tree will search and add every files found in the touchtracer directory to your final package::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:71
#: ../../sources/guide/packaging-windows.rst:63
# ae7ee78faf78447e8061aa46aff86228
# 80fdc441da644809b3fd174333cd3394
msgid "This is done, your spec is ready to be executed !"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:74
# 33ac29aa5d7b44a0b5e800905b83600a
msgid "Build the spec and create DMG"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:77
#: ../../sources/guide/packaging-windows.rst:69
# bbc080d75ce847e5bdfddf35aceb088b
# 2704389e881e479fbbfe29bda704f62b
msgid "Go to the pyinstaller directory, and build the spec::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:82
# 74cd0ca4ed184bd1ba8b4d8b14759891
msgid "The package will be the `touchtracer/dist/touchtracer` directory. Rename it to .app::"
msgstr ""

#: ../../sources/guide/packaging-macosx.rst:89
# 97726ac1db274859a5d9a69780b11669
msgid "You will have a Touchtracer.dmg available in `touchtracer/dist` directory"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:2
# 7fce67fd23b544e1b21dad1e9d821faf
msgid "Create package for Windows"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:4
# 55a05a8df15d4f1d844a312ae4c58b83
msgid "Packaging your application for Windows platform can be done only inside the Windows OS. The following method have been tested only inside VirtualBox and Windows Seven, using the portable package of Kivy."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:8
# ac353b7548d941f3af7887bc99f9d92d
msgid "The package will be 32 bits, and can be runned on both 32/64 bits windows platform."
msgstr ""

#: ../../sources/guide/packaging-windows.rst:20
# 231b3c69ab18467184702dd220b5ead3
msgid "Decompress the PyInstaller in the Kivy portable package"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:21
#: ../../sources/guide/packaging-windows.rst:34
# e18cade4a7314633a965ad6c3dd3dd6c
# f0c00c8b1b2d4376b5fe6cdd5831d6f6
msgid "Double click on the Kivy.bat, a console will be open"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:22
# 9cb59b0bc20b435cb30c32a0f2820a70
msgid "Go to the pyinstaller directory, and run only once the Configure.py::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:30
# 688247f25fd1429ab124e83a1f735219
msgid "For the example, we'll package touchtracer example, using a custom icon. The touchtracer is the `kivy/examples/demo/touchtracer/` directory, and the main file is named `main.py`"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:40
# f15efe8e6539454b87c2d2261e054f46
msgid "Alternatively, you can add an icon.ico to the main executable. If you don't have any .ico file available, you can convert your icon.png file to ico with the http://www.convertico.com/. Save the icon.ico in the touchtracer directory and do::"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:66
# 16b3ad1baee547148c96e582b6a64c12
msgid "Build the spec"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:68
# 9102cb21e3d549bcb03b6f1025bf4e8c
msgid "Double click on Kivy.bat"
msgstr ""

#: ../../sources/guide/packaging-windows.rst:74
# 85052a7fdc3742668734e9eea5487663
msgid "The package will be the `touchtracer\\\\dist\\\\touchtracer` directory !"
msgstr ""

#: ../../sources/guide/platform.rst:2
# fd23bf3150d94da99378c797e11c788c
msgid "Running on Mobile Platforms"
msgstr ""

#: ../../sources/guide/quickstart.rst:4
# 75792cc5acd247e1aa7ab74193129d07
msgid "Quickstart"
msgstr ""

#: ../../sources/guide/quickstart.rst:6
# 9c96a146b4774f7a835c3c5ff76b4768
msgid "This page explains how to create a simple Kivy *\"Hello world\"* program. This assumes you already have Kivy installed. If you do not, head over to the :ref:`installation` section. We also assume basic `Python <http://docs.python.org/tutorial/>`_ 2.x knowledge throughout the rest of this documentation."
msgstr ""

#: ../../sources/guide/quickstart.rst:13
# 08435a5d5b00442185d73d6e029cdaca
msgid "Create an application"
msgstr ""

#: ../../sources/guide/quickstart.rst:15
# 42e19d6c24ec4a0ba34e813b54100c34
msgid "The base code for creating an application looks like this:"
msgstr ""

#: ../../sources/guide/quickstart.rst:32
# 3c3311a384114e99b9168d197aec6d62
msgid "Save it as `main.py`."
msgstr ""

#: ../../sources/guide/quickstart.rst:34
# c2a0e059476a46e793338a1b1d267e04
msgid "To run the application, follow the instructions for your operating system:"
msgstr ""

#: ../../sources/guide/quickstart.rst:37
# 0fdb3e9156ff4a83a0b8f9abb03df9b3
msgid "Follow the instructions for :ref:`running Kivy application on Linux <linux-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:42
# 0c20391cddd94e04bf1b60ac7dbe5b00
msgid "Follow the instructions for :ref:`running Kivy application on Windows <windows-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:49
# d051acab44a44c22be858bf98d394c29
msgid "Follow the instructions for :ref:`running Kivy application on MacOSX <macosx-run-app>`::"
msgstr ""

#: ../../sources/guide/quickstart.rst:54
# 91c079a372ab4c0badc9e431998f5293
msgid "Your application needs some complementary files to be able to run on Android. See :doc:`android` for further reference."
msgstr ""

#: ../../sources/guide/quickstart.rst:57
# 8353831db6994b6099c299ce6dca754a
msgid "A window should open, showing a sole button (with the label 'Hello World') that covers the entire window's area. That's all there is to it."
msgstr ""

#: ../../sources/guide/quickstart.rst:63
# 23d38640918a41eca44e39b476effc47
msgid "So what does that code do?"
msgstr ""

#: ../../sources/guide/quickstart.rst:65
# 9e0f3d8223d045bf8684a013ea65cae7
msgid "First, we import Kivy, and check if the current installed version will be enough for our application. If not, an exception will be automatically fired, and prevent your application to crash in runtime. You can read the documentation of :func:`kivy.require` function for more information."
msgstr ""

#: ../../sources/guide/quickstart.rst:69
# 0f6793a2edce4e3f8d7124dcc76a3987
msgid "We import the :class:`~kivy.app.App` class, to be able to subclass it. By subclassing this class, your own class gains several features that we already developed for you to make sure it will be recognized by Kivy."
msgstr ""

#: ../../sources/guide/quickstart.rst:73
# eb96389d2a8b42b4bc077add46b03b1e
msgid "Next, we import the :class:`~kivy.uix.button.Button` class, to be able to create an instance of a button with a custom label."
msgstr ""

#: ../../sources/guide/quickstart.rst:75
# abdc954e81fb4e0eac1d175a07baa467
msgid "Then, we create our application class, based on the App class. We extend the :meth:`~kivy.app.App.build` function to be able to return an instance of :class:`~kivy.uix.button.Button`. This instance will be used as the root of the widget tree (because we returned it)."
msgstr ""

#: ../../sources/guide/quickstart.rst:79
# ee4ceea59d76412081317009fb0c7cbb
msgid "Finally, we call :meth:`~kivy.app.App.run` on our application instance to launch the Kivy process with our application inside."
msgstr ""

#: ../../sources/guide/readingdoc.rst:2
# 4fdf7344c8fe4d258178e674dd4fa37f
msgid "How to read the documentation"
msgstr ""

#: ../../sources/guide/readingdoc.rst:4
# 9ecdc97b4ffb46b58895b88a8ced95ee
msgid "The documentation is seperated in 2 parts:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:6
# 9d916332fd524a73805a57b6c35efaee
msgid "the Programming Guide: it's a must read to understand the Kivy basics, specially if you never done GUI programming before."
msgstr ""

#: ../../sources/guide/readingdoc.rst:8
# 00eab4bc4ee144a7921f071ed86599dd
msgid "the API: all the functions, classes, methods are explained."
msgstr ""

#: ../../sources/guide/readingdoc.rst:12
# c4d9900fe3db4a81b23cb40e6b1abfbc
msgid "Importing a class"
msgstr ""

#: ../../sources/guide/readingdoc.rst:14
# 9fb8ab7dc5b8425a8e50d04a92fd4456
msgid "The API part is autogenerated from the source code. If you take any class, it will be generated like this:"
msgstr ""

#: ../../sources/guide/readingdoc.rst:19
# 14a47dc77c79417ab6e1b0514b9d271b
msgid "It must readed like this: the \"Button\" class is into the \"kivy.uix.button\" module. So if you want to import that class in your code, write that::"
msgstr ""

#: ../../sources/guide/widgettree.rst:4
# 4e489f85d8734ab2877a59e0398a7374
msgid "Widget tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:6
# 501b05cedff44709a2b479b804bc282a
msgid "Like most of GUI toolkit, Kivy have a tree for handling a hierarchy of widgets. The top level widget is called \"root\". Each widget can be connected to others widgets, as a parent or as a child."
msgstr ""

#: ../../sources/guide/widgettree.rst:10
# 8a96a18be7ab44d2941e9dab71cf2576
msgid "You cannot add into the widget tree something that is not a :class:`~kivy.uix.widget.Widget` subclass."
msgstr ""

#: ../../sources/guide/widgettree.rst:14
# 89ae85b3cb874cd2ae62b4f7a09fc663
msgid "Manipulating the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:16
# 7178d700bdcc4d1a97a4b22e1bf4b67a
msgid "The tree can be manipulated with 3 methods:"
msgstr ""

#: ../../sources/guide/widgettree.rst:18
# cc7e04eaca804e839422f22c62654a44
msgid ":meth:`~kivy.uix.widget.Widget.add_widget`: add a widget as a child"
msgstr ""

#: ../../sources/guide/widgettree.rst:19
# f3f27c872983487486b0770cc83dfd77
msgid ":meth:`~kivy.uix.widget.Widget.remove_widget`: remove a widget from the children list"
msgstr ""

#: ../../sources/guide/widgettree.rst:21
# 306a994e89404799b037981a8d6ce6d1
msgid ":meth:`~kivy.uix.widget.Widget.clear_widgets`: remove all children from a widget"
msgstr ""

#: ../../sources/guide/widgettree.rst:24
# 4deff96009ef4a7ca8536378c8c1f5bf
msgid "For example, if you want to add a button inside a boxlayout, you can do::"
msgstr ""

#: ../../sources/guide/widgettree.rst:30
# f24b41e4f375494eaa22a3b658be79db
msgid "Now, the button parent will be set to layout, and layout will have button in his children list. To remove the button from the layout::"
msgstr ""

#: ../../sources/guide/widgettree.rst:35
# 67913c095e5c45e085563e52097d78ba
msgid "The button parent will be set to None, and layout will remove button from his children list."
msgstr ""

#: ../../sources/guide/widgettree.rst:38
# 0ec8183f18264c61a4d1d2fddee28c2e
msgid "If you want to clear all the children inside a widget, use :meth:`~kivy.uix.widget.Widget.clear_widgets` method::"
msgstr ""

#: ../../sources/guide/widgettree.rst:45
# e44e1fdeb2664d64a3382d2e6ce24d86
msgid "Never manipulate the children list yourself, if you don't know what you are doing. The widget tree is associated to a graphic tree. For example, if you add a widget into the children list without adding his canvas to the graphics tree, the widget will be a children yes, but nothing will be drawed on the screen. More than that, you might have issue on further call of add_widget, remove_widget and clear_widgets."
msgstr ""

#: ../../sources/guide/widgettree.rst:54
# 00157811e5fc4afd8d0b4057ed1cb0e7
msgid "Traversing the tree"
msgstr ""

#: ../../sources/guide/widgettree.rst:56
# 0bf9588d08d6448faf5af756093c011f
msgid "The widget class have a :data:`~kivy.uix.widget.Widget.children` list property that contain all the children. You can easily traverse the tree by doing ::"
msgstr ""

#: ../../sources/guide/widgettree.rst:64
# c4e60abefa4f4946b24404daf602c458
msgid "However, this must be used carefuly. If you intend to modify the children list with one of the methods showed in the previous section, you must use a copy of the list like this::"
msgstr ""

